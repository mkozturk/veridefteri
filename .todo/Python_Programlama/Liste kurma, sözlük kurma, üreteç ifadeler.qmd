---
title: Basit liste kurma
jupyter: python3
---

Python'da yeni bir liste oluşturmak için, boş bir listeden başlayabiliriz ve bir döngü içinde `append()` metoduyla büyütebiliriz. Bu yazıda bu işlemi daha hızlı verimli olarak yapmamızı sağlayan özel _liste kurma_ yazımını göreceğiz. Liste kurma, genel olarak bir _üreteç ifadesi_ örneğidir. Liste kurma gibi sözlük ve kümeleri de hızlıca kurmak için benzer bir yazım kullanırız.

Python Programlamaya Giriş yazı dizimizin bütün yazılarına erişmek için <a href="http://www.veridefteri.com/category/python-giris/"><em>Python Programlamaya Giriş</em></a> kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde <a href="https://github.com/sibirbil/VeriDefteri/tree/master/Python_Programlama">GitHub depomuzda</a> da mevcut.

Basit bir örnekle başlayalım: Bir sayı listesi alalım, ve liste elemanlarının karelerinden oluşan yeni bir liste oluşturalım. 

Şimdiye kadar gördüğümüz yöntemlerle bu işi yapmak için önce boş bir liste yaratırız, sonra bir `for` döngüsü içinde sayıları tek tek alırız, karelerini teker teker boş listeye ekleriz.


```{python}
sayılar = [1,2,3,4,5]
kareler = []
for x in sayılar:
    kareler.append(x*x)

kareler
```

Aynı işi daha kısa yoldan ve daha hızlı yapmak için Python'da _liste kurma_ (list comprehensions) denen bir yapı vardır.

```{python}
kareler = [x*x for x in sayılar]
kareler
```

En basit halinde, liste kurma yapısının genel hali şöyledir:

    [ <ifade> for <değişken> in <sıralı nesne> ]

Bu yapıda, `<sıralı nesne>`'deki değerler tek tek `<değişken>`'e atanır, ve `<ifade>`'nin değeri hesaplanarak listeye eklenir.

Yukarıdaki liste kurma ifadesi aşağıdaki kod parçasına denktir:

    L = []
    for <değişken> in <sıralı nesne>:
        L.append(<ifade>)

Birkaç örnek vererek açıklayalım. İkinin ilk on kuvvetinin listesi:

```{python}
[2**i for i in range(1,11)]
```

Bir dizedeki karakterleri tek tek almak:

```{python}
[c+"*" for c in "merhaba"]
```

Çokuzlardaki elemanların toplamlarının listesi:

```{python}
[ x[0] + x[1] for x in [(1,2), (2,-1), (4,2), (3,7)] ]
```

Yukarıdaki örnek, _çokuz ataması_ özelliği sayesinde şöyle de yazılabilir:

```{python}
[ x+y for x,y in [(1,2), (2,-1), (4,2), (3,7)] ]
```

Aradaki fark şöyle: Birinci durumda `x` değişkenine sırayla çokuzlar atanıyor, sonra indeksleme ile tek tek elemanlarını alıyoruz. İkinci durumda ise çokuzun birinci ve ikinci elemanı sırasıyla `x` ve `y` değişkenlerine atanıyor.

İfade olarak bir fonksiyon da kullanılabilir.

```{python}
def kare(x): return x*x
[kare(x) for x in range(1,11)]
```

```{python}
def topla(a,b): return a+b
[topla(x,y) for x,y in [(1,2), (2,-1), (4,2), (3,7)] ]
```

Liste kurma ifadelerinin döngülerden bir farkı da, döngü değişkeninin kalıcı olmamasıdır.

```{python}
[i*i for i in range(10)]
```

```{python}
i
```

Oysa bir döngü kullandığımızda iç değişkenler döngüden sonra da erişilebilir olurlar.

```{python}
L = []
for i in range(10):
    L.append(i*i)

i
```

Hız farkı
------
Liste kurma ile, bir döngü içinde bir listeye `append()` ile eleman ekleme aynı işi yapıyorsa, neden liste kurmayı kullanalım? Birincisi, daha sade bir yapı olduğu için. Daha da önemlisi, liste kurma işlemi daha hızlı çalışır.

Hız farkının iki sebebi vardır: Birincisi Python gibi yorumlanan dillerde döngülerin nispeten yavaş çalışmasıdır (C gibi derlenen dillere göre). Bir liste kurma ifadesi yine de örtük bir döngü içeriyor elbette, ama bu döngü alt seviyededir ve Python yorumlayıcısı tarafından yüksek hızda işletilir. İkinci sebep ise her iterasyonda listenin `append()` metodunun çağırılması gereğidir - fonksiyon çağrıları uzun zaman alan işlemlerdir ve programı yavaşlatırlar.

Bunu daha somut olarak görmek için 1 ile 1000 arasındaki sayıların karelerini alan bir liste kurma ve bir döngü oluşturalım ve iki yaklaşım arasındaki zaman farkına bakalım.

```{python}
%%timeit
[x*x for x in range(1000)]
```

```{python}
%%timeit
L = []
for x in range(1000):
    L.append(x*x)
```

Şartlı liste kurma
---
Liste kurma işleminde her elemanı eklemek zorunda değiliz; bir şartı sağlayanları da eklememiz mümkün. Sözgelişi, bir sayı listesi içinde, sadece beşten büyük olanların karesini barındıran bir liste oluşturalım.

```{python}
[x*x for x in [1,3,5,7,9,11] if x>5 ]
```

Bu ifade, aşağıdaki döngüye denktir:

```python
L = []
for x in [1,3,5,7,9,11]:
    if x>5:
        L.append(x*x)
```
Çeşitli karşılaştırma işlemleri ve mantıksal işlemler de birleştirilebilir. Örnek olarak, 1900 ile 2100 arasındaki artık yılların listesini oluşturalım. Bilindiği gibi bir yıl 4'e bölünebiliyorsa artık yıldır; 100'e bölünen ama 400'e bölünemeyen yıllar hariç. Yani 1600 ve 2000 yılları artık yıl iken, 1700, 1800, 1900, 2100 yılları artık değildir.

```{python}
[ y for y in range(1900, 2101) if (y%4 == 0 and y%100 != 0) or y%400 == 0 ]
```

Şartlı liste kurmanın genel ifadesi şöyledir:

    [<ifade> for <değişken> in <sıralı nesne> if <şart>]

Bu yapıda, sadece şartın doğru olduğu değişken değerleri için listeye eleman eklenir. Şart yanlışsa eklenmez. Eğer şart yanlış olduğunda da listeye belli değerler eklenmesini istiyorsak, daha önce gördüğümüz _üçlü if-else_ ifadesini kullanabiliriz.

Söz gelişi, girdi listesindeki sayı beşten büyükse o sayının karesini, değilse sıfırı barındıran bir liste kuralım.

```{python}
[x*x if x>5 else 0 for x in [1,3,5,7,9,11] ]
```

Buradaki `if-else` komutunun asıl ifadeye ait olduğuna dikkat edin; liste kurma şartı olarak kullanılmamıştır. 

İç içe döngülerle liste kurma
---
Diyelim iki ayrı listeden elemanları birleştirerek mümkün bütün çiftleri kurmak istiyoruz, (a,1), (a,2),.., (b,1), (b,2),... gibi. Bunun için birinci listedeki her bir eleman için ikinci listedeki elemanlar üzerinde döngü kurmamız gerek. Yani döngü içinde döngü kurmalıyız. Bunu alışıldık yöntemle şöyle yapabiliriz:

```{python}
liste = []
for c in "abcd":
    for b in [1,2,3]:
        liste.append((c,b))
liste
```

Aynı işi liste kurma işlemiyle yapmak da mümkündür:

```{python}
[(c,b) for b in (1,2,3) for c in "abcd"]
```

Başka bir örnek olarak, iki ayrı listeden alınan sayılar ve onların toplamlarından oluşan çokuzlarla bir liste kurabiliriz.

```{python}
[(a,b,a+b) for b in (1,2,3) for a in (4,5,6)]
```

Kullanabileceğimiz iç içe döngülerin sınırı yok, istediğimiz kadar derine inebiliriz.

```{python}
[(a,b,c,a+b+c) for c in (1,2) for b in (3,4) for a in (5,6,7)]
```

Her `for` ile beraber bir şart ekleyebiliriz.

```{python}
[(a,b,a+b) for a in (1,2,3,4) if a>2 for b in (5,6,7)]
```

```{python}
[(a,b,a+b) for a in (1,2,3,4) if a>2 for b in (5,6,7) if b<7]
```

Şartlarımız değişkenlerin hepsini birleştiren bir ifade halinde de olabilir. Örnek olarak, `a+b+c==10` şartını sağlayan bütün üçlüleri bulalım. Tekrarlardan kaçınmak için `b>=a` ve `c>=b` şartlarını da koyalım.

```{python}
[ (a,b,c) for a in range(1,10) for b in range(a, 10) for c in range(b,10) if a+b+c==10 ]
```

Liste kurma ifadesinde solda kalan değişken sağ tarafta tanınır, ama tersi doğru değildir. Aşağıdaki kod yanlış olur:

```{python}
[ (a,b,c) for b in range(a,10) for a in range(1, 10) for c in range(b,10) if a+b+c==10 ]
```

Liste kurmanın yorumlanması sol taraftan başladığı için, yukarıdaki örnekte `a` henüz tanımlanmamış oluyor ve yorumlayıcı hata mesajı veriyor. Bu davranışı anlamak için yukarıda bir önceki örneği döngülerle yazalım:

    L = []
    for a in range(1,10):
        for b in range(a,10):
            for c in range(b,10):
                if (a+b+c==10):
                    L.append((a,b,c))
              
Buradan da görülebileceği gibi, `for b in range(a,10):` satırı önce gelirse, `a`'nın değeri tanımsız oluyor.

Genel liste kurma ifadesi ve dengi olan döngüler
----
Liste kurma ifadesinin en genel hali şöyle yazılabilir:

    [ <ifade> for <değişken_1> in <sıralı_1> if <şart_1>
    for <değişken_2> in <sıralı_2> if <şart_2>
    ...
    for <değişken_N> in <sıralı_N> if <şart_N> ]

Burada `if` kısımları mecburi değil. Bu yapı ilk bakışta yadırgatıcı geliyorsa, aynısının döngü karşılığını göz önünde tutmak faydalı olabilir.

    liste = []
    for <değişken_1> in <sıralı_1>:
        if <şart_1>:
            for <değişken_2> in <sıralı_2>:
                if <şart_2>:
                ....
                          for <değişken_N> in <sıralı_N>:
                              if <şart_N>:
                                  liste.append(<ifade>)

İç içe listeler ve matrisler kurma
----
Bir önceki bölümde gördüğümüz iç içe `for` döngülerinin tek seviyeli bir liste kurduğuna dikkat edin. Listeye yeni eleman eklemek ancak en içteki döngüde gerçekleşiyor. Eğer bir _listeler listesi_ oluşturmak istiyorsak başka bir yaklaşım kullanacağız, yani bir liste kurma işlemini başka birinin içine yerleştireceğiz.

```{python}
[ [a+b for a in "abc"] for b in "xyz"]
```

Bir matris bir listeler listesi olarak yazılabilir. Listenin her elemanı (satır) bir listedir. Sözgelişi, $\left[\begin{array}{ccc}1&2&3\\ 4&5&6\\7&8&9\end{array}\right]$ matrisini bu şekilde temsil etmek için aşağıdaki yapıyı kullanabiliriz.

```{python}
[ [3*sütun + satır for satır in [1,2,3] ] for sütun in [0,1,2] ]
```

Daha karmaşık bir örnek olarak, _Kronecker delta_ $\delta_{i,j}$ matrisi, yani diyagonal elemanları 1, diğer elemanları 0 olan matris bir üçlü if-else ifadesiyle yazılabilir:

```{python}
[ [ 1 if satır==sütun else 0 for sütun in range(5)] for satır in range(5)]
```

Üreteç ifadeler
---
Yukarıda gördüğümüz liste kurma yapısı, aslında daha genel ve daha verimli olan _üreteç ifadeleri_ nin (generator expressions) özel bir durumudur. İlk örneğimizi, bir üreteç olarak şöyle yazabiliriz:

```{python}
(x*x for x in [1,2,3,4,5])
```

Somut bir listeye çevirmek için bu üreteç ifadesini çıplak halde (çevresinde parantezler olmadan) bir `list()` fonksiyonuna verebiliriz. Bu, liste kurma ifadesiyle birebir aynı sonucu verir.

```{python}
list(x*x for x in [1,2,3,4,5])
```

Üreteçler, sıralı nesneler gibi iterasyonlarda kullanılabilirler. Önemli bir farkları vardır: Bütün elemanları bir seferde yaratılıp bellekte saklanmaz. Bunun yerine, her eleman sırası geldikçe üretilir. Üreteç en son kaldığı yeri aklında tutar.

```{python}
g = (x*x for x in [1,2,3,4,5])
next(g), next(g), next(g)
```

Üreteci bir döngüde kullanabiliriz:

```{python}
for i in g:
    print(i)
```

Üreteç ifadelerinin listelere göre avantajı daha az yer kaplamalarıdır. Bir listede bütün elemanlar baştan sonra üretilip bellekte saklanırken, bir üreteçte her eleman sadece ihtiyaç duyulduğu anda (söz gelişi, döngüde sırası geldiği zaman) dinamik olarak üretilirler. Özellikle çok elemanlı dizilerde bu önemli miktarda bellek tasarrufu sağlayabilir.

Üreteç ifadeleri, dizili nesne alan fonksiyonlara parametre olarak verilebilir:

```{python}
sum(1/(x*x) for x in range(1,1001))
```

Bir de kendi tanımladığımız fonksiyonla kullanalım.

```{python}
def çarpım(L):
    """Liste elemanlarının çarpımını döndürür."""
    p = 1
    for x in L:
        p *= x
    return p

çarpım(x+2 for x in range(1,6))
```

Çokuz ve küme kurma
----
Liste yerine küme kurmak için köşeli parantez `[]` yerine küme parantezi `{}` kullanmak yeterlidir. Aynı kurallar geçerlidir.

```{python}
{i for i in range(10) if i%3 > 0}
```

Ancak, yuvarlak parantez `()` üreteç kurma için kullanıldığından, çokuz üretmek için üreteci `tuple()` fonksiyonuna vermek gerekir.

```{python}
tuple( (i,i**2, i**3) for i in range(10) )
```

Sözlük kurma
----
Liste kurma yapısını sözlük kurmaya adapte etmek mümkündür. Sözlük kurma yapısında, ikililerden oluan bir sıralı nesne üzerinden iterasyon yapılır. İkililerin birinci elemanı sözlüğe anahtar, ikinci elemanı ise o anahtara ait değer olarak atanır.

```{python}
{k:v for k,v in (("a",1),("b",2),("c",6))}
```

Anahtarlar ve değerler ayrı nesnelerde sıralanmışlarsa, bunlar `zip()` fonksiyonuyla istenen biçime sokulabilir.

```{python}
anahtarlar = ("a","b","c")
değerler = (1,2,3)
{k:v for k,v in zip(anahtarlar,değerler)}
```

Bir sözlüğün `items()` metodu anahtar-değer ikililerinden oluşan bir dizi verir. Bu dizi üzerinden iterasyon yaparsak, mevcut bir sözlükteki verilerle yeni bir sözlük oluşturabiliriz.

Söz gelişi, `d` sözlüğündeki değerlerin karesini barındıran yeni bir sözlük oluşturalım:

```{python}
d = {'a': 1, 'b': 2, 'c': 3}
{k*2:v*v for k,v in d.items()}
```

Bu yöntemle bir sözlüğün anahtar ve değerlerini ters çevirmek çok kolaydır: 

```{python}
{v:k for k,v in d.items()}
```

Bu son örnekte, iki ayrı anahtarda aynı değer varsa, sonra gelenin öncekini sileceğine dikkat edin.

```{python}
d = {'a': 1, 'b': 2, 'c': 3, 'd':2}
{v:k for k,v in d.items()}
```

