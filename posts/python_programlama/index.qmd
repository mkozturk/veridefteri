---
title: Dinamik kod üretme
author: Kaan Öztürk
date: 'Jun 8, 2018'
image: magnolia.webp
categories:
  - Python Programlamaya Giriş
format:
  html:
    code-fold: false
jupyter: python3
---

Python _dinamik_ tabir edilen dillerden biridir. Programda kullandığıız değişkenlerin tiplerini baştan bildirmeniz gerekmez. Program çalıştıkça işlenen komutlar, yeni nesneleri anında üretir. Bu dinamiklik sayesinde, dize olarak verilmiş Python komutlarını da işleyebilir, hatta program yazan programlar yazabiliriz.

Bu işlemi yapmak için iki Python fonksiyonu vardır: `eval()` ve `exec()`

Dizinin bütün yazılarına erişmek için <a href="http://www.veridefteri.com/category/python-giris/"><em>Python Programlamaya Giriş</em></a> kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde <a href="https://github.com/sibirbil/VeriDefteri/tree/master/Python_Programlama">GitHub depomuzda</a> da mevcut.

## eval

Bu fonksiyon, Python komutları içeren bir dizeyi yorumlayıcıya gönderir ve sonucu geri verir.

```{python}
eval("2**3 + 4*5")
```

Çalıştırma anında isim alanında bulunan değişkenler de kod dizesi içinde kullanılabilir.

```{python}
x = 5
eval("2*x+4")
```

Komut dizesi içindeki değişkeni başka bir değerle kullanmak isterseniz, değişkenleri bir sözlük ile verebilirsiniz.

```{python}
eval("2*x+4",{"x":10})
```

### Örnek: Basit hesap makinesi.
Kullanıcıdan tek tek matematiksel ifadeler alıp sonucu yazan bir programcık yazalım. Kullanıcı "dur" yazdığında program sona ersin.

```{python}
işlemler = """1 + 2 + 3 + 4 + 5
2**2 + 3 * 5
1/10 + 1/5
"""
for işlem in işlemler.splitlines():
    print(işlem, " = ", eval(işlem))
```

### Örnek: Yardım belgeleri özetleri
Nesnelerin yardım belgelerini daha önce kullanmıştık. Bir metodla ilgili bilgi almak için `help()` komutunu kullandığımızda o metodun (bir fonksiyon nesnesidir) `__doc__` isimli özelliği ekrana basılır. Buna doğrudan da erişebiliriz.

```{python}
list.append.__doc__
```

Diyelim bir nesne sınıfı altında tanımlanmış bütün metodların kısa tarifini (belge dizesini) ekrana dökmek istiyoruz. Ama bir sınıf altında, daha özel amaçlı, doğrudan kullanılmayan metodlar da bulunur. Bunların başlarında ve sonlarında bir çift altçizgi ("dunder") bulunur.

Çift altçizgili metodları hariç tutarak, metodların kısa açıklamalarını listelemek için `eval`'i bir döngü içinde kullanabiliriz.

```{python}
for metod in dir(list):
    if "__" not in metod:
        print(eval("list."+metod+".__doc__"))
```

## exec

Değer döndüren ifadeleri `eval()` ile işletebiliriz, ama bir ifade (expression) olmayan, yani değer döndürmeyen komutları (söz gelişi, modül yükleme, fonksiyon tanımları, döngüler, atamalar vb.) çalıştırmak için `exec()` fonksiyonuna ihtiyacımız var.

Örnek olarak, bir değişken ataması yapalım:

```{python}
exec("""
import math
x=math.pi""")
x
```

Bir formülde değişkene 0-9 arası değerler vererek bir tablo oluşturan bir kod yazalım.

```{python}
değişken = "x"
formül = "1/(1+x) + x"
kod = """
for {0} in range(10):
    print({0}, {1})""".format(değişken, formül)
print(kod)
```

```{python}
exec(kod)
```

Farkedeceğiniz gibi, `değişken`'in değeri `"x"` olduğu için formülde de `x` karakterini kullanmamız gerekiyor.

## Global ve yerel değişkenler

`eval`/`exec` fonksiyonları, işletilecek kodu barındıran dizenin yanı sıra iki parametre daha alırlar: *globals* ve *locals*. Bu parametreler özellikle belirtilmezse, `eval`/`exec` kodunda yorumlayıcının o andaki durumunda tanımlanmış olan bütün isimler kullanılabilir.

_Yerel_ değişkenler bir fonksiyon içinden tanımlı olan, o fonksiyonun dışında tanınmayan isimlerdir. _Global_ değişkenler ise bütün fonksiyonların erişebileceği değişkenlerdir. Yerel isimlere `locals()`, global isimlere ise `globals()` komutlarıyla ulaşılabilir. Bu komutlar değişken isimleriyle değerlerini eşleştiren birer sözlük döndürür.

```{python}
def f(x):
    a = 10
    print(locals())

f(3)
```

`eval`/`exec` ile bir kod parçası çalıştırırken bu global ve yerel değişkenleri sınırlandırabiliriz. Bu fonksiyonların genel kullanımı şöyledir:

    eval(source, globals=None, locals=None)
    exec(source, globals=None, locals=None)

Burada `globals` ve `locals` parametreleri için global ve yerel değişkenleri tutan birer sözlük koyabiliriz.

```{python}
exec("print(locals())", None, {"abc": 17, "xyz": "Mehmet"})
```

```{python}
exec("print(globals())", None, {"abc": 17, "xyz": "Mehmet"})
```

_globals_ yerine boş bir sözlük koyarsak, sadece Python'da tanımlanmış (built-in) isimlere erişilebilir sadece

```{python}
exec("print(globals())", {}, {"abc": 17, "xyz": "Mehmet"})
```

Bunlara bile erişimi kapatmamız mümkündür, aşağıdaki bölümde göreceğimiz gibi.

## Güvenlik

Dışarıdan alınan bir kodu çalıştırmak her zaman risklidir. `exec()` ve `eval()` fonksiyonlarının bilgisayarınıza bir kapı açtığını unutmayın.

Tehlikeyi örneklemek için, yukarıdaki örneği tekrar ele alalım. Siz bir formül beklerken, kötü niyetli bir kullanıcı işletim sisteminizi yönetecek bir komutu bu formülle beraber verebilir. Meselâ, formül sorulduğunda

    'x); import os; os.system("touch hello.world");(0,
dizesinin verildiğini varsayalım.

```{python}
değişken = "x" # Formülde kullanılacak değişken.
formül = 'x); import os; os.system("touch hello.world");(0,'
kod = """
for {0} in range(10):
    print({0}, {1})""".format(değişken, formül)
```

Bu girdi sonucunda çalıştırılacak kod şöyle olur:

```{python}
print(kod)
```

Burada kötü niyetli kullanıcı beklenen formülü verdikten sonra parantezi kapatmış ve işletim sistemine yönelik komutlar eklemiş. (Sondaki `(0,` kısmı, kalıpta bulunan sağ parantezin sentaks hatası vermemesi için, onu etkisiz eleman haline dönüştürüyor.) 

Bu kodu `exec(kod)` ile çalıştırdığınızda ekrana sayılar tablosu çıkmasının yanı sıra, bu programı çalıştırdığınız dizinin altında _hello.world_ isimli boş bir dosya yaratıldığını göreceksiniz (Linux kullanıyorsanız). Yani program işletim sisteminize erişebildi. Kötü niyetli bir saldırgan aynı yöntemle diskinizi silebilir, şifrelerinizi çalabilir, virüs yerleştirebilir.

Bu risklere karşı alınabilecek kısmi tedbirler vardır. En yaygın olanı, `exec`'in çalıştığı sanal ortamdaki değişkenleri, _globals_ ve _locals_ parametreleri kullanarak düzenlemektir. Sözgelişi aşağıda, _globals_ parametresi olarak `{"__builtins__":None}` vermekle Python'un öntanımlı fonksiyonlarını kapatırız. Böylelikle `import` ile bir modül yüklenmesini ve işletim sistemine ulaşılmasını engelleriz. Bu işlem `range` ve `print` fonksiyonlarını da kapatır, o yüzden _locals_ parametresine bunların tanımlarını içeren bir sözlük veririz.

```{python}
exec(kod, {"__builtins__":None}, {"range":range, "print":print})
```

Bu yeni düzende `import` fonksiyonu tanınmadığı için `exec()` çağrısı bir hata verdi ve sızma engellendi. Aynı kodu beklenen şekilde bir girdiyle çalıştırdığınızda ise sorun yaşamazsınız. 

Matematik kütüphanesindeki fonksiyonları kullanan işlemler yapmak istiyorsanız, gereken fonksiyonlardan oluşan bir "beyaz liste" oluşturabilirsiniz.

```{python}
değişken = "x" # Formülde kullanılacak değişken.
formül = "x * sqrt(x+1)/log(x+2)"
kod = """
for {0} in range(10):
    print({0}, {1})""".format(değişken, formül)
```

```{python}
import math
exec(kod, {"__builtins__":None}, {"range":range, "print":print, "sqrt":math.sqrt, "log":math.log})
```

Kendi kullanacağınız programlar veya bir masaüstü uygulaması için fazla endişe etmek gerekmeyebilir. Yanlış veya kötü niyetli bir kullanım sadece kullanıcıya zarar verecektir. Ama bir web uygulaması yazıyorsanız güvenliğe çok daha fazla dikkat etmelisiniz. Bu, daha derin bir uzmanlık gerektirir.

------
Özetle, dinamik olarak üretilen bir kodu işletmek için `exec`/`eval` kullanabilirsiniz. Bunun yararlı olduğu çeşitli durumlar vardır. Söz gelişi, Python sentaksıyla yazılmış bir dizeyi doğrudan alıp işletmek gibi.

`exec`/`eval` ilk bakışta çok hoş görünseler de çok sık kullanılmamalıdırlar, bazı sakıncaları vardır.

* Kodu okumayı zorlaştırır. Programcı kaynak koduna ek olarak, çalıştırılmak üzere alınacak kodun ne olduğunu da bilmelidir.
* Kodu test etmeyi, hataları bulmayı zorlaştırır.
* Güvenlik açığı oluşturur.

`exec`/`eval` fonksiyonlarının işe yaradığı durumlar vardır, ama probleminizi önce başka yaklaşımlarla çözmeye çalışın.

