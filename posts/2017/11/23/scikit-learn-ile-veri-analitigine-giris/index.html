<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Birol Yüceoğlu">
<meta name="dcterms.date" content="2017-11-23">

<title>Veri Defteri - scikit-learn ile Veri Analitiğine Giriş</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../../">
<link href="../../../../../img/veridefteri_ikon.png" rel="icon" type="image/png">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Veri Defteri</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html" rel="" target="">
 <span class="menu-text">Hakkımızda</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/veridefteri" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">scikit-learn ile Veri Analitiğine Giriş</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Başlangıç</div>
    <div class="quarto-category">yapay öğrenme</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Birol Yüceoğlu </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 23, 2017</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>Veri bilimine ilgi duyuyorsunuz ancak nereden başlayacağınız konusunda kafanız karışık mı? <a href="http://www.veridefteri.com/2017/10/30/veri-bilimciler-icin-python-ekosistemi/">Python</a> ekosistemi hakkında bilginiz var. <a href="http://www.veridefteri.com/2017/10/30/jupyter-notebook-nedir-2/">Jupyter Notebook</a> ile aranız fena değil. Sırada elinizi kirletmek var. Bunu yapmanın en kolay yollarından biri <code>scikit-learn</code> kütüphanesini kullanmak.</p>
<p><code>scikit-learn</code> yapay öğrenme alanında en yaygın olarak kullanılan kütüphanelerden biri. Doğrusal regresyon, lojistik regresyon, karar ağaçları, rastgele orman gibi birçok temel yöntemi içeren bu kütüphane, Anaconda ile beraber geliyor. Anaconda kullanmayanlar <a href="http://scikit-learn.org/">web</a> sitesinden kütüphaneyi nasıl yükleyeceklerini öğrenebilirler.</p>
<p><code>scikit-learn</code> paketinin bu kadar popüler olmasının birkaç sebebi var. Bunlardan ilki ihtiyaç duyacağınız temel yöntemlerin büyük bir kısmını içermesi. İkinci olarak, <code>scikit-learn</code> sayesinde veri analitiği uygulamalarını baştan sona yürütmenizin mümkün olmasını sayabiliriz. Verideki eksik değerleri doldurmak, öznitelik seçmek, çapraz doğrulama yapmak, sonuçları değerlendirmek için ayrı ayrı modüller sayesinde başka bir pakete ihtiyacınız kalmıyor. <code>scikit-learn</code> paketinin en güzel yanı basit bir API’a sahip olması sayesinde uygulayacağınız farklı yöntemler için farklı sözdizimleri öğrenmenizin önüne geçmesi. Bu sayede veri analitiğine yeni başlayanlar hızla ellerini kirletebiliyorlar. <code>fit/predict</code> ya da <code>fit/transform</code> fonksiyonları sayesinde kümeleme, regresyon, karar ağaçları gibi yöntemleri uygulamak, eksik değerleri doldurmak, veriyi ölçeklendirmek gibi farklı adımlarda benzer fonksiyonlar kullanmak işinizi oldukça kolaylaştırıyor. API basit olmasının yanında çok iyi bir dokümantasyona sahip.</p>
<p><code>lightgbm</code>, <code>tensorflow</code> gibi kütüphaneler performans açısından ileride olsa da <code>scikit-learn</code> başlangıç seviyesindekiler için benim tavsiye edeceğim ilk kütüphane. Veri Defteri’nde <code>scikit-learn</code> paketinin API’ını bir örnek üzerinden anlatıp, temel modüllerden bahsedeceğiz. Bu amaçla yine <code>scikit-learn</code> altındaki veri kümelerini kullanacağız.</p>
<p>Örneğimiz <code>digits</code> veri kümesi üzerinden bir sınıflandırma problemi olacak. <code>digits</code> veri kümesi elle yazılmış rakamların 8*8 büyüklüğündeki resimlerinin piksel (8*8 = 64) değerlerinden oluşuyor. Amacımız veri kümesindeki 3 ve 8 rakamlarını birbirinden ayırmak. Kaan <code>digits</code> veri kümesinden bir <a href="http://www.veridefteri.com/2017/11/03/yeni-baslayanlar-icin-veri-kumeleri-cicekler-bebekler-filmler/">yazısında</a> bahsetmişti. Kullanacağımız modülleri, veri kümesini yükleyelim ve öğrenme ve sınama için ikiye bölelim.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Rakamlar veri kümesini yüklüyoruz.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_digits</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#numpy paketini yüklüyoruz.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">#Veri kümesini ikiye bölmek için kullanıyoruz.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Resimleri incelemek için matplotlib kullanıyoruz.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Veri kümesini etiket değerleriyle birlikte yükleyelim.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>X,y <span class="op">=</span> load_digits(return_X_y<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Verinin boyutları (Gözlem, öznitelik) = '</span> <span class="op">+</span> <span class="bu">str</span>(np.shape(X)))</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Etiketlerin boyutları (Gözlem) = '</span> <span class="op">+</span> <span class="bu">str</span>(np.shape(y)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Verinin boyutları (Gözlem, öznitelik) = (1797, 64)
Etiketlerin boyutları (Gözlem) = (1797,)</code></pre>
</div>
</div>
<p>Veri kümesi 64 öznitelik (bunlar piksellerin değerlerine denk geliyor) ve 1797 gözlemden oluşuyor. Veri kümesinin ilk rakamını inceleyerek başlayalım. Rakamı çizdirmek için (1,64) olan boyutu (8,8) şeklinde değiştirmemiz gerekiyor. Bu amaçla da <code>numpy</code> altında <code>reshape</code> fonksiyonunu kullanacağız.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>rakam1 <span class="op">=</span> X[<span class="dv">0</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>rakam1 <span class="op">=</span> np.reshape(rakam1, (<span class="dv">8</span>,<span class="dv">8</span>))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span> (<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>plt.imshow(rakam1, cmap<span class="op">=</span><span class="st">"gray_r"</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>etiket1 <span class="op">=</span> y[<span class="dv">0</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Etiket: '</span> <span class="op">+</span> <span class="bu">str</span>(etiket1))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-3-output-1.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Etiket: 0</code></pre>
</div>
</div>
<p>Gördüğümüz gibi ilk rakam 0. Veri kümesindeki 3 ve 8 rakamlarını ayırmak istiyoruz. Bu amaçla filtreleme kullanacağız. Eğer bir rakam beşe bölündüğünde kalan üç ise istediğimiz koşulları sağlıyor.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#3 ve 8 rakamlarını seçmek için filtreleme kullanacağız.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">#Filtrelemeyi etiket değerlerine (y) bakarak yapacağız. </span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Etiket değeri beşe bölündüğünde kalan üç ise bu gözlemleri veri kümesinde bırakıyoruz.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>X<span class="op">=</span> X[y<span class="op">%</span><span class="dv">5</span> <span class="op">==</span> <span class="dv">3</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>y<span class="op">=</span> y[y<span class="op">%</span><span class="dv">5</span> <span class="op">==</span> <span class="dv">3</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Son olarak etiketleri 0 ve 1 değerlerine çevirelim.</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Rakam 3 ise etiket 0, 8 ise 1 olacak.</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> (y<span class="op">==</span><span class="dv">8</span>)<span class="op">*</span><span class="dv">1</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Verinin boyutları (Gözlem, öznitelik) = '</span> <span class="op">+</span> <span class="bu">str</span>(np.shape(X)))</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Etiketlerin boyutları (Gözlem) = '</span> <span class="op">+</span> <span class="bu">str</span>(np.shape(y)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Verinin boyutları (Gözlem, öznitelik) = (357, 64)
Etiketlerin boyutları (Gözlem) = (357,)</code></pre>
</div>
</div>
<p>Öğrenen modellerin başarısını sınamak için veri kümesini öğrenme (train) ve sınama (test) olarak ikiye bölelim. Bu da <code>scikit-learn</code> altında yapılabilecek bir işlem. Burada dikkat etmemiz gereken, veri kümesini bölerken etiketlerin yüzdelerini korumak. Bu sayede veri kümesinin sadece bir rakamdan oluşması gibi durumların önüne geçmeyi hedefliyoruz. <code>stratify</code> argümanı ile veri kümesini bölerken etiket değerlerini de hesaba katıyoruz.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Stratify değeri veri kümesinin etiket yüzdelerini korumak için kullanılıyor.</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">#Öğrenme veri kümesini küçük tutarak sonuçların çok iyi olmasını engelliyoruz.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#random_state değeri sonuçların her seferinde aynı çıkmasını sağlamak için kullanılıyor.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(X,y, train_size <span class="op">=</span> <span class="fl">0.5</span>, test_size <span class="op">=</span> <span class="fl">0.5</span>, random_state <span class="op">=</span> <span class="dv">0</span>, stratify <span class="op">=</span> y)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Öğrenme verisinin boyutları (Gözlem, öznitelik) = '</span> <span class="op">+</span> <span class="bu">str</span>(np.shape(X_train)))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Sınama verisinin boyutları (Gözlem, öznitelik) = '</span> <span class="op">+</span> <span class="bu">str</span>(np.shape(X_test)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Öğrenme verisinin boyutları (Gözlem, öznitelik) = (178, 64)
Sınama verisinin boyutları (Gözlem, öznitelik) = (179, 64)</code></pre>
</div>
</div>
<p>Veri kümesini ikiye böldük. Şimdi sınıflandırma için karar ağacı ve rastgele orman yöntemlerini kullanıp karşılaştıracağız. <code>scikit-learn</code> API’ının üç adımlık basit bir kullanımı var. Şimdi bu adımları inceleyelim.</p>
<section id="kullanacağımız-sınıfa-ait-bir-örnek-oluşturma" class="level2">
<h2 class="anchored" data-anchor-id="kullanacağımız-sınıfa-ait-bir-örnek-oluşturma">Kullanacağımız sınıfa ait bir örnek oluşturma</h2>
<p>Örnek olarak bir karar ağacı oluşturmak ya da eksik değerleri ortalama değerle doldurmak istiyorsunuz. Bu amaçla gerekli sınıflara (class) ait örnekleri istediğiniz parametrelerle oluşturmanız gerekiyor..</p>
<p><code>dt</code> adında bir karar ağacı oluşturmak için <code>DecisionTreeClassifier</code> sınıfını kullanıyoruz:</p>
<p><code>dt = DecisionTreeClassifier()</code></p>
<p>Eksik değerleri ortalama değerle değiştirmek için ise <code>Imputer</code> sınıfını kullanacağız. <code>NaN</code> şeklinde olan eksik değerleri ortalama (mean) değerle değiştirmek istersek bunu kullanacağımız argümanlarla belirtmemiz gerekiyor.</p>
<p><code>mean_imputer = Imputer(missing_values = 'NaN', strategy = 'mean')</code></p>
<p>Aşağıda <code>dt</code> adında bir karar ağacı ve <code>rf</code> adında bir rastgele orman örneği tanımlıyoruz.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Karar ağaçları</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.tree <span class="im">import</span> DecisionTreeClassifier</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Rastgele orman</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestClassifier</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">#Karar ağacı modelini oluşturalım. </span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">#random_state değeri sayesinde sonuçların rassal olarak değişmemesini sağlıyoruz.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> DecisionTreeClassifier(random_state <span class="op">=</span> <span class="dv">0</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">#Rastgele orman modelini oluşturalım.</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>rf <span class="op">=</span> RandomForestClassifier(random_state <span class="op">=</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="oluşturduğumuz-örneğin-öğrenmesini-sağlama-fit" class="level2">
<h2 class="anchored" data-anchor-id="oluşturduğumuz-örneğin-öğrenmesini-sağlama-fit">Oluşturduğumuz örneğin öğrenmesini sağlama (fit)</h2>
<p>Bir önceki aşamada oluşturduğumuz örneğin veri üzerinde öğrenmesi <code>fit</code> fonksiyonuyla yapılıyor. Örneğin bir karar ağacını öznitelik ve etiketleri kullanarak eğitmek için <code>fit</code> fonksiyonunu aşağıdaki gibi kullanabiliriz:</p>
<p><code>dt.fit(X_train, y_train)</code></p>
<p>Bu sayede öğrenme verisi üzerinden bir karar ağacı modeli oluşturulur.</p>
<p>Eksik değerleri doldurmak için de <code>fit</code> fonksiyonunu kullanacağız. Ancak burada <code>fit</code> fonksiyonu sadece yapacağımız işlemi tanımlıyor. Aşağıdaki satırda <code>X_train</code> matrisindeki eksik değer içeren sütunlar için ortalama değer hesaplanıyor.</p>
<p><code>mean_imputer.fit(X_train)</code></p>
<p>Şimdi yukarıda oluşturduğumuz karar ağacı ve rastgele orman modellerini eğitelim.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Modellerin öğrenmesini sağlayalım.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>dt.fit(X_train,y_train)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>rf.fit(X_train,y_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>RandomForestClassifier(bootstrap=True, class_weight=None, criterion='gini',
            max_depth=None, max_features='auto', max_leaf_nodes=None,
            min_impurity_decrease=0.0, min_impurity_split=None,
            min_samples_leaf=1, min_samples_split=2,
            min_weight_fraction_leaf=0.0, n_estimators=10, n_jobs=1,
            oob_score=False, random_state=0, verbose=0, warm_start=False)</code></pre>
</div>
</div>
</section>
<section id="sonuçları-elde-etmek-predictpredict_proba-ve-transform" class="level2">
<h2 class="anchored" data-anchor-id="sonuçları-elde-etmek-predictpredict_proba-ve-transform">Sonuçları elde etmek (predict/predict_proba ve transform)</h2>
<p>Oluşturduğunuz modelleri eğittikten sonra sonuçları elde etmek için kullanabileceğiniz iki farklı fonksiyon tipi var.</p>
<ul>
<li><code>predict</code>: Regresyon, sınıflandırma, kümeleme gibi yöntemler kullanarak yapacağınız çalışmalarda tahmin edilen etiket bilgisini <code>predict</code> fonksiyonuyla elde edebilirsiniz. Sınıflandırma problemlerinde gözlemlerin sınıflara ait olma olasılıklarını elde etmek istiyorsanız <code>predict_proba</code> fonksiyonunu kullanmanız gerekiyor.</li>
</ul>
<p>Yukarıda oluşturduğumuz karar ağacı için etiketleri elde etmek için aşağıdaki satıra ihtiyacımız var:</p>
<p><code>y_pred = dt.predict(X_test)</code></p>
<p>Eğer etiketleri değil de olasılıkları öğrenmek istiyorsak <code>predict_proba</code> fonksiyonunu kullanmamız gerekiyor. Sonuçlar her etikete ait olma yüzdesini içeriyor.</p>
<p><code>y_pred_proba = dt.predict_proba(X_test)</code></p>
<ul>
<li><code>transform</code>: Veriyle ilgili yapacağımız dönüştürme işlemlerinde ise <code>transform</code> fonksiyonunu kullanacağız. Dönüştürme işlemleri eksik veriyi doldurma, veriyi ölçeklendirme gibi alanlarda karşımıza çıkıyor. Aynı zamanda bir matrisi çarpanlarına ayırmak gibi işlemler için de <code>transform</code> fonksiyonu kullanılıyor.</li>
</ul>
<p>Eksik değerleri doldurmak için aşağıdaki satırı kullanabiliriz:</p>
<p><code>X_test = mean_imputer.transform(X_test)</code></p>
<p>Şimdi kullandığımız iki modeli sınama veri kümesinde kullanarak etiketleri ve gözlemlerin etiketlere ait olma olasılıklarını hesaplayalım.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Sınama verisinin etiketlerini elde edelim.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>y_pred_dt <span class="op">=</span> dt.predict(X_test)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Sınama veri kümesinin sınıflara ait olma olasılıklarını alalım.</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>y_pred_proba_dt <span class="op">=</span> dt.predict_proba(X_test)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">#Aynı adımları rastgele orman yöntemi için tekrarlayalım.</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>y_pred_rf <span class="op">=</span> rf.predict(X_test)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>y_pred_proba_rf <span class="op">=</span> rf.predict_proba(X_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Burada dikkat etmemiz gereken bir nokta <code>fit</code> işlemlerini öğrenme, <code>predict</code> ve <code>transform</code> işlemlerini ise sınama verisi üzerinden yapmak. Yapacağımız çalışmalardaki amacımız öğrenme veri kümesiyle yakaladığımız örüntüleri sınama verisi üzerinde denemek. Yani, sınama veri kümesinin sadece son aşamada kullanılması gerekiyor. Eksik değerleri doldurmak gibi konularda da öğrenme verisiyle elde ettiğimiz bilgileri (örnek olarak ortalamayı) sınama verisinde kullanıyoruz. Sınama veri kümesi için de <code>fit</code> fonksiyonunu kullanmak sıklıkla yapılan bir hata.</p>
<p>Aşağıdaki satırlarda öğrenme verisindeki sütunlar için ortalama değeri bulup eksik değerleri dolduruyoruz. Daha sonra da sınama verisindeki sütunlar için ortalama değerleri bulup eksik değerleri doldurmak için kullanıyoruz. Oysa ki yapmamız gereken sınama verisinde de öğrenme verisindeki ortalamaları kullanmak.</p>
<p><code>mean_imputer.fit(X_train) X_train = mean_imputer.transform(X_train) mean_imputer.fit(X_test) X_test = mean_imputer.transform(X_test)</code></p>
</section>
<section id="sonuçları-değerlendirmek-ve-yorumlamak" class="level1">
<h1>Sonuçları değerlendirmek ve yorumlamak</h1>
<p><code>scikit-learn</code> modellerin sonuçlarını değerlendirmek ve yorumlamak için de çeşitli araçlar sunuyor. Sonuçları değerlendirmek için isabetlilik (accuracy) ve eğri altı alan (area under curve) değerlerini kullanacağız. <code>metrics</code> modülünün altında farklı yöntemleri (sınıflandırma, regresyon, kümeleme) değerlendirmek için araçlar da var.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Sonuçları değerlendirmek için aşağıdaki fonksiyonları kullanacağız.</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> roc_auc_score, accuracy_score</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">#İsabetlilik değeri için etiketlere ihtiyacımız var.</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Karar ağacı isabetlilik değeri: '</span> <span class="op">+</span> <span class="bu">str</span>(accuracy_score(y_pred_dt, y_test)))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Rastgele orman isabetlilik değeri: '</span> <span class="op">+</span> <span class="bu">str</span>(accuracy_score(y_pred_rf, y_test)))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Eğri altı alan değeri için etiketlerin olasılıklarına ihtiyacımız var.</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Bu amaçla etiketlerin 1 değerinde olma yüzdelerini kullanacağız.</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Karar ağacı eğri altı alan değeri: '</span> <span class="op">+</span> <span class="bu">str</span>(roc_auc_score(y_test, y_pred_proba_dt[:,<span class="dv">1</span>])))</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Rastgele orman eğri altı alan değeri: '</span> <span class="op">+</span> <span class="bu">str</span>(roc_auc_score(y_test, y_pred_proba_rf[:,<span class="dv">1</span>])))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Karar ağacı isabetlilik değeri: 0.927374301676
Rastgele orman isabetlilik değeri: 0.960893854749
Karar ağacı eğri altı alan değeri: 0.928723138431
Rastgele orman eğri altı alan değeri: 0.997876061969</code></pre>
</div>
</div>
<p>İsabetlilik değeri ve eğri altı değeri de rastgele orman yönteminde daha yüksek çıktı.</p>
<p>3 ve 8 rakamlarını ayırmamızı sağlayan öznitelikler (piksel değerleri) hangileri? Şimdi de <code>features_importances_</code> özelliğini kullanarak modellerin önemli bulduğu piksellere bakalım.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>features_dt <span class="op">=</span> dt.feature_importances_</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>features_rf <span class="op">=</span> rf.feature_importances_</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>features_dt <span class="op">=</span> np.reshape(features_dt, (<span class="dv">8</span>,<span class="dv">8</span>))</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>features_rf <span class="op">=</span> np.reshape(features_rf, (<span class="dv">8</span>,<span class="dv">8</span>))</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>plt.imshow(features_dt)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Karar Ağacı'</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>plt.colorbar()</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>plt.imshow(features_rf)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Rastgele Orman'</span>)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>plt.colorbar()</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-10-output-1.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-10-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Önemli olan öznitelikler sarı ve açık mavi, önemsiz olanlarsa koyu mavi ile gösteriliyor. Karar ağaçları daha çok 3 piksele bakarken, rastgele orman yöntemi daha fazla piksele bakarak karar veriyor. İki yöntem de ağırlıklı olarak resmin sol tarafına bakıyor, yani resimlerin sol tarafı 3 ve 8 rakamlarını ayırmak önemli olan pikselleri içeriyor.</p>
</section>
<section id="diğer-modüller" class="level1">
<h1>Diğer Modüller</h1>
<p>Bu yazıda sınıflandırma algoritmalarına bakmış olsak da <code>scikit-learn</code> altında başka modüller de var. Bunlardan sıklıkla kullanılanları aşağıda bulabilirsiniz:</p>
<ul>
<li><code>cluster</code>: Başta k-ortalamalar algoritması olmak üzere kümeleme yöntemlerini içeriyor.</li>
<li><code>ensemble</code>: Adaboost, gradient boosting ve rastgele orman gibi grup halinde (ensemble) tahmin yapan yöntemleri bu modül altında yer alıyor.</li>
<li><code>feature_selection</code>: Öznitelik seçme/azaltma algoritmalarını içeriyor.</li>
<li><code>linear_model</code>: Başta doğrusal regresyon ve lojistik regresyon olmak üzere doğrusal yöntemleri içeriyor. Bu modül altında genelde regresyon yöntemleri bulunuyor.</li>
<li><code>metrics</code>: Regresyon, sınıflandırma ve kümeleme problemlerinde elde ettiğiniz sonuçları değerlendirmek için kullanabileceğiniz araçları kapsıyor.</li>
<li><code>model_selection</code>: Çapraz doğrulama (cross-validation) ve veri kümesini bölmek için kullanabileceğiniz bir modül.</li>
<li><code>neighbors</code>: Gözlemlerin birbirine yakınlığı üzerinden sınıflandırma ve regresyon uygulayan yöntemlerden (k en yakın komşu yöntemi gibi) oluşuyor.</li>
<li><code>neural_network</code>: Yapay sinir ağları üzerinden denemeler yapabileceğiniz bir modül. Ciddi bir çalışma gerçekleştirmek için başka paketlere ihtiyaç duyabilirsiniz.</li>
<li><code>preprocessing</code>: Veri üzerinde ölçeklendirme, eksik değerleri doldurma ve kategorik değişkenleri ikili değerlere çevirmek gibi işlemleri <code>preprocessing</code> ile yapabilirsiniz.</li>
<li><code>svm</code>: Destek vektör makineleri modülü. Sınıflandırma, regresyon ve aykırı gözlem bulmak için kullanılabilen algoritmalardan oluşuyor.</li>
<li><code>tree</code>: Karar ağaçları temelli yöntemleri içeriyor.</li>
</ul>
<p>Bu Veri Defteri’ni <a href="https://github.com/sibirbil/VeriDefteri">github</a> dizinimizde bulabilirsiniz.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>