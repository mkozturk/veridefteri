{
  "hash": "344fd34b851cd255e574dc665e27050a",
  "result": {
    "markdown": "---\ntitle: Groupby\nauthor: Birol Yüceoğlu\ndate: Oct. 30, 2017\ncategories:\n    - pandas\n    - veri önişleme\neval: false\n---\n\nPandas paketi veri analizi ve işlemesi için hazırlanmış bir Python paketidir. Bu paket çeşitli formatlardaki dosyaları (Excel, Csv, Txt gibi) okumayı, bu formatlarda dosyalar oluşturmayı kolaylaştırır. Aynı zamanda pandas paketi ile oluşturulan veri çerçeveleri (dataframe) sayesinde farklı formatlardaki (sayı, metin, tarih) veriyi birlikte tutmak, bu verileri işlemek ve basit analizler yapmak mümkündür.\n\nPandas paketinin altındaki bir yöntem olan `groupby()` ham haldeki veriden (örnek olarak alışveriş verisi) çeşitli istatistikler çıkarmak için oldukça yararlı bir araç. Bu Veri Defteri'nde UCI Machine Learning Repository'de bulunan online satış verisini kullanacağız. Veriye [linke](http://archive.ics.uci.edu/ml/datasets/online+retail) tıklayarak erişebilirsiniz. İlk olarak veriyi okutarak ve boyutlarına bakarak başlayalım.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# İlk adımda pandas ve numpy paketlerini yüklüyoruz\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n# Input dosyasının olduğu klasörün yolu\nIDIR = 'D:/Data/Blog/Data/'\n\n# Pandas'ın altındaki read_excel fonksiyonuyla Excel dosyasını okutabiliriz.\n# Pandas aynı zamanda csv, table, sql ve kopyaladığınız tablo halindeki verileri de okuyabilir (clipboard).\n# read_csv, read_table, read_json, read_sql, read_clipboard fonksiyonlarını inceleyebilirsiniz.\n# Şimdi veriyi okutarak verinin boyutlarını inceleyelim.\ndf = pd.read_excel(IDIR + 'Online Retail.xlsx')\n\nprint(\"Veri çerçevesinin boyutu: \" + str(np.shape(df)))\n```\n:::\n\n\nVeride 8 kolon var. Kolonlar hakkındaki ilk bilgiyi `head()` fonksiyonuyla görebiliriz.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nHTML(df.head().to_html())\n```\n:::\n\n\nVerideki kolonların ne anlama geldiğine bakalım.\n\n|Kolon | Anlam|\n|:------------- |:-------------|\n|InvoiceNo| Fatura numarası, her alışverişin bir numarası var|\n|StockCode| Ürünün numarası |\n|Description|Ürünün açıklaması|\n|Quantity|Üründen kaç adet alındığı|\n|InvoiceDate| Alışverişin tarihi ve saati|\n|UnitPrice| Ürünün birim fiyatı|\n|CustomerID| Müşteri numarası|\n|Country| Ülke|\n\n\nÖncelikle ülke bazında alışveriş istatistikleri çıkaralım. Bu amaçla ilk yapacağımız şey veri setini ülke bazında gruplamak.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Veriyi ülke (Country) bazında grupluyoruz\ndf_country = df.groupby('Country')\n```\n:::\n\n\nVeride hangi ülkeler olduğunu görmek için `group.keys()`, kaç ülke olduğunu görmek içinse `ngroups` metotlarını kullanabiliriz.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(\"Ülkeler\")\nprint(df_country.groups.keys())\nprint(\"Ülke sayısı: \" + str(df_country.ngroups))\n```\n:::\n\n\nVeri setinde 38 ülkeden yapılan alışverişler var. Her bir gruba (ülkede yapılan alışverişlere) erişmek için aşağıdaki gibi bir loop kullanabiliriz. `df_country` bir *GroupBy* objesi ve veriyi ülke ve satış verisini içeren bir dictionarye benzer bir şekilde tutuyor.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfor country, sales in df_country:\n    if country == 'Belgium':\n        HTML(sales.head().to_html())\n```\n:::\n\n\nİstediğimiz gruba ulaşmanın bir diğer yolu da `get_group()` fonksiyonu. 'Austria' için olan satış verilerine ulaşmayı deneyelim.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nHTML(df_country.get_group('Austria').head().to_html())\n```\n:::\n\n\nŞimdi her ülke için en çok satılan ürünü bulalım. Bunun için yapmamız gerekenler ülke (Country) ve ürün (StockCode) bazında satış miktarlarını (Quantity) toplamak olacak. Ondan sonra da her ülke için en çok satılan ürünü bulacağız. `groupby` fonksiyonuna vereceğimiz `by` argümanı hangi kolonlara göre (Country, StockCode) gruplayacağımız bilgisini veriyor. Daha sonra işlem yapacağımız kolonu (Quantity) ve yapacağımız işlemi (`sum()`) belirtiyoruz.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndf_country_product = df.groupby(by = ['Country', 'StockCode'])['Quantity'].sum()\nprint(df_country_product.head())\n```\n:::\n\n\nDataframe yapısını korumak için reset_index() fonksiyonunu kullanabiliriz.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndf_country_product = df_country_product.reset_index()\nHTML(df_country_product.head().to_html())\n```\n:::\n\n\nÜlke bazında en yüksek miktara sahip ürünleri bulmak için `groupby`ı maksimum değeri bulacak şekilde kullanabiliriz. Ancak bu ürün bilgisini vermeyeceği için `transform` yöntemini kullanıyoruz. Bu sayede her ülke için maksimum satış değerine sahip ürünün satış adedine erişiyoruz. Aşağıdaki satırda değeri maksimum satışa sahip ürünlere sahip indexleri belirliyoruz. Bu, aynı satış miktarına sahip birden fazla ürün varsa onları da bulmamızı sağlar.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nidx = df_country_product.groupby(['Country'])['Quantity'].transform(max) == df_country_product['Quantity']\n\nHTML(df_country_product[idx].head(10).to_html())\n```\n:::\n\n\nŞimdi de müşteriler için çeşitli istatistikler çıkaralım. Müşterilerle ilgili pazarlama, segmentasyon, müşteri terki tahmini gib çalışmalarda sıklıkla kullanılan **RFM** (Recency, frequency, monetary / yakınlık, sıklık, mali) değişkenlerini `groupby` fonksiyonunu kullanarak oluşturacağız. Bu tip istatistikler aynı zamanda gerçekleştireceğiniz çalışmalarda öznitelik türetmek için de kullanılabilir.\n\nHer müşteri için aşağıdaki değişkenlerin değerlerini elde etmek istiyoruz:\n* Alışveriş sayısı\n* Toplam ve ortalama alışveriş miktarı\n* Satın alınan toplam ve ortalama (farklı) ürün sayısı \n* En son alışveriş tarihi\n\nBunun için öncelike toplam alışveriş miktarını 'Amount' kolonuna yazdıracağız. Yapmamız gereken miktar (Quantity) ile birim fiyat (UnitPrice) kolonlarını çarpmak. \n\nBunları yapmadan önce müşteri (CustomerID) kolonunda boş değerler olduğu için öncelikle bu alışverişleri veri setinden çıkaralım.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# CustomerID değeri olmayan müşterileri veri setinden çıkaralım.\nprint(\"Temizlik öncesi alışveriş sayısı: \" + str(len(df)))\ndf = df[df['CustomerID'] > 0]\nprint(\"Temizlik sonrası alışveriş sayısı: \" + str(len(df)))\n\n# Birim fiyat ve miktar değerlerini çarparak toplam tutarı bulalım.\ndf['Amount'] = df['Quantity'] * df['UnitPrice']\nHTML(df.head().to_html())\n```\n:::\n\n\nAlışverişleri önce müşteri (CustomerID) ve alışveriş (InvoiceNo) değerleri için gruplayalım. Bu sayede her alışveriş için sepetteki ürün sayısı ve sepetteki ürünleri toplam tutarını öğrenebiliriz. Her alışveriş için yapacağımız işlemler aşağıdakilerdir:\n* Farklı ürün sayısını bulmak (StockCode): Kullanacağımız yöntem `nunique` kaç tane tekil (unique) değer olduğuna bakar.\n* Sepetteki ürünlerin değerini toplamak (Amount): Kullanacağımız yöntem `sum` verilen kolonun değerlerini toplar.\n* Alışveriş tarihini belirlemek (InvoiceDate): Kullanacağımız değer `max` maksimum değeri verir. Burada max değerini kullanmamız şart değil. Sadece bu değeri bir sonraki tabloya da aktarmak istiyoruz.\n\n`agg` fonksiyonu dictionary yapısıyla bu farklı işlemleri tek satırda yapmamıza imkan tanıyor. \n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndf_customer = df.groupby(['CustomerID', 'InvoiceNo']).agg({'StockCode':'nunique', \n                                                           'Amount':'sum', \n                                                           'InvoiceDate': 'max'}).reset_index()\n\nHTML(df_customer.head().to_html())\n```\n:::\n\n\nArtık istediğimiz değerleri hesaplayabiliriz. Her müşteri ve alışveriş için oluşturduğumuz tabloyu müşteri bazında tekrar gruplayacağız. Yapmak istediğimiz işlemler aşağıdakilerdir:\n* İşlem sayısını bulmak: 'InvoiceNo' kolonundaki değerleri sayacağız. Değerler tekil olduğu için `count` fonksiyonunu kullanabiliriz.\n* Toplam ve ortalam işlem miktarını bulmak: 'Amount' kolonu için toplam ve ortalama (`mean`) değerleri bulacağız.\n* En son alışveriş tarihini bulmak: Her müşteri için 'InvoiceDate' kolonundaki maksimum değeri bulacağız.\n\nMiktar kolonunda yapacağımız iki işlem (toplam ve ortalama) için de dictionary yapısını ya da bir liste kullanabiliriz.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndf_customer = df_customer.groupby('CustomerID').agg({'InvoiceNo':'count', \n                                                     'Amount': ['sum','mean'],\n                                                    'InvoiceDate': 'max'}).reset_index()\n\ndf_customer.columns = ['CustomerID', 'Number_of_Transactions', 'Total_Amount', 'Average_Amount', 'Last_Transaction_Date']\nHTML(df_customer.head().to_html())\n```\n:::\n\n\n`groupby()`fonksiyonunu kullanarak veriyi özetledik. Bu noktadan sonra uygulamanıza göre veriden özetlediğiniz bilgileri kullanabilirsiniz.\n\nJupyter Notebook dosyalarına ulaşmak için Github [dizinine](https://github.com/sibirbil/VeriDefteri) bakabilirsiniz.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}