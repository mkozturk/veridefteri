[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Veri Defteri",
    "section": "",
    "text": "Binder ile Jupyter defterleri paylaşmak\n\n\n\nGenel\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nFeb 3, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBilimsel Programlamaya Kolay Başlangıç - 4\n\n\n\nBilimsel Programlama\n\n\n\n\n\n\n\nEgemen İmre\n\n\nMar 4, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBilimsel Programlamaya Kolay Başlangıç - 3\n\n\n\nBilimsel Programlama\n\n\n\n\n\n\n\nEgemen İmre\n\n\nMar 1, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKeras ile Derin Öğrenmeye Giriş\n\n\n\nBaşlangıç\n\n\nderin öğrenme\n\n\nyapay öğrenme\n\n\n\n\n\n\n\nBirol Yüceoğlu\n\n\nFeb 6, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBilimsel Programlamaya Kolay Başlangıç - 2\n\n\n\nBilimsel Programlama\n\n\n\n\n\n\n\nEgemen İmre\n\n\nSep 3, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBilimsel Programlamaya Kolay Başlangıç - 1\n\n\n\nBilimsel Programlama\n\n\n\n\n\n\n\nEgemen İmre\n\n\nAug 29, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 23 - Modüller ve paketler\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJul 25, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 22 - Hata yakalama, try/except\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJun 25, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 21 - Dinamik kod üretme\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJun 8, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLightGBM’e Giriş\n\n\n\nBaşlangıç\n\n\nLightGBM\n\n\nveri setleri\n\n\nyapay öğrenme\n\n\n\n\n\n\n\nBirol Yüceoğlu\n\n\nMay 22, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 20 - Dosya okuma ve yazma\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nApr 11, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npandas’a Giriş - Veri Çerçeveleri\n\n\n\nBaşlangıç\n\n\npandas\n\n\nveri önişleme\n\n\n\n\n\n\n\nBirol Yüceoğlu\n\n\nMar 30, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 19 - Liste kurma, sözlük kurma, üreteç ifadeler\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nMar 24, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeather Underground API\n\n\n\nBaşlangıç\n\n\nGenel\n\n\nveri setleri\n\n\n\n\n\n\n\nBirol Yüceoğlu\n\n\nMar 22, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 18 - Python referans modeli, sığ ve derin kopyalama\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nMar 19, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 17 - Küme metodları\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nMar 9, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npandas’a Giriş - Seriler\n\n\n\nBaşlangıç\n\n\nGenel\n\n\npandas\n\n\nveri önişleme\n\n\n\n\n\n\n\nBirol Yüceoğlu\n\n\nMar 1, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 16 - Dize Biçimlendirme\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nFeb 23, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 15 - Dize Metodları\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nFeb 17, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 14 - Sözlük Metodları\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nFeb 3, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 13 - Liste Metodları\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJan 30, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 12 - Sıralı Nesnelerle İşlemler\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJan 26, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFoursquare API\n\n\n\nBaşlangıç\n\n\nGenel\n\n\nveri setleri\n\n\n\n\n\n\n\nBirol Yüceoğlu\n\n\nJan 23, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 11 - İsimsiz Fonksiyonlar\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJan 19, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 10 - Fonksiyon Alıştırmaları\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJan 14, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 9 - Fonksiyonlara örnekler\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJan 13, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 8 - Fonksiyon parametreleri\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJan 10, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 7 - Fonksiyonlar\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nJan 6, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 6 - Döngü Alıştırmaları\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nDec 30, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 5 - Döngülerle Problem Çözme\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nDec 26, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 4 - Döngüler\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nDec 20, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 3 - Seçim yapma, Mantık İşlemleri, Karşılaştırmalar\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nDec 16, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 2 - Sayılar, Aritmetik, Temel Veri Yapıları\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nDec 11, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Programlamaya Giriş 1 - İlk adımlar\n\n\n\nPython Programlamaya Giriş\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nDec 8, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJupyter / IPython sihirli ifadeler\n\n\n\nJupyter\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nNov 28, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nscikit-learn ile Veri Analitiğine Giriş\n\n\n\nBaşlangıç\n\n\nyapay öğrenme\n\n\n\n\n\n\n\nBirol Yüceoğlu\n\n\nNov 23, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTürkçe Metin İşlemede İlk Adımlar\n\n\n\nBaşlangıç\n\n\nGenel\n\n\nmetin işleme\n\n\n\n\n\n\n\nİlker Birbil\n\n\nNov 20, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMuhabbet Teorisi - Algoritmalara güvenebilir miyiz?\n\n\n\ncepyayını\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nNov 17, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[TODO] Jupyter Notebook - R ve Julia\n\n\n\nBaşlangıç\n\n\nGenel\n\n\n\n\n\n\n\nİlker Birbil\n\n\nNov 12, 2017\n\n\n\n\n\n\n\n\n\n\n\n\nAşırı Öğrenme ve Eksik Öğrenme\n\n\n\nyapay öğrenme\n\n\n\n\n\n\n\nBirol Yüceoğlu\n\n\nNov 7, 2017\n\n\n\n\n\n\n\n\n\n\n\n\nYeni başlayanlar için veri kümeleri : Çiçekler, bebekler, filmler\n\n\n\nBaşlangıç\n\n\nveri setleri\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nNov 3, 2017\n\n\n\n\n\n\n\n\n\n\n\n\nVeri Bilimciler İçin Python Ekosistemi\n\n\n\nBaşlangıç\n\n\n\n\n\n\n\nKaan Öztürk\n\n\nOct 30, 2017\n\n\n\n\n\n\n\n\n\n\n\n\nJupyter Notebook nedir?\n\n\n\nBaşlangıç\n\n\nGenel\n\n\n\n\n\n\n\nİlker Birbil\n\n\nOct 30, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGroupby\n\n\n\npandas\n\n\nveri önişleme\n\n\n\n\n\n\n\nBirol Yüceoğlu\n\n\nOct 30, 2017\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2019/03/01/bilimsel-programlamaya-kolay-baslangic-iii/index.html",
    "href": "posts/2019/03/01/bilimsel-programlamaya-kolay-baslangic-iii/index.html",
    "title": "Bilimsel Programlamaya Kolay Başlangıç - 3",
    "section": "",
    "text": "Bilimsel Programlama’ya Kolay Başlangıç serisinin ilk yazısında Hazırlık, Hesaplama ve Sonuçları Görselleştirme adımlarından bahsetmiş ve bunları serbest düşüş problemine uygulamıştık. İkinci yazıda ise Hesaplama adımından sonra Veri/Hata Analizi adımını eklemiş ve eğik atış problemini Euler sayısal metodu ile de hesaplayarak hatamızı incelemiştik. Lakin tüm bunları Python’un kendi matematik kütüphanesi olan math ile gerçekleştirdik.\nSerinin üçüncü yazısında ise math’a oranla (genellikle) daha hızlı ve çok daha yetenekli olan numpy ve sonrasında da bunun üstüne bir kat daha çıkarak scipy kütüphanelerine terfi edeceğiz ve kolay yoldan bir ikinci derece diferansiyel denklem çözeceğiz. Bunun için Eğik Atış problemi yerine, nonlineer bir problem olan “iki cisim problemini”, yani Dünya’nın çevresindeki uyduların dinamiğini kullanacağız.\nİki cisim problemi en genel haliyle kütle çekiminden kaynaklanan ivmeden ibaret:\n\\[\\ddot{\\vec{r}} = - \\frac{\\mu}{r^3} \\vec{r} \\]\nBurada \\(\\vec{r}\\) konum vektörünü, \\(r\\) konum vektörünün büyüklüğünü ve $ $ konum vektörünün zamana göre ikinci türevini, ya da daha bilindik adıyla ivmeyi gösteriyor. \\(\\mu\\) ise pek tanıdık değil, ama aslında Dünya’nın kütleçekim sabitini gösteriyor. Örneğin Ay’ın ya da bir uydunun, Dünya’nın çevresinde dönerken gelecekteki konum ve hızını bulabilmek için, başlangıçtaki konum ve hızı bu ivmenin integralini alarak ilerleteceğiz. İntegral lafını duyunca tüyleriniz diken diken olduysa korkmayın; integrali biz almayacağız, bilgisayar alacak.\nMatematiğe gelmeden önce, işin kalbindeki veri yapısı olan ZamanKonumHız sınıfının numpy kullanan yeni sürümüne bakalım:\n\n# sonradan gerekecek kütüphaneleri çağır\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\n\n# Kütleçekimi Sabiti [m^3/s^2]\nmuDünya = 398600.5*1E9    \n\nclass ZamanKonumHız:\n   \"\"\"\n    Zaman, 2D konum ve 2D hız değerlerini içeren vektör sınıfı\n   \"\"\"\n   t = 0\n   r = np.zeros(2)\n   v = np.zeros(2)\n\n   def __init__(self, t0, rx0, ry0, vx0, vy0):\n       \"\"\"\n       Zaman, konum ve hızı ilk değerleriyle başlatır.\n       \n       Arguments:\n           t0  {float} -- zaman (s)\n           rx0 {float} -- x ekseninde konum (m)\n           ry0 {float} -- y ekseninde konum (m)\n           vx0 {float} -- x ekseninde hız (m/s)\n           vy0 {float} -- y ekseninde hız (m/s)\n      \"\"\"\n       self.t = t0      \n       self.r = np.array([rx0, ry0])\n       self.v = np.array([vx0, vy0])\n\n      \n   def konumBüyüklüğü(self):\n       \"\"\"Konum vektörünün büyüklüğünü döndürür\n               \n        Returns:\n           float -- Konum vektörünün büyüklüğü ($m$)\n       \"\"\"\n       return np.linalg.norm(self.r)\n\n   def hızBüyüklüğü(self):\n       \"\"\"Hız vektörünün büyüklüğünü döndürür\n        \n        Returns:\n           float -- Hız vektörünün büyüklüğü ($m^2/s^2$)\n        \"\"\"\n       return np.linalg.norm(self.v)\n\n   def spesifikEnerji(self):\n       \"\"\"\n       Spesifik enerjiyi hesaplar.\n\n       Spesifik enerji birim kütleye düşen enerji olarak tanımlanır\n\n       $e =  \\frac{1}{2} v^2 - \\frac{\\mu}{r} $\n       \n       Returns:\n           float -- spesifik enerji ($m^2/s^2$)\n       \"\"\"\n       return 0.5*self.v.dot(self.v) - muDünya/self.konumBüyüklüğü()\n\n   def ivme (self, mu=muDünya):\n       \"\"\"\n       İvmeyi hesaplar\n       \n       İki cisim problemine göre bu konum ve hıza ait ivmeyi hesaplar.\n       \n       Keyword Arguments:\n           mu {float} -- Kütleçekimi Sabiti (m^3/s^2) (default: {muDünya})\n       \n       Returns:\n           {ndarray} -- İvme vektörü ($m/s^2$)\n       \"\"\"\n       return -mu/np.power(self.konumBüyüklüğü(), 3) * self.r\n\nÖncelikle, eğik atış problemindeki sınıfa göre ne kadar az şeyin değiştiğine dikkatinizi çekmek isterim. İyi bir sınıf tasarımı sayesinde, çok daha başka bir problemde bile eski veri yapılarımızı kullanmayı başardık.\nnumpy’a geçişte konum ve hız vektörleri olan r ve v’yi minik ikili array’ler haline getirdik. Bu durum okunaklılığı kaçınılmaz olarak azaltıyor (ry mi daha açık, r[1] mi?), ama bize numpy’ın kuvvetli vektör işlemlerinin kapılarını açtığı için sonuçta çok faydalı.\nBununla birlikte, __init__ vektörü hala t0, rx0, ry0, vx0, vy0 değişkenlerini tek tek girmemizi istiyor. Bunları neden vektör olarak vermiyoruz diye merak edebilirsiniz. Bunu yapabiliriz, ama o zaman girdideki her bir vektörün iki elemanlı olduğunu kontrol etmemiz, sonra da ikiden fazla ya da eksik eleman çıkarsa ne yapacağımıza karar vermemiz gerekli. Bu nedenle, daha kodu yazarken, bu tür girdilerde ve arayüzlerde yapılabilecek hataları öngörüp buna göre önlem almak orta vadede sizi (ve kodlarınızı kullanacak başka kişileri) hatadan korur. Bu örnekte, bu sınıfı kullanacak kişileri doğru sayıda veri vermeye zorlayarak sınıfın hatalı şekilde başlatılmasının önüne geçtik.\nBunun yanı sıra vektör büyüklüklerini hesaplama işini de numpy’ın linalg.norm metoduna emanet ettik. Böylece, örneğin bu sınıfı başka bir zaman 3 boyut için kullanmak istediğimizde bu kısımları değiştirmemiz gerekmeyecek, şimdiden hazırız.\nBu arada yorumları daha detaylı yazmaya başladık ve parametrelerin birimlerini de özellikle belirttik. Birimler ve arayüzler mühim, 1999 yılında Mars Climate Orbiter tam da bu yüzden kaybedildi!\nEklediğimiz ivme metodu da dikkatli gözlerden kaçmamıştır. Böylece ivme hesaplamasını ZamanKonumHız sınıfının bir yeteneği olarak tanımladık.\nSon olarak spesifikEnerji adlı bir metod da ekledik. Spesifik enerji birim kütleye düşen enerji olarak tanımlanabilir:\n\\(e = \\frac{E}{m} = \\frac{1}{2} v^2 - \\frac{\\mu}{r}\\)\nSpesifik enerjinin bizim için önemi şurada: İki cisim probleminde enerjinin korunup korunmadığına bakarak hatamızı kontrol edebiliriz. Zira fizik bize enerjinin korunması gerektiğini söylüyor, enerji korunumundan ne kadar uzaklaşırsak yaptığımız hata da o kadar artmış demektir. Bunu da birazdan kullanacağız.\nBu sınıfı uzun uzadıya anlattığım için şimdiden sıkılmaya başlayan arkadaşlara not: Genellikle bilimsel programlamada bu tarz temel veri yapılarını içeren sınıflar çok kullanılır. Bunları ne kadar özenle hazırlar ve yetenekler kazandırırsanız ileride hayatınız o kadar kolaylaşır.\nHazırlık kısmının diğer bileşenleri ise geçen yazıdan tanıdık gelecektir:\n\n# Kütleçekimi Sabiti [m^3/s^2]\nmuDünya = 398600.5*1E9\n\n# başlangıç zamanı\nt0 = 0\n# bitiş zamanı (sn)\ntSon = 6000 \n# adım büyüklüğü (sn)\ntAdım = 5\n\n# başlangıç konum ve hız\npvt0 = ZamanKonumHız(t0, 0, 7000*1E3, 7.5*1E3, 0)\n\nİşin matematik kısmını bu örnekte fonkisyonlara toplayacağız. Bu tür fonksiyonlar ve bu fonksiyonları çağıran daha da başka fonksiyonlar Matruşka Bebekleri gibi iç içe geçerek kodun çok daha derli toplu ve daha önemlisi yeniden kullanılabilir olmasını sağlıyorlar. Aynı kodları defalarca yazmak hem zahmetli hem de hata bulma ve yeni işlev eklemeyi son derece zorlaştırıyor.\nBir sonraki adımda, bir önceki yazıda değndiğimiz temel fonksiyonları da numpy ile tekrar yazacağız. Yorumlar daha detaylı hale geldi, artık veri tipi bile yazıyor ama temel yapı aynı.\n\ndef eulerZamanKonumHız(dt, pvt, mu=muDünya):\n    \"\"\"\n    Verilen bir dt adım büyüklüğü kadar zaman konum ve hızı Euler Metodu ile ilerletir.\n    \n    Arguments:\n        dt {float} -- adım büyüklüğü (s)\n        pvt {ZamanKonumHız} -- t zamanında zaman konum hız\n        mu {float} -- Kütleçekimi Sabiti (m^3/s^2) (default: {muDünya})\n\n    Returns:\n        {ZamanKonumHız} -- t+dt zamanında zaman konum hız\n    \"\"\"\n    a = pvt.ivme(mu)\n\n    tYeni  = pvt.t + dt\n    rYeni  = pvt.r + pvt.v * dt\n    vYeni  = pvt.v + a * dt\n\n    return ZamanKonumHız(tYeni, rYeni[0], rYeni[1], vYeni[0], vYeni[1])\n\n\ndef hesapDöngüsüEuler(pvt0, tAdım, tSon):\n    \"\"\"\n    Euler sayısal integrasyon metoduyla konum ve hız değerleri listesini hesaplar.\n\n    Arguments:\n        tAdım {float} -- adım büyüklüğü (s)\n        pvt0 {ZamanKonumHız} -- başlangıç zamanında zaman konum hız\n        tSon {float} -- bitiş zamanı (s)\n\n    Returns:\n        list {ZamanKonumHız} --  her bir zaman adımı için zaman konum hız değerlerini içeren liste\n    \"\"\"\n    # ilk değerleri doldur\n    numPvtList = [pvt0]\n\n    t = numPvtList[0].t + tAdım\n    while t&lt;=tSon:\n        pvtNum = eulerZamanKonumHız(tAdım, numPvtList[-1])\n        numPvtList.append( pvtNum )\n\n        t += tAdım\n    \n    return (numPvtList)\n\neulerZamanKonumHız adlı yapı içinde iki cisim problemine ait ivmeyi hesaplıyoruz. Sonra da konumu bilinen en son hızı sabit kabul ederek, hızı da hesaplanan ivmeyi sabit kabul ederek ilerletiyoruz. Burada yaptığımız şey aslında kısa bir zaman adımı için integral almak, ama bunu sayısal olarak yaptığımız için son derece kolay şekilde hallediyoruz. Tabii ödediğimiz bedel “tam olarak doğru ve hatasız” değil, ancak yaklaşık bir hesaplama yapmak. hesapDöngüsüEuler adımı içinde ise bu küçük zaman adımlarını bir döngü içinde defalarca hesaplayarak tSon değerine kadar tüm konum ve hız çiftlerini elde ediyoruz.\nBütün matematiği yukarıda anlatılan fonkisyonlara paketlediğimiz için asıl işi yapacak kod sadece ve sadece 1 (bir) satıra indi:\n\n# Euler sayısal integrasyon verisini hesaplayan döngüyü çalıştır\neulPvtList = hesapDöngüsüEuler(pvt0, tAdım, tSon)\n\nBu çok klasik bir “işi fonksiyonda yap, return ile sonucu döndür ve bu sonucu bir değişkene ata” diyebileceğim (muhtemelen birilerinin çoktan bir pattern adı ile tanımladığı) bir yapı. Başkalarının kodlarını incelerken sıkça karşınıza çıkacak, sonra siz de bol bol kullanacaksınız.\nKonum ve hız grafiklerine bakalım:\n\n# konum grafiği \nplt.plot( [pvt.r[0] for pvt in eulPvtList], [pvt.r[1] for pvt in eulPvtList], label=\"Euler (\" + str(tAdım) + \" s)\")\n\nplt.title(\"Konum\")\nplt.xlabel(\"x konum (m)\")\nplt.ylabel('y konum (m)')\n\nplt.axes().set_aspect('equal')\nplt.grid(b=True, which='major', linestyle='--')\n\nplt.show()\n\n# hız grafiği\nplt.plot( [pvt.v[0] for pvt in eulPvtList], [pvt.v[1] for pvt in eulPvtList], label=\"Euler (\" + str(tAdım) + \" s)\")\n\nplt.title(\"Hız\")\nplt.xlabel(\"x hız (m/s)\")\nplt.ylabel(\"y hız (m/s)\")\n\nplt.axes().set_aspect('equal')\nplt.grid(b=True, which='major', linestyle='--')\n\nplt.show()\n\n\n\n\n\n\n\nGrafikleri oluşturduğumuz kod bir önceki yazıdakinden pek farklı değil, ama eklediğimiz iki satırla eksenlerin ölçeklerini birbirine eşitlediğimize dikkat edin. Böylece daha gerçekçi bir fiziksel gösterim elde ettik.\nGrafiklere yakından bakınca bir tuhaflık göze çarpıyor: ilk grafikte “saat 12” konumundan başlayıp saat yönünde dönüyoruz, ama başladığımız yere geri dönemiyoruz. Aynı durum hız için de geçerli. Normalde iki cisim problemi periyodik bir problem, enerji korunuyor ve bu nedenle de -gördüğümüz grafiklerin aksine- başladığımız konum ve hıza geri dönmeyi bekliyoruz. Diğer bir deyişle, potansiyel ve kinetik enerjinin toplamının değişmemesi gerekiyor. Bizim çözümümüzde enerjinin korunup korunmadığını test etmek için, başlangıç konum ve hızından hesapladığımız “referans” enerji değerinden, her yeni zaman için ne kadar sapıldığını kontrol etmemiz yeterli:\n\n# enerji grafikleri\n\n#referans değer - tüm farklar bu değere göre hesaplanacak\nspEnerjiRef = pvt0.spesifikEnerji()\n\nplt.title(\"Euler Spesifik Enerji Değişimi (\" + str(tAdım) + \" s)\")\nplt.xlabel(\"zaman (s)\")\nplt.ylabel(r\"spesifik enerji ($m^2/s^2$)\")\n\nplt.plot( [pvt.t for pvt in eulPvtList], [pvt.spesifikEnerji()-spEnerjiRef for pvt in eulPvtList], label=\"Euler (\" + str(tAdım) + \" s)\")\n\nplt.show()\n\n\n\n\nGörünüşe göre spesifik enerji lineer olarak artıyor ve bu artış duracakmış gibi de görünmüyor. Anlaşılan o ki, Euler ilerleticisi enerjiyi korumuyor. Adım büyüklüğünü azaltırsak hatanın da azalacağından daha önce bahsetmiştik. O halde 1, 5 ve 10 saniye için duruma bir göz atalım:\n\n# adım büyüklüğü (sn)\ntAdım5  = 5\ntAdım10 = 10\ntAdım1  = 1\n\n# Euler sayısal integrasyon verisini hesaplayan döngüyü çalıştır\neulPvtList5  = hesapDöngüsüEuler(pvt0, tAdım5, tSon)\neulPvtList10 = hesapDöngüsüEuler(pvt0, tAdım10, tSon)\neulPvtList1  = hesapDöngüsüEuler(pvt0, tAdım1, tSon)\n\n# enerji grafikleri\n\nplt.title(\"Euler Spesifik Enerji Değişimi\")\n\nplt.plot( [pvt.t for pvt in eulPvtList1], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in eulPvtList1], label=\"Euler (\" + str(tAdım1) + \" s)\")\nplt.plot( [pvt.t for pvt in eulPvtList5], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in eulPvtList5], label=\"Euler (\" + str(tAdım5) + \" s)\")\nplt.plot( [pvt.t for pvt in eulPvtList10], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in eulPvtList10], label=\"Euler (\" + str(tAdım10) + \" s)\")\n\nplt.legend(loc=2)\n\nplt.show()\n\n\n\n\nGerçekten de, adım büyüklüğü azaldıkça enerjideki artış yavaşlıyor. Yani adım büyüklüğünü ne kadar azaltırsak enerjinin korunumuna o oranda yaklaşıyoruz, haliyle konum ve hız hatamız da azalıyor. Teorik olarak, adım büyüklüğü sıfıra giderken enerji hatamızı da sıfırlayabiliriz! Gerçekte, başımıza dert olan kayan nokta hataları nedeniyle hatayı belli bir değerin altına indirmek mümkün değil.\nBu da sayısal modellerin, neden gerçek matematiksel modellerin yerini almakta zorlanacağını bize anlatıyor - tam matematiksel modeli elde edilemeyen, diferansiyel denklemi çözülemeyen ağır problemleri tenzih ediyorum elbette. Zira Euler ya da Runge-Kutta gibi matematiksel modeller fiziksel gerçekliği değil, sadece problemin fiziğini ifade eden diferansiyel denklemlerin çözümünü modellemeye yarıyor. Enerjinin ya da momentumun korunumunu da modellemek için, bunun için özelleşmiş matematiksel modeller gerekiyor.\nİşin yazılım tarafına baktığınızda ise, bu tür testlerle modellerinizin doğruluğunu ve nasıl davrandığını, istediğiniz doğruluğa ulaşmak için adım büyüklüğünü nasıl seçmeniz gerektiğini kestirebilirsiniz. Ya da enerjinin korunumu en ufak sorunda bozulan hassas bir denge olduğu için, sayısal integrasyon algoritmanıza bir modül testi olarak yazabilirsiniz. İşler yeterince büyüdüğünde, yazılımınızın bir köşesinde bir şeyleri değiştirirken başka bir köşesinde bir şeyleri kırıp dökmek çok kolay olduğu için, bu tür testleri yazıp düzenli olarak çalıştırdığınızda yaptığınız hangi değişikliğin ortalığı karıştırdığını bulmak çok kolay olacaktır.\nBuraya kadar numpy kullanımına basit bir giriş yaptık. Daha ileri matematiksel yöntemler de var. Bunları numpy ile hazırlamak mümkün olsa da, scipy kütüphanesi daha geniş imkanlar sağlıyor. Bunları bir sonraki kısımda göreceğiz."
  },
  {
    "objectID": "posts/2019/02/06/keras-ile-derin-ogrenmeye-giris/index.html",
    "href": "posts/2019/02/06/keras-ile-derin-ogrenmeye-giris/index.html",
    "title": "Keras ile Derin Öğrenmeye Giriş",
    "section": "",
    "text": "Derin öğrenme son zamanlarda yapay öğrenme alanındaki en popüler konulardan biri. AlphaGo adlı bir bilgisayar programının kısa vadede çözülemeyeceği iddia edilen Go oyununda dünya şampiyonu olan Lee Sedol’u yenmesi ve bunun popüler bir şekilde belgeselleştirilmesi de derin öğrenmenin ününü pekiştirdi. Ancak, derin öğrenme konusundaki ilk önemli gelişme ImageNet yarışmasında derin öğrenme yöntemlerinin sağladığı iyileşmelerdi. Fotoğraflardaki objelerin sınıflandırılması üzerine olan bu yarışmada 2011 yılında %75 civarında olan başarı düzeyi, 2012 yılında ilk derin öğrenme modeliyle birlikte %10 civarında iyileşti. 2015 yılında ise artık derin öğrenme modelleri insanlardan daha iyi bir performans gösterir oldular.\nDerin öğrenme konusunda Keras oldukça önemli paketlerden biri. Aslında Keras kendi başına bir derin öğrenme kütüphanesi değil. Keras, size Google Tensorflow, Microsoft CNTK, ve Theano derin öğrenme kütüphanelerini kullanabileceğiniz üst seviye bir API (application programming interface, uygulama programlama arayüzü) sunuyor. Bu sayede oluşturduğunuz derin öğrenme mimarisini farklı paketleri kullanarak eğitmeniz mümkün.\nDerin öğrenme konusunda bir ders hazırlamak istiyorum. O yüzden derin öğrenme mimarilerine şimdilik girmeyeceğim. Yapay sinir ağlarının teorisiyle ilgili bilgi edinmek isteyenlere İlker’in dersini izlemelerini öneririm. Bu yazı Keras için bir tanıtım içerecek ve derin öğrenme modellerinin eğitilmesi için temel kavramlara değinecek.\nBen Keras’ı Tensorflow ile kullanmayı tercih ettim. Tensorflow’u da kullanmış biri olarak söyleyebilirim ki, Keras derin öğrenme modelleriyle oynamayı çok kolaylaştırıyor. Hem Tensorflow, hem de Keras için aşağıdaki komutları kullanarak conda ile yükleme yapmanızı tavsiye ederim. Tensorflow’un kendi web sayfasındaki öneriler benim işime yaramadı.\nconda install -c conda-forge tensorflow\nconda install -c conda-forge keras\n\n\nDoğrusal olmayan ilişkilerin modellenmesini görmek için veri kümesini doğrusal olarak ayrılamayan bir şekilde kendimiz oluşturacağız. İç içe geçmiş iki yarım daire oluşturan make_moons fonksiyonunu kullanalım. Benzer bir örneği internette görmüştüm, ancak gördüğüm kaynağı unuttum. Veri kümesini eğitim ve test için ikiye ayırmadan karar sınırlarına bakarak değerlendirme yapacağız.\n\nimport numpy as np \nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import make_moons\nfrom sklearn.model_selection import train_test_split\n#Uyarı mesajlarını kapatmak için\nimport warnings\nwarnings.filterwarnings('ignore')\n\nX, y = make_moons(n_samples= 1500, noise=0.3, random_state=0)\nX,X_test, y, y_test = train_test_split(X,y, test_size = 0.333, random_state = 0)\n\nplt.figure(figsize=(5,5))\nplt.scatter(X[:,0], X[:,1], c= y)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nAmacımız yukarıda sarı ve mor ile gösterilen sınıfları ayırmak olacak.\nKeras’ta model oluşturmak için iki farklı yöntemi kullanabiliriz. Bunlardan ilki sıralı katmanlar (layer) halinde bir yapı oluşturmamızı sağlayan Sequential model yöntemi. Sequential fonksiyonu ile oluşturduğunuz yapay sinir ağı sadece birbirine sırayla bağlı olan katmanlardan oluşabilir. Diğer bir deyişle oluşturduğunuz ağ çevrimsiz yönlü bir çizgeye (directed acyclic graph) denk geliyor. Daha karmaşık yapılar için ise Functional API kullanmanız gerekiyor. Bu yapılarda bir katmana birden fazla katmandan girdi sağlanabilir. Aynı şekilde bir katmanın çıktısını birden fazla katman kullanabilir. Bu yazıda ilk olarak Sequential modellere değineceğiz. Daha sonra Functional API ile model kurmayı da göreceğiz.\nİlk olarak gerekli yöntemleri yükleyelim. Yapay sinir ağı yoğun (dense) katmanlardan oluşacak. Yani bir katmandaki düğümler bir sonraki katmandaki bütün düğümlere bağlı olacak. Yoğun katmanlar, gözlemler ve özniteliklerden oluşan iki boyutlu yapılarda sıklıkla kullanılan bir mimari. Resim işleme, zaman serisi analizleri gibi alanlarda farklı mimariler de mevcut.\n\nfrom keras.models import Sequential\nfrom keras.layers import Dense\n\nUsing TensorFlow backend.\n\n\nİlk olarak basit bir model oluşturalım. * Modelin girdi katmanı veri kümesindeki iki boyutlu girdiyi kabul edecek. * Modeldeki ilk katmanda (gizli katman) iki düğüm olacak. * Modelin ikinci katmanı ise çıktıların belirleneceği katman olacak.\nDerin öğrenme yöntemlerinin doğrusal olmayan ilişkileri modellemesi için her düğümde gerçekleşen işlemler doğrusal olmayan bir aktivasyon fonksiyonundan geçirilir. Relu (Rectified Linear Unit) aktivasyon fonksiyonu sıfırın altındaki değerlere sıfır, sıfırın üzerindeki değerlere ise kendi değerini atayan bir fonksiyondur. Aşağıdaki şekilde Relu fonksiyonunu görebilirsiniz.\n\ndegerler = np.arange(-3, 3, .2)\nsifir = np.zeros(len(degerler))\naktivasyon = np.max([sifir, degerler], axis=0)\n\nfig = plt.figure(figsize = (6,6))\nplt.plot(degerler, aktivasyon)\nplt.ylim([-3.0, 3.0])\nplt.xlim([-3.0, 3.0])\nplt.ylabel('Aktivasyon Değeri')\nplt.xlabel('Değerler')\nplt.title('Relu Aktivasyon Fonksiyonu')\n\nplt.show()\n\n\n\n\nSigmoid aktivasyon fonksiyonu ise \\(sgm(x) = \\frac{1}{1+ e^{-x}}\\) şeklinde tanımlanır ve yapay sinir ağında elde ettiğiniz değerleri 0 ile 1 arasında bir olasılığa çevirmek için kullanılır. Aşağıda sigmoid fonksiyonunu görebilirsiniz. İlker’in dersinde başka aktivasyon fonksiyonu örnekleri de görebilirsiniz.\n\ndegerler = np.arange(-5, 5, .2)\nsigmoid = 1 / (1+ np.exp(-degerler))\n\nfig = plt.figure(figsize = (6,6))\nplt.plot(degerler, sigmoid)\nplt.ylim([-1.0, 2.0])\nplt.xlim([-5.0, 5.0])\nplt.ylabel('Aktivasyon Değeri')\nplt.xlabel('Değerler')\nplt.title('Sigmoid Aktivasyon Fonksiyonu')\n\nplt.show()\n\n\n\n\nŞimdi yukarıda bahsettiğimiz iki düğümlü bir katman ve çıktı katmanını içeren sinir ağını oluşturalım. Burada dikkat etmemiz gereken nokta ilk katmanda girdinin boyutunu belirtmek gerekliliği. Veri setimiz iki öznitelik içerdiği için bu değer iki olacak. Keras daha sonraki katmanlarda girdi ve çıktıları birbiriyle uyumlu olarak belirliyor. Kurduğumuz mimariyi aşağıdaki şekilde görebilirsiniz.\n\nfrom IPython.display import Image\nImage(\"Network1.png\")\n\n\n\n\n\n# Model oluşturuyoruz.\nmodel = Sequential()\n# Modele bir katman (gizli katman) ekliyoruz. Katmanda iki düğüm var ve relu aktivasyon fonksiyonunu kullanıyor. \nmodel.add(Dense(2, input_dim=2, activation='relu'))\n# Aşağıda eklediğimiz katman çıktı katmanı. Bir sınıflandırma problemi üzerine çalıştığımız için\n# sigmoid aktivasyon fonksiyonunu kullanıyoruz.\nmodel.add(Dense(1, activation='sigmoid'))\n\nOluşturduğumuz modeli derlememiz gerekiyor. Bu noktada eniyilenecek amaç fonksiyonu, eniyileme yöntemi ve takip edilecek başarı ölçütlerini belirtiyoruz. İkili sınıflandırma problemlerinde binary_crossentropy sıklıkla kullanılan bir amaç fonksiyonu. Eniyileme yöntemi olarak Adam ve takip edilecek ölçüt olarak isabetlilik değerini kullanalım. Birden fazla ölçütü takip etmeniz mümkün olsa da amaç fonksiyonunuz tek bir fonksiyon olmalı.\nEniyileme yöntemi olarak seçtiğim Adam oldukça popüler bir yöntem. Yöntem hakkında bilgi edinmek isteyenler için linkteki yazıyı ve yöntemin tanıtıldığı makaleyi önerebilirim.\n\n# Modeli derlerken amaç fonksiyonu (loss), eniyileme yöntemini (adam) ve takip edeceğimiz\n# başarı ölçütlerini (accuracy) sağlıyoruz.\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n\nSırada modeli eğitmek var. Burada da karşımıza iki kavram çıkıyor: epochs ve batch_size. Küme büyüklüğü (batch_size) bir seferde yapay sinir ağını eğitmek için kullanılacak örnek sayısını belirtir. Bütün veri kümesinin yapay sinir ağından bir kere geçmesi ise bir devir (epoch) olarak adlandırılır. Elimizdeki 1000 örneklemlik bir veri kümesi için küme büyüklüğü 10 ise bir devirde yapay sinir ağı 100 kere güncellenir. Şimdi küme büyüklüğü 10 ve devir sayısı 15 olacak şekilde modeli eğitelim.\n\n# Batch_size her adımda kaç örneklemin model parametrelerini değiştirmek için kullanılacağını belirtir.\n# Epoch ise bütün örneklerin modelden kaç kere geçeceğini söyler.\n# Bu durumda her bir epoch 1000/10 = 100 adımdan oluşur. Bu adımların her birinde 10 tane örneklem kullanılarak \n# yapay sinir ağının parametreleri güncellenir.\nmodel.fit(X, y, epochs=15, batch_size=10)\n\nEpoch 1/15\n1000/1000 [==============================] - 0s 276us/step - loss: 0.6519 - acc: 0.5150\nEpoch 2/15\n1000/1000 [==============================] - 0s 80us/step - loss: 0.6205 - acc: 0.6060\nEpoch 3/15\n1000/1000 [==============================] - 0s 96us/step - loss: 0.5984 - acc: 0.6780\nEpoch 4/15\n1000/1000 [==============================] - 0s 110us/step - loss: 0.5802 - acc: 0.7200\nEpoch 5/15\n1000/1000 [==============================] - 0s 87us/step - loss: 0.5652 - acc: 0.7470\nEpoch 6/15\n1000/1000 [==============================] - 0s 100us/step - loss: 0.5524 - acc: 0.7540\nEpoch 7/15\n1000/1000 [==============================] - 0s 100us/step - loss: 0.5405 - acc: 0.7600\nEpoch 8/15\n1000/1000 [==============================] - 0s 84us/step - loss: 0.5298 - acc: 0.7630\nEpoch 9/15\n1000/1000 [==============================] - 0s 123us/step - loss: 0.5200 - acc: 0.7700\nEpoch 10/15\n1000/1000 [==============================] - 0s 120us/step - loss: 0.5104 - acc: 0.7760\nEpoch 11/15\n1000/1000 [==============================] - 0s 115us/step - loss: 0.5002 - acc: 0.7800\nEpoch 12/15\n1000/1000 [==============================] - 0s 137us/step - loss: 0.4887 - acc: 0.7890\nEpoch 13/15\n1000/1000 [==============================] - 0s 116us/step - loss: 0.4759 - acc: 0.7950\nEpoch 14/15\n1000/1000 [==============================] - 0s 95us/step - loss: 0.4618 - acc: 0.8090\nEpoch 15/15\n1000/1000 [==============================] - 0s 126us/step - loss: 0.4472 - acc: 0.8220\n\n\n&lt;keras.callbacks.History at 0x1736e063fd0&gt;\n\n\nŞimdi karar sınırlarına bakalım. Bu amaçla belirttiğimiz aralıkta noktalar oluşturup, oluşturduğumuz noktaların sınıflandırmasını gerçekleştireceğiz. predict_classes fonksiyonu her gözlemin hangi sınıfa ait olduğunu bulmamızı sağlar. predict fonksiyonu ise gözlemlerin sınıflara ait olma olasılığını gösterir.\n\nxx, yy = np.meshgrid(np.arange(-2, 3, 0.1),\n                     np.arange(-1.5, 2, 0.1))\n\nyhat = model.predict_classes(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)\n\nplt.figure(figsize=(5,5))\nplt.scatter(xx,yy, c= yhat)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nGördüğünüz gibi model doğrusal olmayan ilişkiyi bulmak için biraz basit kaldı. Şimdi önümüzde iki seçenek var: devir sayısını arttırmak, mimariyi değiştirmek. Modelin çıktısına bakarsak performansın çok düşük olmadığını görüyoruz. Ancak örüntü basite indirgenmiş. O zaman, katmandaki düğüm sayısını arttırarak tekrar deneyelim. Katmandaki düğüm sayısı, modelinizin esnekliğini artırmanızı sağladığı için daha iyi bir çözüm olabilir. Gizli katmandaki düğüm sayısını yirmiye çıkaralım. Aşağıdaki şekilde ikinci yapay sinir ağının mimarisini bulabilirsiniz.\n\nImage(\"Network2.png\")\n\n\n\n\n\n# Modeli 20 düğümlü bir katmanla oluşturalım. Geri kalan adımlar değişmeyecek.\nmodel = Sequential()\nmodel.add(Dense(20, input_dim=2, activation='relu'))\nmodel.add(Dense(1, activation='sigmoid'))\n\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n\n#Modelin çıktılarını kapatmak için verbose = 0 değerini kullanmak gerekiyor.\nmodel.fit(X, y, epochs=15, batch_size=10, verbose = 0)\n\nxx, yy = np.meshgrid(np.arange(-2, 3, 0.1),\n                     np.arange(-1.5, 2, 0.1))\n\nyhat = model.predict_classes(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)\n\nplt.figure(figsize=(5,5))\nplt.scatter(xx,yy, c= yhat)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nModel doğrusal olmayan ilişkiyi öğrenmeye başlamış. Ancak çok isabetli bir örüntü çıkarmamış. Devir sayısını arttırarak tekrar deneyelim.\n\n# Bir önceki modeli kullanıyoruz\nmodel = Sequential()\nmodel.add(Dense(20, input_dim=2, activation='relu'))\nmodel.add(Dense(1, activation='sigmoid'))\n\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n\n# Devir sayısını 50 yapalım.\nmodel.fit(X, y, epochs=50, batch_size=10, verbose = 0)\n\nxx, yy = np.meshgrid(np.arange(-2, 3, 0.1),\n                     np.arange(-1.5, 2, 0.1))\n\nyhat = model.predict_classes(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)\n\nplt.figure(figsize=(5,5))\nplt.scatter(xx,yy, c= yhat)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nKarar sınırlarında bir iyileşme görüyoruz.\n\n\n\nKeras ile model oluşturmanın bir diğer yolu da Functional API. Bu sayede oluşturduğunuz katmanları birbirine ardışık olarak bağlamak zorunluluğu da ortadan kalkmış oluyor. Bir katmanın çıktısını birden fazla katman kullanabilir ya da bir katmana birden fazla katman girdi sağlayabilir. Şimdi yukarıda oluşturduğumuz modele iki katman daha ekleyerek bir örnek yapalım. Functional APIı kullanmak için her katmanı bir değişken gibi tanımlamamız gerekiyor. Her katman girdi olarak bir başka katmanı alıyor. Bu mantıkta girdileri de bir Input katmanıyla tanımlamamız şart.\nFarklı bir katman tipi öğrenmek açısından Dropout katmanını da kullanalım. Dropout katmanı her adımda belirtilen orandaki girdiyi rassal olarak sıfıra eşitleyerek modelin veriye aşırı uyum sağlamasının (aşırı öğrenmenin) önüne geçer. Buna karşılık Dropout katmanı modelin eğitilmesinin uzamasına neden olabilir, yani devir sayısını arttırmanız gerekebilir.\nAşağıdaki şekilde üçüncü yapay sinir ağının mimarisini bulabilirsiniz. Dropout katmanı 1 numaralı gizli katmandaki kimi çıktıları baskıladığı için ayrıca şekle eklemedim.\n\nImage(\"Network3.png\")\n\n\n\n\n\nfrom keras.layers import Input, Dense, Dropout\nfrom keras.models import Model\n\n# Girdi katmanını tanımlıyoruz. Girdideki öznitelik sayısını da belirtiyoruz.\n# Bizim örneğimizde iki öznitelik var.\ninputs = Input(shape=(2,))\n\n# İki tane katman tanımlayacağız. Bunlardan ilki inputs katmanını girdi olarak alıyor ve 20 düğümden oluşuyor.\nlayer1 = Dense(20, activation='relu')(inputs)\n# Dropout katmanı layer1 katmanını girdi olarak kabul ediyor.\nlayer_dropout = Dropout(rate = 0.1)(layer1)\n# İkinci katman ise layer_dropout adlı katmanı girdi olarak alacak ve yine 20 düğümden oluşacak.\nlayer2 = Dense(20, activation='relu')(layer_dropout)\n# Tahmin yaptığımız katman layer2 adlı katmanı girdi olarak alıyor.\n# Aktivasyon fonksiyonu ise daha önce de gördüğümüz gibi sigmoid olacak. Bu katman tek bir düğümden oluşuyor.\npredictions = Dense(1, activation='sigmoid')(layer2)\n\n# Model oluştururken girdi ve çıktı katmanlarını sağlamamız yeterli.\nmodel = Model(inputs=inputs, outputs=predictions)\n# Modeli derlemek ve eğitmek için aynı parametreleri kullanıyoruz.\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\nmodel.fit(X, y, batch_size=10, epochs=50, verbose = 0)  # starts training\n\n&lt;keras.callbacks.History at 0x1736e3c6518&gt;\n\n\nBir önceki örnekte olduğu gibi karar sınırlarını çizdirebiliriz. Ancak Functional API predict_classes fonksiyonunu desteklemiyor. predict fonksiyonuyla bulduğumuz olasılıkları sınıflara çevirerek bu sorunu aşabiliriz.\n\nxx, yy = np.meshgrid(np.arange(-2, 3, 0.1),\n                     np.arange(-1.5, 2, 0.1))\n\nyhat = ( model.predict(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)  &gt; 0.5) *1\n\nplt.figure(figsize=(5,5))\nplt.scatter(xx,yy, c= yhat)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nGördüğünüz gibi Keras sayesinde yapay sinir ağları oluşturmak oldukça kolay. Ancak şunu da unutmamak gerekir ki, derin öğrenmenin sanata döndüğü yer mimarinin oluşturulması. Biz henüz bu konuya değinmedik. Buna da planladığım derste değinmeyi amaçlıyorum.\nBu yazıda kullandığım yapay sinir ağı mimarisi şekillerini linkteki kodu kullanarak çizdim.\nBu yazıya Github dizinimizden ulaşabilirsiniz."
  },
  {
    "objectID": "posts/2019/02/06/keras-ile-derin-ogrenmeye-giris/index.html#veri-kümesi",
    "href": "posts/2019/02/06/keras-ile-derin-ogrenmeye-giris/index.html#veri-kümesi",
    "title": "Keras ile Derin Öğrenmeye Giriş",
    "section": "",
    "text": "Doğrusal olmayan ilişkilerin modellenmesini görmek için veri kümesini doğrusal olarak ayrılamayan bir şekilde kendimiz oluşturacağız. İç içe geçmiş iki yarım daire oluşturan make_moons fonksiyonunu kullanalım. Benzer bir örneği internette görmüştüm, ancak gördüğüm kaynağı unuttum. Veri kümesini eğitim ve test için ikiye ayırmadan karar sınırlarına bakarak değerlendirme yapacağız.\n\nimport numpy as np \nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import make_moons\nfrom sklearn.model_selection import train_test_split\n#Uyarı mesajlarını kapatmak için\nimport warnings\nwarnings.filterwarnings('ignore')\n\nX, y = make_moons(n_samples= 1500, noise=0.3, random_state=0)\nX,X_test, y, y_test = train_test_split(X,y, test_size = 0.333, random_state = 0)\n\nplt.figure(figsize=(5,5))\nplt.scatter(X[:,0], X[:,1], c= y)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nAmacımız yukarıda sarı ve mor ile gösterilen sınıfları ayırmak olacak.\nKeras’ta model oluşturmak için iki farklı yöntemi kullanabiliriz. Bunlardan ilki sıralı katmanlar (layer) halinde bir yapı oluşturmamızı sağlayan Sequential model yöntemi. Sequential fonksiyonu ile oluşturduğunuz yapay sinir ağı sadece birbirine sırayla bağlı olan katmanlardan oluşabilir. Diğer bir deyişle oluşturduğunuz ağ çevrimsiz yönlü bir çizgeye (directed acyclic graph) denk geliyor. Daha karmaşık yapılar için ise Functional API kullanmanız gerekiyor. Bu yapılarda bir katmana birden fazla katmandan girdi sağlanabilir. Aynı şekilde bir katmanın çıktısını birden fazla katman kullanabilir. Bu yazıda ilk olarak Sequential modellere değineceğiz. Daha sonra Functional API ile model kurmayı da göreceğiz.\nİlk olarak gerekli yöntemleri yükleyelim. Yapay sinir ağı yoğun (dense) katmanlardan oluşacak. Yani bir katmandaki düğümler bir sonraki katmandaki bütün düğümlere bağlı olacak. Yoğun katmanlar, gözlemler ve özniteliklerden oluşan iki boyutlu yapılarda sıklıkla kullanılan bir mimari. Resim işleme, zaman serisi analizleri gibi alanlarda farklı mimariler de mevcut.\n\nfrom keras.models import Sequential\nfrom keras.layers import Dense\n\nUsing TensorFlow backend.\n\n\nİlk olarak basit bir model oluşturalım. * Modelin girdi katmanı veri kümesindeki iki boyutlu girdiyi kabul edecek. * Modeldeki ilk katmanda (gizli katman) iki düğüm olacak. * Modelin ikinci katmanı ise çıktıların belirleneceği katman olacak.\nDerin öğrenme yöntemlerinin doğrusal olmayan ilişkileri modellemesi için her düğümde gerçekleşen işlemler doğrusal olmayan bir aktivasyon fonksiyonundan geçirilir. Relu (Rectified Linear Unit) aktivasyon fonksiyonu sıfırın altındaki değerlere sıfır, sıfırın üzerindeki değerlere ise kendi değerini atayan bir fonksiyondur. Aşağıdaki şekilde Relu fonksiyonunu görebilirsiniz.\n\ndegerler = np.arange(-3, 3, .2)\nsifir = np.zeros(len(degerler))\naktivasyon = np.max([sifir, degerler], axis=0)\n\nfig = plt.figure(figsize = (6,6))\nplt.plot(degerler, aktivasyon)\nplt.ylim([-3.0, 3.0])\nplt.xlim([-3.0, 3.0])\nplt.ylabel('Aktivasyon Değeri')\nplt.xlabel('Değerler')\nplt.title('Relu Aktivasyon Fonksiyonu')\n\nplt.show()\n\n\n\n\nSigmoid aktivasyon fonksiyonu ise \\(sgm(x) = \\frac{1}{1+ e^{-x}}\\) şeklinde tanımlanır ve yapay sinir ağında elde ettiğiniz değerleri 0 ile 1 arasında bir olasılığa çevirmek için kullanılır. Aşağıda sigmoid fonksiyonunu görebilirsiniz. İlker’in dersinde başka aktivasyon fonksiyonu örnekleri de görebilirsiniz.\n\ndegerler = np.arange(-5, 5, .2)\nsigmoid = 1 / (1+ np.exp(-degerler))\n\nfig = plt.figure(figsize = (6,6))\nplt.plot(degerler, sigmoid)\nplt.ylim([-1.0, 2.0])\nplt.xlim([-5.0, 5.0])\nplt.ylabel('Aktivasyon Değeri')\nplt.xlabel('Değerler')\nplt.title('Sigmoid Aktivasyon Fonksiyonu')\n\nplt.show()\n\n\n\n\nŞimdi yukarıda bahsettiğimiz iki düğümlü bir katman ve çıktı katmanını içeren sinir ağını oluşturalım. Burada dikkat etmemiz gereken nokta ilk katmanda girdinin boyutunu belirtmek gerekliliği. Veri setimiz iki öznitelik içerdiği için bu değer iki olacak. Keras daha sonraki katmanlarda girdi ve çıktıları birbiriyle uyumlu olarak belirliyor. Kurduğumuz mimariyi aşağıdaki şekilde görebilirsiniz.\n\nfrom IPython.display import Image\nImage(\"Network1.png\")\n\n\n\n\n\n# Model oluşturuyoruz.\nmodel = Sequential()\n# Modele bir katman (gizli katman) ekliyoruz. Katmanda iki düğüm var ve relu aktivasyon fonksiyonunu kullanıyor. \nmodel.add(Dense(2, input_dim=2, activation='relu'))\n# Aşağıda eklediğimiz katman çıktı katmanı. Bir sınıflandırma problemi üzerine çalıştığımız için\n# sigmoid aktivasyon fonksiyonunu kullanıyoruz.\nmodel.add(Dense(1, activation='sigmoid'))\n\nOluşturduğumuz modeli derlememiz gerekiyor. Bu noktada eniyilenecek amaç fonksiyonu, eniyileme yöntemi ve takip edilecek başarı ölçütlerini belirtiyoruz. İkili sınıflandırma problemlerinde binary_crossentropy sıklıkla kullanılan bir amaç fonksiyonu. Eniyileme yöntemi olarak Adam ve takip edilecek ölçüt olarak isabetlilik değerini kullanalım. Birden fazla ölçütü takip etmeniz mümkün olsa da amaç fonksiyonunuz tek bir fonksiyon olmalı.\nEniyileme yöntemi olarak seçtiğim Adam oldukça popüler bir yöntem. Yöntem hakkında bilgi edinmek isteyenler için linkteki yazıyı ve yöntemin tanıtıldığı makaleyi önerebilirim.\n\n# Modeli derlerken amaç fonksiyonu (loss), eniyileme yöntemini (adam) ve takip edeceğimiz\n# başarı ölçütlerini (accuracy) sağlıyoruz.\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n\nSırada modeli eğitmek var. Burada da karşımıza iki kavram çıkıyor: epochs ve batch_size. Küme büyüklüğü (batch_size) bir seferde yapay sinir ağını eğitmek için kullanılacak örnek sayısını belirtir. Bütün veri kümesinin yapay sinir ağından bir kere geçmesi ise bir devir (epoch) olarak adlandırılır. Elimizdeki 1000 örneklemlik bir veri kümesi için küme büyüklüğü 10 ise bir devirde yapay sinir ağı 100 kere güncellenir. Şimdi küme büyüklüğü 10 ve devir sayısı 15 olacak şekilde modeli eğitelim.\n\n# Batch_size her adımda kaç örneklemin model parametrelerini değiştirmek için kullanılacağını belirtir.\n# Epoch ise bütün örneklerin modelden kaç kere geçeceğini söyler.\n# Bu durumda her bir epoch 1000/10 = 100 adımdan oluşur. Bu adımların her birinde 10 tane örneklem kullanılarak \n# yapay sinir ağının parametreleri güncellenir.\nmodel.fit(X, y, epochs=15, batch_size=10)\n\nEpoch 1/15\n1000/1000 [==============================] - 0s 276us/step - loss: 0.6519 - acc: 0.5150\nEpoch 2/15\n1000/1000 [==============================] - 0s 80us/step - loss: 0.6205 - acc: 0.6060\nEpoch 3/15\n1000/1000 [==============================] - 0s 96us/step - loss: 0.5984 - acc: 0.6780\nEpoch 4/15\n1000/1000 [==============================] - 0s 110us/step - loss: 0.5802 - acc: 0.7200\nEpoch 5/15\n1000/1000 [==============================] - 0s 87us/step - loss: 0.5652 - acc: 0.7470\nEpoch 6/15\n1000/1000 [==============================] - 0s 100us/step - loss: 0.5524 - acc: 0.7540\nEpoch 7/15\n1000/1000 [==============================] - 0s 100us/step - loss: 0.5405 - acc: 0.7600\nEpoch 8/15\n1000/1000 [==============================] - 0s 84us/step - loss: 0.5298 - acc: 0.7630\nEpoch 9/15\n1000/1000 [==============================] - 0s 123us/step - loss: 0.5200 - acc: 0.7700\nEpoch 10/15\n1000/1000 [==============================] - 0s 120us/step - loss: 0.5104 - acc: 0.7760\nEpoch 11/15\n1000/1000 [==============================] - 0s 115us/step - loss: 0.5002 - acc: 0.7800\nEpoch 12/15\n1000/1000 [==============================] - 0s 137us/step - loss: 0.4887 - acc: 0.7890\nEpoch 13/15\n1000/1000 [==============================] - 0s 116us/step - loss: 0.4759 - acc: 0.7950\nEpoch 14/15\n1000/1000 [==============================] - 0s 95us/step - loss: 0.4618 - acc: 0.8090\nEpoch 15/15\n1000/1000 [==============================] - 0s 126us/step - loss: 0.4472 - acc: 0.8220\n\n\n&lt;keras.callbacks.History at 0x1736e063fd0&gt;\n\n\nŞimdi karar sınırlarına bakalım. Bu amaçla belirttiğimiz aralıkta noktalar oluşturup, oluşturduğumuz noktaların sınıflandırmasını gerçekleştireceğiz. predict_classes fonksiyonu her gözlemin hangi sınıfa ait olduğunu bulmamızı sağlar. predict fonksiyonu ise gözlemlerin sınıflara ait olma olasılığını gösterir.\n\nxx, yy = np.meshgrid(np.arange(-2, 3, 0.1),\n                     np.arange(-1.5, 2, 0.1))\n\nyhat = model.predict_classes(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)\n\nplt.figure(figsize=(5,5))\nplt.scatter(xx,yy, c= yhat)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nGördüğünüz gibi model doğrusal olmayan ilişkiyi bulmak için biraz basit kaldı. Şimdi önümüzde iki seçenek var: devir sayısını arttırmak, mimariyi değiştirmek. Modelin çıktısına bakarsak performansın çok düşük olmadığını görüyoruz. Ancak örüntü basite indirgenmiş. O zaman, katmandaki düğüm sayısını arttırarak tekrar deneyelim. Katmandaki düğüm sayısı, modelinizin esnekliğini artırmanızı sağladığı için daha iyi bir çözüm olabilir. Gizli katmandaki düğüm sayısını yirmiye çıkaralım. Aşağıdaki şekilde ikinci yapay sinir ağının mimarisini bulabilirsiniz.\n\nImage(\"Network2.png\")\n\n\n\n\n\n# Modeli 20 düğümlü bir katmanla oluşturalım. Geri kalan adımlar değişmeyecek.\nmodel = Sequential()\nmodel.add(Dense(20, input_dim=2, activation='relu'))\nmodel.add(Dense(1, activation='sigmoid'))\n\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n\n#Modelin çıktılarını kapatmak için verbose = 0 değerini kullanmak gerekiyor.\nmodel.fit(X, y, epochs=15, batch_size=10, verbose = 0)\n\nxx, yy = np.meshgrid(np.arange(-2, 3, 0.1),\n                     np.arange(-1.5, 2, 0.1))\n\nyhat = model.predict_classes(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)\n\nplt.figure(figsize=(5,5))\nplt.scatter(xx,yy, c= yhat)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nModel doğrusal olmayan ilişkiyi öğrenmeye başlamış. Ancak çok isabetli bir örüntü çıkarmamış. Devir sayısını arttırarak tekrar deneyelim.\n\n# Bir önceki modeli kullanıyoruz\nmodel = Sequential()\nmodel.add(Dense(20, input_dim=2, activation='relu'))\nmodel.add(Dense(1, activation='sigmoid'))\n\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n\n# Devir sayısını 50 yapalım.\nmodel.fit(X, y, epochs=50, batch_size=10, verbose = 0)\n\nxx, yy = np.meshgrid(np.arange(-2, 3, 0.1),\n                     np.arange(-1.5, 2, 0.1))\n\nyhat = model.predict_classes(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)\n\nplt.figure(figsize=(5,5))\nplt.scatter(xx,yy, c= yhat)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nKarar sınırlarında bir iyileşme görüyoruz."
  },
  {
    "objectID": "posts/2019/02/06/keras-ile-derin-ogrenmeye-giris/index.html#functional-api",
    "href": "posts/2019/02/06/keras-ile-derin-ogrenmeye-giris/index.html#functional-api",
    "title": "Keras ile Derin Öğrenmeye Giriş",
    "section": "",
    "text": "Keras ile model oluşturmanın bir diğer yolu da Functional API. Bu sayede oluşturduğunuz katmanları birbirine ardışık olarak bağlamak zorunluluğu da ortadan kalkmış oluyor. Bir katmanın çıktısını birden fazla katman kullanabilir ya da bir katmana birden fazla katman girdi sağlayabilir. Şimdi yukarıda oluşturduğumuz modele iki katman daha ekleyerek bir örnek yapalım. Functional APIı kullanmak için her katmanı bir değişken gibi tanımlamamız gerekiyor. Her katman girdi olarak bir başka katmanı alıyor. Bu mantıkta girdileri de bir Input katmanıyla tanımlamamız şart.\nFarklı bir katman tipi öğrenmek açısından Dropout katmanını da kullanalım. Dropout katmanı her adımda belirtilen orandaki girdiyi rassal olarak sıfıra eşitleyerek modelin veriye aşırı uyum sağlamasının (aşırı öğrenmenin) önüne geçer. Buna karşılık Dropout katmanı modelin eğitilmesinin uzamasına neden olabilir, yani devir sayısını arttırmanız gerekebilir.\nAşağıdaki şekilde üçüncü yapay sinir ağının mimarisini bulabilirsiniz. Dropout katmanı 1 numaralı gizli katmandaki kimi çıktıları baskıladığı için ayrıca şekle eklemedim.\n\nImage(\"Network3.png\")\n\n\n\n\n\nfrom keras.layers import Input, Dense, Dropout\nfrom keras.models import Model\n\n# Girdi katmanını tanımlıyoruz. Girdideki öznitelik sayısını da belirtiyoruz.\n# Bizim örneğimizde iki öznitelik var.\ninputs = Input(shape=(2,))\n\n# İki tane katman tanımlayacağız. Bunlardan ilki inputs katmanını girdi olarak alıyor ve 20 düğümden oluşuyor.\nlayer1 = Dense(20, activation='relu')(inputs)\n# Dropout katmanı layer1 katmanını girdi olarak kabul ediyor.\nlayer_dropout = Dropout(rate = 0.1)(layer1)\n# İkinci katman ise layer_dropout adlı katmanı girdi olarak alacak ve yine 20 düğümden oluşacak.\nlayer2 = Dense(20, activation='relu')(layer_dropout)\n# Tahmin yaptığımız katman layer2 adlı katmanı girdi olarak alıyor.\n# Aktivasyon fonksiyonu ise daha önce de gördüğümüz gibi sigmoid olacak. Bu katman tek bir düğümden oluşuyor.\npredictions = Dense(1, activation='sigmoid')(layer2)\n\n# Model oluştururken girdi ve çıktı katmanlarını sağlamamız yeterli.\nmodel = Model(inputs=inputs, outputs=predictions)\n# Modeli derlemek ve eğitmek için aynı parametreleri kullanıyoruz.\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\nmodel.fit(X, y, batch_size=10, epochs=50, verbose = 0)  # starts training\n\n&lt;keras.callbacks.History at 0x1736e3c6518&gt;\n\n\nBir önceki örnekte olduğu gibi karar sınırlarını çizdirebiliriz. Ancak Functional API predict_classes fonksiyonunu desteklemiyor. predict fonksiyonuyla bulduğumuz olasılıkları sınıflara çevirerek bu sorunu aşabiliriz.\n\nxx, yy = np.meshgrid(np.arange(-2, 3, 0.1),\n                     np.arange(-1.5, 2, 0.1))\n\nyhat = ( model.predict(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)  &gt; 0.5) *1\n\nplt.figure(figsize=(5,5))\nplt.scatter(xx,yy, c= yhat)\nplt.xlim(-2,3)\nplt.ylim(-1.5,2)\nplt.show()\n\n\n\n\nGördüğünüz gibi Keras sayesinde yapay sinir ağları oluşturmak oldukça kolay. Ancak şunu da unutmamak gerekir ki, derin öğrenmenin sanata döndüğü yer mimarinin oluşturulması. Biz henüz bu konuya değinmedik. Buna da planladığım derste değinmeyi amaçlıyorum.\nBu yazıda kullandığım yapay sinir ağı mimarisi şekillerini linkteki kodu kullanarak çizdim.\nBu yazıya Github dizinimizden ulaşabilirsiniz."
  },
  {
    "objectID": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html",
    "href": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html",
    "title": "Python Programlamaya Giriş 20 - Dosya okuma ve yazma",
    "section": "",
    "text": "Yazı dizimizin bu bölümünde, dosya okuma ve yazma yöntemlerinden bahsedeceğiz. Önce herhangi bir özel şekilde yapılanmamış olan düz metin dosyalarını işlemeyi göreceğiz. Ardından csv modülüyle CSV biçiminde yapılanmış dosyaları okuyup yazmayı inceleyeceğiz. JSON, ZIP, PDF, Word, Excel, HTML dosyalarının işlenmesine kısaca değineceğiz. Son olarak, Python oturumunda yarattığımız nesneleri ikili (binary) formda dosyaya kaydetmemizi ve sonra dosyadan tekrar yüklememizi sağlayan pickle modülünün kullanımını özetleyeceğiz."
  },
  {
    "objectID": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html#genel-dosya-okumayazma",
    "href": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html#genel-dosya-okumayazma",
    "title": "Python Programlamaya Giriş 20 - Dosya okuma ve yazma",
    "section": "Genel dosya okuma/yazma",
    "text": "Genel dosya okuma/yazma\n\nDosya okumak\nÖncelikle, IPython sihirleriyle deneme.txt isimli bir dosya yaratalım (Jupyter kullanmıyorsanız aşağıdaki metni bir metin editörüne kopyalayıp deneme.txt ismiyle çalışma dizininize kaydedebilirsiniz).\n\n%%writefile deneme.txt\nEy Türk Gençliği!\nBirinci vazifen, \nTürk istiklâlini, Türk Cumhuriyeti'ni, \nilelebet muhafaza ve müdafaa etmektir.\n\nWriting deneme.txt\n\n\nBir dosyayı açmak için open() fonksiyonunu kullanırız. En basit halinde open() mevcut bir metin dosyasını okumak için açar ve bir dosya nesnesi döndürür.\n\nf = open(\"deneme.txt\")\n\nDosya nesnesinin read() metodu dosya içeriğini tek bir dize halinde döndürür.\n\nf.read()\n\n\"Ey Türk Gençliği!\\nBirinci vazifen, \\nTürk istiklâlini, Türk Cumhuriyeti'ni, \\nilelebet muhafaza ve müdafaa etmektir.\\n\"\n\n\nAçılmış dosyalarla işimiz bittiğinde kapatmamız gerekir, yoksa bellekte birikip yer işgal edebilirler.\n\nf.close()\n\nreadlines() metodu, satırlardan oluşan bir liste döndürür:\n\nf = open(\"deneme.txt\")\nf.readlines()\n\n['Ey Türk Gençliği!\\n',\n 'Birinci vazifen, \\n',\n \"Türk istiklâlini, Türk Cumhuriyeti'ni, \\n\",\n 'ilelebet muhafaza ve müdafaa etmektir.\\n']\n\n\n\nf.close()\n\nBir dosya nesnesi bir iteratördür; bütün dosyayı bir kerede belleğe yüklemez, ama talep geldikçe satırları birer birer verir. readline() metodu dosyadaki mevcut satırı okumak için kullanılır. Her yeni readline() çağrısı bir sonraki satırı getirir.\n\nf = open(\"deneme.txt\")\nf.readline()\n\n'Ey Türk Gençliği!\\n'\n\n\n\nf.readline()\n\n'Birinci vazifen, \\n'\n\n\nDosya nesnesi bir iteratör olduğu için for döngüsünde kullanılabilir. Bir dosyayı satır satır işlemek için şöyle bir döngü kurulur.\n\nfor satır in f:\n    print(satır.upper(),end=\"\")\nf.close()\n\nTÜRK ISTIKLÂLINI, TÜRK CUMHURIYETI'NI, \nILELEBET MUHAFAZA VE MÜDAFAA ETMEKTIR.\n\n\n\n\nContext manager with ... as\nYukarıda, dosyayı open() ile açtıktan sonra close() metoduyla kapatmak gerektiğini söyledik. Bu basit bir kural olsa da, karmaşık programlar içinde gözden kaçabiliyor. Dosya açma/kapama işlemini daha düzenli hale getirmek için Python programcıları context manager denen bir yapı kullanırlar. Bir context manager oluşturmak için with ... as komutu kullanılır.\n\nwith open(\"deneme.txt\") as f:\n    print(f.read())\n\nEy Türk Gençliği!\nBirinci vazifen, \nTürk istiklâlini, Türk Cumhuriyeti'ni, \nilelebet muhafaza ve müdafaa etmektir.\n\n\n\nContext manager ayrı ve geniş bir konudur, ayrıntısı için Python belgelerine bakabilirsiniz. Bizim açımızdan önemli olan, burada with bloku bitince dosyanın otomatik olarak kapatılmasıdır. Dosyanın kapanmış olduğunu, dosya nesnesinin closed değişkeninin durumuyla kontrol edebiliriz.\n\nf.closed\n\nTrue\n\n\n\n\nDosyaya yazmak\nBir dosyaya yazmak için open() fonksiyonunda \"w\" (write) modunu kullanırız.\n\nf = open(\"deneme2.txt\", \"w\")\n\nBu komutla, mevcut dizinde deneme2.txt dosyası yoksa yaratılır, varsa mevcut içeriği silinip üstüne yeni veri yazılır. Açılan dosyaya bir dize yazmak için write() metodu kullanılır.\n\nf.write(\"ABCDE\\n\")\nf.write(\"123456\\n\")\nf.write(\"wxyz\\n\")\nf.close()\n\nDosyayı açarak, veya %cat sihirini kullanarak içeriğine bakabiliriz.\n\n%cat deneme2.txt\n\nABCDE\n123456\nwxyz\n\n\nAynısını bir context manager ile de yapabiliriz:\n\nwith open(\"deneme2.txt\", \"w\") as f:\n    f.write(\"ABCDE\\n\")\n    f.write(\"123456\\n\")\n    f.write(\"wxyz\\n\")\n\nDosyada mevcut bulunan verileri silmeden, yeni verilerin dosyanın altına eklenmesini istersek dosyayı \"a\" (append) modunda açmalıyız.\n\nwith open(\"deneme2.txt\", \"a\") as f:\n    f.write(\"Yeni satır 1\\n\")\n    f.write(\"Yeni satır 2\\n\")\n\n\n%cat deneme2.txt\n\nABCDE\n123456\nwxyz\nYeni satır 1\nYeni satır 2"
  },
  {
    "objectID": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html#csv-dosya-biçimi",
    "href": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html#csv-dosya-biçimi",
    "title": "Python Programlamaya Giriş 20 - Dosya okuma ve yazma",
    "section": "CSV dosya biçimi",
    "text": "CSV dosya biçimi\nBir çok veri dosyasında veriler tablo halinde, her satırda bir kayıt ve her sütunda o kayda ait bir alan olacak şekilde düzenlenmişlerdir. Alanlar birbirlerinden boşlukla, virgülle, veya başka bir karakterle ayrılabilir. Bu tür bir dosya düzenine CSV (comma-separated values, virgülle ayrılmış değerler) adı verilir. CSV biçimindeki dosyaları okumak için yukarıda açıkladığımız genel yöntemleri kullanmak mümkünse de, Python’un csv modülü işleri basitleştirir. Sözgelişi MS Excel ve benzeri bir hesap tablosunu CSV biçiminde kaydedip, verileri Python ile okuyabilirsiniz; veya Python’la üretilen verileri CSV dosyası olarak kaydedip hesap tablosu uygulamasıyla açabilirsiniz.\n\nCSV okuma\nÖnce bir örnek veri dosyası hazırlayalım.\n\n%%writefile ornek.csv\n\"Potter, H\",37,\"Londra, İngiltere\"\n\"Granger, H\",36,\"Sydney, Avustralya\"\n\"Weasley, Bill\",45,\"Bükreş, Romanya\"\n\nWriting ornek.csv\n\n\nBu örnekte isim ve adres alanı değerlerinin tırnak içinde yazıldığına dikkat edin. Eğer tırnak kullanılmasaydı, alanları virgülle ayırma kuralı bize \"Potter\", \"H\", 37, \"Londra\", \"İngiltere\" gibi beş ayrı alan verirdi.\nBir CSV dosyasını açtıktan sonra, csv modülündeki reader() fonksiyonunu kullanarak onu satır satır okuyacak bir iteratör nesnesi yaratırız. Sonra bu iteratör nesnesi üzerinde bir döngüyle dosyayı tarayabiliriz.\n\nimport csv\nwith open(\"ornek.csv\") as f:\n    okur = csv.reader(f)\n    for satır in okur:\n        print(satır)\n\n['Potter, H', '37', 'Londra, İngiltere']\n['Granger, H', '36', 'Sydney, Avustralya']\n['Weasley, Bill', '45', 'Bükreş, Romanya']\n\n\nVeya dosyamızda alan ayırıcı olarak boşluk karakteri, alan gruplama için bölü işareti (/) kullanılmış olabilir. Bu durumda reader() fonksiyonundaki delimiter ve quotechar parametrelerini değiştirerek dosyayı doğru şekilde alabiliriz.\n\n%%writefile ornek2.csv\n/Potter, H/ 37 /Londra, İngiltere/\n/Granger, H/ 36 /Sydney, Avustralya/\n/Weasley, Bill/ 45 /Bükreş, Romanya/\n\nWriting ornek2.csv\n\n\n\nwith open(\"ornek2.csv\") as f:\n    okur = csv.reader(f, delimiter=\" \", quotechar=\"/\")\n    for satır in okur:\n        print(satır)\n\n['Potter, H', '37', 'Londra, İngiltere']\n['Granger, H', '36', 'Sydney, Avustralya']\n['Weasley, Bill', '45', 'Bükreş, Romanya']\n\n\nGörüldüğü gibi, bir CSV dosyasında alan ayırma, gruplama, satır sonu karakterleri için farklı tercihler olabilir. Her bir tercih kümesine bir lehçe (dialect) adı veriliyor. csv.reader() için varsayılan lehçe olan \"excel\", MS Excel ile üretilen CSV dosyalarını okumaya ayarlıdır. Ancak yukarıda gördüğümüz gibi bu tercihler kolaylıkla değiştirilebilir.\nEğer özel bir CSV biçimini sık sık kullanıyorsanız, o lehçeye özel bir Dialect nesnesi oluşturup reader() ile birlikte kullanabilirsiniz. Bunun ayrıntılarını Python belgelerinden öğrenebilirsiniz.\n\n\nCSV yazma\nElimizdeki verileri bir CSV dosyasına yazmak için önce csv modülünün writer() fonksiyonuyla bir yazıcı nesnesi yaratırız. Yazıcı nesnesi verilen veriyi kullanılan “lehçe”ye uygun şekilde bir dizeye dönüştürür ve dosyaya yazar. Yazılacak dosyayı open() ile açarken newline=\"\" parametresi vermemiz gerekir.\nYazıcı nesnesinin writerow() metodu yazılacak satırı bir liste olarak alır.\n\nwith open(\"ornek3.csv\", \"w\", newline=\"\") as f:\n    yazıcı = csv.writer(f)\n    yazıcı.writerow(['Potter, H', '37', 'Londra, İngiltere'])\n    yazıcı.writerow(['Granger, H', '36', 'Sydney, Avustralya'])\n\nDosyanın içeriğine bakarak doğru yazılıp yazılmadığını kontrol edelim\n\n%cat ornek3.csv\n\n\"Potter, H\",37,\"Londra, İngiltere\"\n\"Granger, H\",36,\"Sydney, Avustralya\"\n\n\n\n\nPandas ile CSV okuma\nCSV dosyalarını veri analizi paketi pandas ile de okumak ve yazmak mümkündür. Pandas ile CSV okumak hem daha basittir, hem de csv modülünde bulunmayan sözgelişi veri içindeki yorumları elemek, sadece istenen sütunları almak gibi ince ayarlara da imkan verir.\nPandas’ın read_csv() fonksiyonu dosyanın içeriğini bir veri çerçevesi olarak okur; ardından bu veri çerçevesinden çeşitli satırlar veya sütunlar alınabilir. Pandas kullanımı bu notların kapsamı dışında olduğu için ayrıntıya girmiyorum."
  },
  {
    "objectID": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html#diğer-dosya-formatları",
    "href": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html#diğer-dosya-formatları",
    "title": "Python Programlamaya Giriş 20 - Dosya okuma ve yazma",
    "section": "Diğer dosya formatları",
    "text": "Diğer dosya formatları\nBirçok dosya biçimi için Python’da özelleşmiş kütüphaneler vardır. Bunların bazılarına değinelim.\n\nJSON\nBirçok internet hizmeti API’si, sorgulama sonuçlarını JSON biçiminde bir dosya olarak verir (sözgelişi daha önce Foursquare, Weather Underground ve Star Wars API’lerini JSON verilerini incelemiştik). Python standart kütüphanesindeki json modülü, JSON biçimli bir dosyayı okuyup bir Python sözlük veya listesine dönüştüren, ve Python nesnelerinden JSON biçimli bir dosya oluşturan fonksiyonları içerir.\nMockaroo sitesini kullanarak yalancı veri içeren küçük bir JSON dosyası üretelim.\n\n%%writefile yalanci_veri.json\n[{\n  \"id\": 1,\n  \"first_name\": \"Fredia\",\n  \"last_name\": \"Waith\",\n  \"email\": \"fwaith0@tamu.edu\"\n}, {\n  \"id\": 2,\n  \"first_name\": \"Rafaello\",\n  \"last_name\": \"Rowthorn\",\n  \"email\": \"rrowthorn1@stanford.edu\"\n}, {\n  \"id\": 3,\n  \"first_name\": \"Harriette\",\n  \"last_name\": \"Patters\",\n  \"email\": \"hpatters2@samsung.com\"\n}]\n\nWriting yalanci_veri.json\n\n\nŞimdi bu dosyayı açıp, içeriğini yorumlayalım ve bir Python nesnesine aktaralım.\n\nimport json\nwith open(\"yalanci_veri.json\") as f:\n    yalanciveriler = json.load(f)\n\nBu işlem sonucunda bir sözlükler listesi elde etmiş oluruz. Bilindik indeksleme işlemleriyle tek tek elemanlara ulaşabiliriz.\n\nyalanciveriler[1][\"first_name\"], yalanciveriler[1][\"email\"]\n\n('Rafaello', 'rrowthorn1@stanford.edu')\n\n\nŞimdi JSON dosyası yazmayı görelim. Elimizdeki veriye bir satır daha ekleyelim ve nesnenin yeni halini json.dump() ile dosyaya yazalım.\n\nyalanciveriler.append(\n{\n  \"id\": 4,\n  \"first_name\": \"Giffer\",\n  \"last_name\": \"Dur\",\n  \"email\": \"gdur2@cnbc.com\"\n})\n\nwith open(\"yalanci_veri.json\", \"w\") as f:\n    json.dump(yalanciveriler,f)\n\nDosyanın içeriğine bakarak beklediğimiz şekilde yazıldığını görebiliyoruz.\n\n%cat yalanci_veri.json\n\n[{\"id\": 1, \"first_name\": \"Fredia\", \"last_name\": \"Waith\", \"email\": \"fwaith0@tamu.edu\"}, {\"id\": 2, \"first_name\": \"Rafaello\", \"last_name\": \"Rowthorn\", \"email\": \"rrowthorn1@stanford.edu\"}, {\"id\": 3, \"first_name\": \"Harriette\", \"last_name\": \"Patters\", \"email\": \"hpatters2@samsung.com\"}, {\"id\": 4, \"first_name\": \"Giffer\", \"last_name\": \"Dur\", \"email\": \"gdur2@cnbc.com\"}]\n\n\n\n\nHTML\nHTML dosyaları zaten düz metinden oluştuğu için onları okumakta teknik bir zorluk yok. HTML işlemede asıl istenen şey parsing, yani çeşitli HTML elemanlarına erişebilmektir. Söz gelişi, bir HTML’deki bağlantıları almak, tablo veriyi okumak gibi işlemler yapmamız gerekebilir. Bu tür işlemler bu yazı dizisinin kapsamını aşıyor. İlgilenenler, en çok kullanılan araçlardan biri olan Beautiful Soup modülüyle denemeler yapabilirler.\n\n\nExcel\nMS Excel dosyalarını CSV olarak kaydederseniz CSV okuma/yazma kısmındaki yöntemleri kullanabilirsiniz. Bunu istemiyorsanız, veya tablodaki verileriniz bu işleme uygun değilse, veya birden fazla yapraktan oluşuyorsa, Excel dosyasını doğrudan açmak için xlrd modülünü kullanabilirsiniz.\nDaha geniş özelliklere sahip bir paket olan pyexcel ile hem okuma hem de yazmayı daha kolay işlemlerle yapabilirsiniz.\nPandas paketinin read_excel() fonksiyonu ile bir Excel dosyasını doğrudan okuyarak bir veri çerçevesi haline getirebilirsiniz. Kullanımına bir örnek görmek için “Groupby” yazımıza bakabilirsiniz. Word\n\nMS Word belgelerinin içinden metin almak, belge yaratmak ve varolan belgeye içerik eklemek için python-docx modülü kullanılabilir. Örnekler için Al Sweigart’ın Automate The Boring Stuff with Python kitabına bakabilirsiniz.\n\n\nPDF\nPDF dosyalarından bilgi almak, PDF dosyası yaratmak, mevcut dosyada değişiklik yapmak gibi işler için pyPDF2 modülünü kullanabilirsiniz. Sweigart’ın Automate The Boring Stuff with Python [kitabında] (https://automatetheboringstuff.com/chapter13/) bu modülün kullanımına dair açıklayıcı örnekler bulabilirsiniz.\n\n\nZIP\nPython standart kütüphanesindeki zipfile modülü, ZIP formatında sıkıştırma ve açma fonksiyonları sağlar. Basit bir örnek olarak, yukarıda kullandığımız deneme.txt ve yalanci_veri.json dosyalarını sıkıştırarak bir arşiv dosyası oluşturalım.\n\nimport zipfile\nwith zipfile.ZipFile(\"arsiv.zip\",\"w\") as z:\n    z.write(\"deneme.txt\")\n    z.write(\"yalanci_veri.json\")\n\nMevcut bir arşive bir dosya eklemek istiyorsak, ZipFile() fonksiyonunun açılma modunu \"w\" yerine \"a\" yaparız.\nZipFile() fonksiyonu, yukarıda gördüğümüz open() gibi çalışır. Arşivi açmak için ZipFile() fonksiyonunu okuma modunda kullanırız, ve arşiv dosyası nesnesine ait open() metoduyla dosyayı açarız. Açılan dosyanın içeriği read(), readline() veya readlines() metodlarıyla okunabilir. Bu metodlar kodlanmış dizeler döndürdüğü için decode() dize metoduyla Unicode’a çevrilmelidir.\n\nwith zipfile.ZipFile('arsiv.zip') as z:\n    with z.open('deneme.txt') as f:\n        print(f.read().decode(\"utf-8\"))\n\nEy Türk Gençliği!\nBirinci vazifen, \nTürk istiklâlini, Türk Cumhuriyeti'ni, \nilelebet muhafaza ve müdafaa etmektir.\n\n\n\nBir ZIP arşivindeki bir dosyayı açarak diske kaydetmek için extract(), arşivdeki bütün dosyaları açmak için extractall() fonksiyonları kullanabiliriz."
  },
  {
    "objectID": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html#değişkenlerimizi-kaydetmek-pickle",
    "href": "posts/2018/04/11/python-programlamaya-giris-20-dosya-okuma-ve-yazma/index.html#değişkenlerimizi-kaydetmek-pickle",
    "title": "Python Programlamaya Giriş 20 - Dosya okuma ve yazma",
    "section": "Değişkenlerimizi kaydetmek: pickle",
    "text": "Değişkenlerimizi kaydetmek: pickle\nBir oturumda hazırladığınız değişkenleri, oturumu kapattığınızda kaybetmemek isterseniz bunları ikili (binary) bir veri yapısı haline getirip diske kaydetmeniz gerekir. Bu işi standart kütüphanedeki pickle modülü ile yapabilirsiniz. Neredeyse bütün Python nesnelerini (kendi tanımladığımız nesne sınıfları dahil) dosyaya kaydetmeniz ve sonra tekrar okumanız mümkündür. Bu işleme serialization adı verilir.\nBirkaç değişken tanımlayalım.\n\nx = 3.14159\nL = [1,3,2,5,4]\nD = {\"abc\": 123, \"def\": 456}\ndef fon(x):\n    return x*x\n\nVerileri kaydetmek istediğimiz dosyayı ikili yazma modunda açalım ve pickle modülündeki dump() fonksiyonuyla değişkenleri dosyaya ekleyelim.\n\nimport pickle\nwith open(\"data.p\", \"wb\") as f:\n    pickle.dump(x,f)\n    pickle.dump(L,f)\n    pickle.dump(D,f)\n    pickle.dump(fon,f)\n\nDeğişkenleri dosyadan okumak için load() fonksiyonunu kullanırız. Nesneler dosyaya kondukları sırayla geri alınırlar. Değişkenlerin orijinal adını kullanmamız gerekmez.\n\nwith open(\"data.p\", \"rb\") as f:\n    y = pickle.load(f)\n    print(y)\n    J = pickle.load(f)\n    print(J)\n    F = pickle.load(f)\n    print(F)\n    G = pickle.load(f)\n    print(G(y))\n\n3.14159\n[1, 3, 2, 5, 4]\n{'abc': 123, 'def': 456}\n9.869587728099999\n\n\nBazı nesneler pickle ile kaydedilemezler; ağ bağlantıları, veri tabanı bağlantıları, açık dosya nesneleri gibi.\nDikkat: pickle işlemleri herhangi bir emniyet tedbiri içermez. Pickle dosyasının içindeki nesne load() ile doğrudan doğruya çalıştırılır. Bu nesnenin içinde kötü amaçlı bir kod parçası varsa sisteminize zarar gelebilir. Bu yüzden bilmediğiniz bir yerden gelen pickle dosyalarını açmayın."
  },
  {
    "objectID": "posts/2018/03/30/pandasa-giris-veri-cerceveleri/index.html",
    "href": "posts/2018/03/30/pandasa-giris-veri-cerceveleri/index.html",
    "title": "pandas’a Giriş - Veri Çerçeveleri",
    "section": "",
    "text": "Pandas ile ilgili bu yazımızda veri çerçevesi (DataFrame) isimli veri yapısını ele alacağız. Önceki yazımızda etiketli verilerden oluşan serileri görmüştük. Seriler tek boyutlu bir veri yapısıyken, veri çerçevelerini her sütunu bir seriden oluşan iki boyutlu bir matris olarak düşünebiliriz. Serilerde bahsettiğimiz birçok yöntemi veri çerçevelerinde de kullanmak mümkün. Ayrıca SQL tablolarında kullanılan tablo birleştirme (JOIN) gibi işlemleri de Pandas ile yapmak mümkün.\n\nVeri Çerçeveleri\nVeri çerçevelerini birden fazla serinin bir araya gelmiş hali olarak düşünebiliriz. Veri çerçeveleri de seriler gibi etiketli bir veri yapısıdır, ancak serilerden farkı iki boyutlu olmasıdır. Serilerdeki gibi etiket değerlerine indeks (index) denir. Veri çerçeveleri index alanının yanında columns alanını da içeriyor. columns sütunların isimlerini içeren bir sıralı nesne.\nVeri çerçevesi oluşturmak için serileri kullanmak mümkün. Linkten erişebileceğiniz IMF’nin gayrisafi yurt içi hasıla verisi ile ilk denemeyi yapabiliriz. 2016 ve 2017 yılları için serileri anlattığımız yazıdaki veri kümelerini oluşturalım.\n\n# Pandas paketini yükleyelim\nimport pandas as pd \nimport numpy as np\n\n# GSYİH değeri en yüksek olan 10 ülkenin değerlerini kullanacağız.\ngdp_data_2017 = [19362.13, 11937.56, 4884.49, 3651.87, 2574.81, 2565.05, 2439.01, \n                 2080.92, 1921.14, 1640.39]\n# İndeks değerlerini içeren listeyi oluşturalım.\ngdp_index_2017 = ['ABD', 'Çin', 'Japonya', 'Almanya', 'Fransa', \n                  'Birleşik Krallık', 'Hindistan', 'Brezilya', 'İtalya', 'Kanada']\n\n# Seriyi oluşturalım. İndeks değerini vermediğimizde, Pandas 0'dan başlayarak veriyi indeksler.\ngdp_2017 = pd.Series(gdp_data_2017, index = gdp_index_2017, name = 'GDP_2017')\n\n# Aynı işlemi 2016 yılı için yapalım.\nd = {'ABD':18624.45,\n'Çin':11232.11,\n'Japonya':4936.54,\n'Almanya':3479.23,\n'Fransa':2466.47,\n'Birleşik Krallık':2629.19,\n'Hindistan':2263.79,\n'Brezilya':1798.62,\n'İtalya':1850.74,\n'Kanada':1529.76,\n'Kore':1411.04}\n\ngdp_2016 = pd.Series(d, name = 'GDP_2016')\n\nprint(gdp_2016)\nprint(gdp_2017)\n\nABD                 18624.45\nAlmanya              3479.23\nBirleşik Krallık     2629.19\nBrezilya             1798.62\nFransa               2466.47\nHindistan            2263.79\nJaponya              4936.54\nKanada               1529.76\nKore                 1411.04\nÇin                 11232.11\nİtalya               1850.74\nName: GDP_2016, dtype: float64\nABD                 19362.13\nÇin                 11937.56\nJaponya              4884.49\nAlmanya              3651.87\nFransa               2574.81\nBirleşik Krallık     2565.05\nHindistan            2439.01\nBrezilya             2080.92\nİtalya               1921.14\nKanada               1640.39\nName: GDP_2017, dtype: float64\n\n\nOluşturduğumuz serileri birleştirmek için iki yol kullanacağız. Bunlardan biri pandas altındaki concat fonksiyonu, diğeri ise serilerden oluşan bir sözlük tanımlamak olacak.\nconcat fonksiyonunu kullanırken sütunların isimlerini ayrıca belirtmemize gerek yok. Bunun yerine serilerin name alanı sütun isimleri olarak atanıyor. Bir seride olup diğerinde olmayan değerler (Kore gibi) NaN değeriyle gösterilir.\n\ndf = pd.concat([gdp_2017, gdp_2016], axis = 1)\nprint(df)\n\n                  GDP_2017  GDP_2016\nABD               19362.13  18624.45\nAlmanya            3651.87   3479.23\nBirleşik Krallık   2565.05   2629.19\nBrezilya           2080.92   1798.62\nFransa             2574.81   2466.47\nHindistan          2439.01   2263.79\nJaponya            4884.49   4936.54\nKanada             1640.39   1529.76\nKore                   NaN   1411.04\nÇin               11937.56  11232.11\nİtalya             1921.14   1850.74\n\n\nVeri çerçevesindeki değerlerin serilerdeki yerinden bağımsız olarak indeks alanına göre eşleştirildiğini görüyoruz. Ondalık işaretini virgüle çevirmek için aşağıdaki yerel ayarları kullanabiliriz. Aşağıdaki kutucukta yerel ayarları değiştiriyoruz ve ondalıklı sayıları formatlıyoruz. Son satırdaki grouping = False binlik işaretini kullanmayacağımızı belirtiyor. Yerel ayarların formatlama ile kullanılması konusunda Kaan’ın sıralı nesneler ve dizeler için yazdığı yazıları incelemenizi tavsiye ederim.\n\nimport locale\nloc = locale.getlocale()\n# Yerel ayarları Türkiye standartlarına çeviriyoruz.\nlocale.setlocale(locale.LC_ALL, \"Turkish_Turkey.1254\")\n# Küsuratlı sayıları virgülden sonra iki basamak içerecek şekilde formatlıyoruz.\n# Binlik işaretini kullanmayacağız.\npd.set_option('display.float_format', lambda x: locale.format('%.2f', x, grouping = False))\n\nAşağıdaki örnekte, veri çerçevesini serilerden oluşan bir sözlük yardımıyla oluşturuyoruz. Sözlüğün anahtarı sütunun ismine atanır.\n\nd = {'2017' : gdp_2017,\n     '2016' : gdp_2016}\n\ndf = pd.DataFrame(d)\nprint(df)\n\n                     2016     2017\nABD              18624,45 19362,13\nAlmanya           3479,23  3651,87\nBirleşik Krallık  2629,19  2565,05\nBrezilya          1798,62  2080,92\nFransa            2466,47  2574,81\nHindistan         2263,79  2439,01\nJaponya           4936,54  4884,49\nKanada            1529,76  1640,39\nKore              1411,04      nan\nÇin              11232,11 11937,56\nİtalya            1850,74  1921,14\n\n\nOndalık işaretinin değiştiğini görebilirsiniz.\nSözlük listeleri de veri çerçevesi oluşturmak için kullanılabilir. Aşağıdaki örnekteki listedeki her bir sözlük bir ülkenin GSYİH değerine denk geliyor. Hangi ülkeler olduğunu ise veri çerçevesini oluştururken söylüyoruz. Belirtmediğimiz değerler de NaN değerini alıyor.\n\ndata = [{'GDP_2016':3651.87, 'GDP_2017': 3479.23}, {'GDP_2016' : 2466.47}]\ndf = pd.DataFrame(data, index = ['Almanya', 'Fransa'])\nprint(df)\n\n         GDP_2016  GDP_2017\nAlmanya   3651,87   3479,23\nFransa    2466,47       nan\n\n\nVeri çerçevelerinin matrisler gibi iki boyutlu bir veri yapısı olduğundan bahsetmiştik. Matrisler de veri çerçeveleri oluşturmak için kullanılabilir.\n\n# 2x2'lik rassal sayılardan oluşan bir matris oluşturalım.\ndata = np.random.rand(2,2)\n# Index ve columns değerlerini veri çerçevesini oluştururken tanımlayabiliriz.\ndf = pd.DataFrame(data, index = ['1. satır', '2. satır'], columns=['1. sütun', '2. sütun'])\nprint(df)\n\n          1. sütun  2. sütun\n1. satır      0,45      0,42\n2. satır      1,00      0,96\n\n\nUygulamalarınızda kullanacağınız boyuttaki verileri bahsettiğimiz yöntemlerle veri çerçevesine atamanın zorluğunu farketmişsinizdir. Neyse ki pandas çeşitli formatlardaki dosyaları okumanızı sağlayacak fonksiyonlar içeriyor.\n\n\nDosya okuma\npandas paketi csv, Excel, JSON formatlarındaki dosyaların yanında Stata, SAS programlarıyla oluşturulmuş dosyaları da okuyarak içeriğini bir veri çerçevesine atamanızı sağlayan fonksiyonlar içeriyor. Benim sıklıkla kullandığım read_clipboard fonksiyonu ise kopyaladığınız bir veriyi (örneğin bir Excel tablosunu) veri çerçevesine dönüştürüyor.\nread_csv fonksiyonunda sıklıkla kullanabileceğiniz parametreleri aşağıda bulabilirsiniz:\n\nsep: kolonları ayıran karakter ya da kurallı ifade (varsayılan değer ','),\nheader: sütun isimlerini içeren satırın numarası (varsayılan değer 0, eğer böyle bir satır yoksa None),\nindex_col: indeks değerlerini içeren sütunun numarası,\nnames: sütun isimlerini içeren sıralı nesne.\n\nread_excel fonksiyonunda ek olarak birden fazla sayfa içeren dokümanlarda hangi sayfaları okutacağınızı belirten sheet_name argümanını da kullanabilirsiniz. sheet_name değeri sayfanın adı, indeksi (ya da bunların bir listesi) olabilir. Ayrıca None değerini kullanmanız halinde bütün sayfaları okutabilirsiniz. Örnek olarak linkten indirebileceğiniz bir çevrimiçi alışveriş veri kümesini kullandım.\n\n# Dosya tek bir sayfa içerdiği için sheet_name'e ihtiyaç duymadık.\n# Benim bilgisayarımda Excel dosyası ile Jupyter Notebook dosyası \n# aynı klasörde olduğundan adres belirtmedim.\ndf = pd.read_excel('Online Retail.xlsx', decimal = ',')\nprint(df.head())\n\n  InvoiceNo StockCode                          Description  Quantity  \\\n0    536365    85123A   WHITE HANGING HEART T-LIGHT HOLDER         6   \n1    536365     71053                  WHITE METAL LANTERN         6   \n2    536365    84406B       CREAM CUPID HEARTS COAT HANGER         8   \n3    536365    84029G  KNITTED UNION FLAG HOT WATER BOTTLE         6   \n4    536365    84029E       RED WOOLLY HOTTIE WHITE HEART.         6   \n\n          InvoiceDate  UnitPrice  CustomerID         Country  \n0 2010-12-01 08:26:00       2,55    17850,00  United Kingdom  \n1 2010-12-01 08:26:00       3,39    17850,00  United Kingdom  \n2 2010-12-01 08:26:00       2,75    17850,00  United Kingdom  \n3 2010-12-01 08:26:00       3,39    17850,00  United Kingdom  \n4 2010-12-01 08:26:00       3,39    17850,00  United Kingdom  \n\n\nKolonların isimlerini değiştirelim.\n\ndf.columns = ['FaturaNo', 'UrunNo', 'Tanim', 'Adet', 'FaturaTarihi', 'BirimFiyat', 'MusteriNo', 'Ulke']\nprint(df.head())\n\n  FaturaNo  UrunNo                                Tanim  Adet  \\\n0   536365  85123A   WHITE HANGING HEART T-LIGHT HOLDER     6   \n1   536365   71053                  WHITE METAL LANTERN     6   \n2   536365  84406B       CREAM CUPID HEARTS COAT HANGER     8   \n3   536365  84029G  KNITTED UNION FLAG HOT WATER BOTTLE     6   \n4   536365  84029E       RED WOOLLY HOTTIE WHITE HEART.     6   \n\n         FaturaTarihi  BirimFiyat  MusteriNo            Ulke  \n0 2010-12-01 08:26:00        2,55   17850,00  United Kingdom  \n1 2010-12-01 08:26:00        3,39   17850,00  United Kingdom  \n2 2010-12-01 08:26:00        2,75   17850,00  United Kingdom  \n3 2010-12-01 08:26:00        3,39   17850,00  United Kingdom  \n4 2010-12-01 08:26:00        3,39   17850,00  United Kingdom  \n\n\n\n\nTemel Metotlar ve Erişim\nVeri çerçevelerinde, serilerde gördüğümüz dim, shape, size alanlarını ve erişim için kullandığımız loc ve iloc fonksiyonları kullanabiliriz. Serilerden farklı olarak veri çerçeveleri iki boyutlu, size alanı da bu nedenle sütun ve satır sayısının çarpımına eşit.\n\nprint('Boyut: {}'.format(df.ndim))\nprint('Şekil: {}'.format(df.shape))\nprint('Uzunluk: {}'.format(df.size))\nprint('Sütunlar: {}'.format(df.columns))\n\nBoyut: 2\nŞekil: (541909, 8)\nUzunluk: 4335272\nSütunlar: Index(['FaturaNo', 'UrunNo', 'Tanim', 'Adet', 'FaturaTarihi', 'BirimFiyat',\n       'MusteriNo', 'Ulke'],\n      dtype='object')\n\n\nErişim için de yine serilerde gördüğümüz iloc ve loc metotlarını kullanabiliriz. Aynı zamanda Kaan’ın Sıralı Nesneler İşlemler yazısında bahsettiği dilimleme yöntemlerini kullanabiliriz.\n\nprint('Veri çerçevesinin 0,0 indeksindeki değer: {}'.format(df.iloc[0,0]))\nprint('Veri çerçevesinin ilk satırındaki değerler:\\n{}'.format(df.iloc[0,:]))\n\nVeri çerçevesinin 0,0 indeksindeki değer: 536365\nVeri çerçevesinin ilk satırındaki değerler:\nFaturaNo                                    536365\nUrunNo                                      85123A\nTanim           WHITE HANGING HEART T-LIGHT HOLDER\nAdet                                             6\nFaturaTarihi                   2010-12-01 08:26:00\nBirimFiyat                                    2,55\nMusteriNo                                 17850,00\nUlke                                United Kingdom\nName: 0, dtype: object\n\n\nVerideki eksik değerler özel ilgi göstermemizi gerektirecek durumlara işaret edebilir. Şimdi sütunlardaki eksik değerlerin sayısına bakalım. isnull veri çerçevesinin boyutunda 0 ve 1 (True/False) değerlerinden oluşan bir veri çerçevesi döndürüyor. Bu veri çerçevesi NaN olan hücreler için True, diğer hücreler için False değerine sahip. Sütunlar üzerinden toplarsak eksik değer içeren hücre sayısını bulabiliriz.\n\nprint('Eksik hücre sayısı')\nprint(df.isnull().sum())\n\nEksik hücre sayısı\nFaturaNo             0\nUrunNo               0\nTanim             1454\nAdet                 0\nFaturaTarihi         0\nBirimFiyat           0\nMusteriNo       135080\nUlke                 0\ndtype: int64\n\n\nMüşteri numarası olmayan 135080 satır var. Bu satırları veri setinden çıkaralım.\n\ndf = df[~df['MusteriNo'].isnull()]\nprint('Şekil: {}'.format(df.shape))\nprint('Eksik hücre sayısı')\nprint(df.isnull().sum())\n\nŞekil: (406829, 8)\nEksik hücre sayısı\nFaturaNo        0\nUrunNo          0\nTanim           0\nAdet            0\nFaturaTarihi    0\nBirimFiyat      0\nMusteriNo       0\nUlke            0\ndtype: int64\n\n\nAlternatif olarak eksik değerleri istediğiniz başka bir değerle değiştirmeniz de mümkün. Bu amaçla fillna fonksiyonunu kullanabilirsiniz. Örnek olarak eksik değerleri 0 değeriyle doldurmak için df.fillna(0, inplace = True) yazmanız yeterli. Buradaki inplace argümanı değişikliğin veri çerçevesi üzerinde yapılmasını sağlar. Bunu kullanmak istemezseniz bir atama yapmanız gerekecek (df = df.fillna(0)). İki seçeneği de kullanmamanız haline orijinal veri çerçevesi değişmeyecektir.\nMüşteri numaraları tamsayı olması gerekirken ondalıklı olarak okunduğu için tamsayıya çevirelim.\n\n# Aşağıdaki satırda sütunlara ulaşmanın iki farklı yolunu görüyoruz. \n# Veri_çerçevesi['sütun_adı'] ve Veri_çerçevesi.Sütun_adı\ndf['MusteriNo'] = df.MusteriNo.astype('int')\nprint(df.head())\n\n  FaturaNo  UrunNo                                Tanim  Adet  \\\n0   536365  85123A   WHITE HANGING HEART T-LIGHT HOLDER     6   \n1   536365   71053                  WHITE METAL LANTERN     6   \n2   536365  84406B       CREAM CUPID HEARTS COAT HANGER     8   \n3   536365  84029G  KNITTED UNION FLAG HOT WATER BOTTLE     6   \n4   536365  84029E       RED WOOLLY HOTTIE WHITE HEART.     6   \n\n         FaturaTarihi  BirimFiyat  MusteriNo            Ulke  \n0 2010-12-01 08:26:00        2,55      17850  United Kingdom  \n1 2010-12-01 08:26:00        3,39      17850  United Kingdom  \n2 2010-12-01 08:26:00        2,75      17850  United Kingdom  \n3 2010-12-01 08:26:00        3,39      17850  United Kingdom  \n4 2010-12-01 08:26:00        3,39      17850  United Kingdom  \n\n\n\n\nVeri İşleme\nVeri çerçevesinde ürünler için birim fiyat ve satın alınan adet değerleri var. Müşterilerin o ürün için toplam harcamasını içeren bir sütun ekleyelim. Yeni sütunun adı Miktar olsun.\n\ndf['Miktar'] = df['BirimFiyat'] * df['Adet']\nprint(df.head())\n\n  FaturaNo  UrunNo                                Tanim  Adet  \\\n0   536365  85123A   WHITE HANGING HEART T-LIGHT HOLDER     6   \n1   536365   71053                  WHITE METAL LANTERN     6   \n2   536365  84406B       CREAM CUPID HEARTS COAT HANGER     8   \n3   536365  84029G  KNITTED UNION FLAG HOT WATER BOTTLE     6   \n4   536365  84029E       RED WOOLLY HOTTIE WHITE HEART.     6   \n\n         FaturaTarihi  BirimFiyat  MusteriNo            Ulke  Miktar  \n0 2010-12-01 08:26:00        2,55      17850  United Kingdom   15,30  \n1 2010-12-01 08:26:00        3,39      17850  United Kingdom   20,34  \n2 2010-12-01 08:26:00        2,75      17850  United Kingdom   22,00  \n3 2010-12-01 08:26:00        3,39      17850  United Kingdom   20,34  \n4 2010-12-01 08:26:00        3,39      17850  United Kingdom   20,34  \n\n\nFaturaNo ve o faturaya ait toplam miktarı içeren yeni bir veri çerçevesi oluşturalım. groupby fonksiyonuyla her alışverişin toplam miktarını bulabiliriz. Groupby fonksiyonunun kullanımını Veri Defteri’nin ilk yazılarından birinde anlatmıştık.\n\ndf_fis = df.groupby(['FaturaNo']).agg({'Miktar' : 'sum'}).reset_index()\ndf_fis.columns = ['FaturaNo', 'ToplamMiktar']\nprint(df_fis.head())\n\n  FaturaNo  ToplamMiktar\n0   536365        139,12\n1   536366         22,20\n2   536367        278,73\n3   536368         70,05\n4   536369         17,85\n\n\nİlk veri çerçevesine ToplamMiktar sütununu eklemek için pandas paketinin sunduğu birleştirme işlemlerinden yararlanabiliriz. Bu amaçla merge fonksiyonunu kullanacağız.\nmerge işlemi için iki veri çerçevesinin hangi sütunlarının nasıl birleştirileceğini belirtmek gerekiyor. merge fonksiyonu SQL tablolarında kullanılan birleştirme (JOIN) işlemlerini destekliyor. İki veri çerçevesini birleştirmek için FaturaNo anahtarını kullanalım (on = 'FaturaNo'). Farklı isimlere sahip sütunlar üzerinden birleştirme yapmak için right_on = ... ve left_on = ... şeklinde veri çerçevelerindeki sütun isimlerini fonksiyona ekleyebilirsiniz.\nhow argümanı için kullanabileceğiniz değerler:\n\n“inner”: Sadece iki tabloda da bulunan anahtar değerlerini birleştirir. Bir tabloda olmayan değerler silinir.\n“right”: İlk tabloda bulunan değerler korunur ve ikinci tabloda eşleşen değerler tabloya eklenir. İkinci tabloda bulunmayan değerler NaN ile belirtilir.\n“left”: İkinci tabloda bulunan değerler korunur ve ilk tabloda eşleşen değerler tabloya eklenir. İlk tabloda bulunmayan değerler NaN ile belirtilir.\n“outer”: İki tablodan en az birinde bulunan değerler korunur. Bir tabloda olmayan eksik değerler NaN ile belirtilir.\n\n\ndf_yeni = pd.merge(df,df_fis, how= 'inner', on = 'FaturaNo')\nprint(df_yeni.head())\nprint('Şekil: {}'.format(df_yeni.shape))\nprint(df_yeni[df_yeni['FaturaNo'] == 536365])\n\n  FaturaNo  UrunNo                                Tanim  Adet  \\\n0   536365  85123A   WHITE HANGING HEART T-LIGHT HOLDER     6   \n1   536365   71053                  WHITE METAL LANTERN     6   \n2   536365  84406B       CREAM CUPID HEARTS COAT HANGER     8   \n3   536365  84029G  KNITTED UNION FLAG HOT WATER BOTTLE     6   \n4   536365  84029E       RED WOOLLY HOTTIE WHITE HEART.     6   \n\n         FaturaTarihi  BirimFiyat  MusteriNo            Ulke  Miktar  \\\n0 2010-12-01 08:26:00        2,55      17850  United Kingdom   15,30   \n1 2010-12-01 08:26:00        3,39      17850  United Kingdom   20,34   \n2 2010-12-01 08:26:00        2,75      17850  United Kingdom   22,00   \n3 2010-12-01 08:26:00        3,39      17850  United Kingdom   20,34   \n4 2010-12-01 08:26:00        3,39      17850  United Kingdom   20,34   \n\n   ToplamMiktar  \n0        139,12  \n1        139,12  \n2        139,12  \n3        139,12  \n4        139,12  \nŞekil: (406829, 10)\n  FaturaNo  UrunNo                                Tanim  Adet  \\\n0   536365  85123A   WHITE HANGING HEART T-LIGHT HOLDER     6   \n1   536365   71053                  WHITE METAL LANTERN     6   \n2   536365  84406B       CREAM CUPID HEARTS COAT HANGER     8   \n3   536365  84029G  KNITTED UNION FLAG HOT WATER BOTTLE     6   \n4   536365  84029E       RED WOOLLY HOTTIE WHITE HEART.     6   \n5   536365   22752         SET 7 BABUSHKA NESTING BOXES     2   \n6   536365   21730    GLASS STAR FROSTED T-LIGHT HOLDER     6   \n\n         FaturaTarihi  BirimFiyat  MusteriNo            Ulke  Miktar  \\\n0 2010-12-01 08:26:00        2,55      17850  United Kingdom   15,30   \n1 2010-12-01 08:26:00        3,39      17850  United Kingdom   20,34   \n2 2010-12-01 08:26:00        2,75      17850  United Kingdom   22,00   \n3 2010-12-01 08:26:00        3,39      17850  United Kingdom   20,34   \n4 2010-12-01 08:26:00        3,39      17850  United Kingdom   20,34   \n5 2010-12-01 08:26:00        7,65      17850  United Kingdom   15,30   \n6 2010-12-01 08:26:00        4,25      17850  United Kingdom   25,50   \n\n   ToplamMiktar  \n0        139,12  \n1        139,12  \n2        139,12  \n3        139,12  \n4        139,12  \n5        139,12  \n6        139,12  \n\n\nTekrar eden verileri tekilleştirmek için drop_duplicates fonksiyonunu kullanabiliriz. Aşağıda müşteri numaralarını tekilleştirerek kaç müşteri olduğunu buluyoruz. Ben sütunları kopyalamayı tercih ettim. Bunu yapmamanız durumunda Python referans modelinden kaynaklı bir uyarı mesajı alacaksınız. Bu konu hakkında Kaan’ın yazısını okumanızı tavsiye ederim.\n\n# Sadece ürün bilgilerini içeren sütunları alıyoruz.\n# Burada copy işlemini kullanmazsak bir uyarı mesajı alıyoruz.\ndf_musteri = df[['MusteriNo']].copy()\ndf_musteri.drop_duplicates(inplace = True)\nprint(df_musteri.head())\nprint('Şekil: {}'.format(df_musteri.shape))\nprint('Müşteri sayısı: {}'.format(df_musteri.shape[0]))\n\n    MusteriNo\n0       17850\n9       13047\n26      12583\n46      13748\n65      15100\nŞekil: (4372, 1)\nMüşteri sayısı: 4372\n\n\nVeri çerçeveleri scikit-learn, statsmodel gibi bir çok paket tarafından destekleniyor. Tensorflow ve lightgbm gibi popüler paketlerle de veri çerçevelerini kullanabilirsiniz. Yapay öğrenmede sıklıkla kullanılan bu paketlerden scikit-learn paketiyle ilgili bir giriş yazısı yazmıştık. İleride, diğer paketlerle ilgili yazılar yazmayı planlıyoruz.\nBu yazının Jupyter Notebook dosyasına Github dizinimizden ulaşabilirsiniz."
  },
  {
    "objectID": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html",
    "href": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html",
    "title": "Python Programlamaya Giriş 17 - Küme metodları",
    "section": "",
    "text": "Python programlamaya giriş konulu yazı dizimizdeki son birkaç bölümde, Python’da tanımlı temel veri tiplerinin kullanımının ayrıntılarından bahsettik. Bu yazıdaki konumuz, daha önce bahsetmediğimiz bir veri yapısı olan “kümeler”. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\nBir küme, listelerden farklı olarak, belli bir sırası bulunmayan bir veri topluluğudur; yani elemanlarına indeksleme ile erişilemez. Ayrıca, matematiksel kümeler gibi, aynı elemandan birden fazla barındıramaz. Python’da bir küme yaratmanın birinci yolu, nesneleri küme parantezinde toplayarak vermektir:\ns = {(1,2,3),\"abc\",123,-1,\"abc\",(1,2,3)}\ns\n\n{'abc', 123, -1, (1, 2, 3)}\nİkinci yolu ise, set() fonksiyonuna bir sıralı nesne vermektir:\nset([1,3,1,-2,\"abc\", \"abc\"])\n\n{1, 'abc', 3, -2}\nBir dize de karakterlerden oluşan bir sıralı nesnedir, bu yüzden set() fonksiyonu ile dizenin karakterlerinin kümesini elde ederiz.\nset(\"ananas\")\n\n{'a', 'n', 's'}\nÖrneklerden de gördüğünüz gibi kümelerde, matematiksel tanıma uygun olarak, bir eleman sadece bir kere mevcut olabilir. Orijinal sıralı nesnede mükerrer eleman varsa alınmaz.\nPython’da bir liste, bir kümenin elemanı olamaz. Denemeye kalkarsanız hata mesajı alırsınız.\n{1,2, [1,2,3]}\n\nTypeError: unhashable type: 'list'\nBir kümedeki elemanların hashable olabilmesi, yani bir hash fonksiyonuna verilebilmesi gerekir. Bu da genellikle değiştirilemez (immutable) veri tipleri olmalarını gerektirir. Sayılar, çokuzlar, dizeler küme elemanı olmaya uygundurlar. Buna karşılık listeler, sözlükler ve kümeler, küme elemanı olamazlar (evet, matematiksel tanımda kümeler başka kümelerin elemanı olabilir, ama Python’da teknik sebeplerle bu mümkün olmaz).\nBoş küme için set() fonksiyonu tek başına kullanılmalıdır. Boş küme parantezleri {} kullanmak boş bir sözlük oluşturur, küme değil.\ntype(set()), type({})\n\n(set, dict)\nBir kümenin kaç elemanlı olduğunu bulmak için len() fonksiyonu kullanılabilir.\ns = {1,3,1,2,1,3,2}\nlen(s)\n\n3\nBir elemanın kümenin içinde olup olmadığını sorgulamak için e in s kullanılabilir. Ters şart olarak da e not in s kullanılabilir.\n1 in s, 4 in s, 4 not in s\n\n(True, False, True)\nKüme elemanları üzerinde for e in s yapısıyla döngü kurulabilir.\nfor e in s:\n    print(e,e**2)\n\n1 1\n2 4\n3 9"
  },
  {
    "objectID": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#küme-karşılaştırmaları",
    "href": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#küme-karşılaştırmaları",
    "title": "Python Programlamaya Giriş 17 - Küme metodları",
    "section": "Küme karşılaştırmaları",
    "text": "Küme karşılaştırmaları\nKüme nesneleri ==, &lt;, &gt; gibi karşılaştırma işlemlerini yeniden tanımlayarak küme teorisine uyumlu hale getirirler. Söz gelişi A &lt;= B şartı, A kümesi B kümesinin bir alt kümesi ise doğrudur.\n\nAvrupa = {\"Almanya\",\"Fransa\",\"İspanya\",\"Portekiz\",\"Rusya\",\"Türkiye\"}\nAsya = {\"Rusya\",\"Türkiye\",\"Çin\",\"Hindistan\"}\nİberya = {\"İspanya\",\"Portekiz\"}\n\n\nfrom IPython import display\ndisplay.Image(\"img/Venn_ulkeler.png\",width=300)\n\n\n\n\nEşitlik (==) ve eşitdeğil (!=) işlemleri iki kümenin eşit olup olmadığını test eder.\n\nAvrupa == Avrupa, Avrupa != Asya\n\n(True, True)\n\n\nAlt küme testi için &lt;= işlemi, öz alt küme testi için &lt; işlemi kullanılabilir.\n\nİberya &lt; Avrupa, Asya &lt; Asya, Asya &lt;= Asya\n\n(True, False, True)\n\n\nKapsama işlemi için &gt; ve &gt;= işlemleri kullanılır.\n\nAvrupa &gt; İberya, Asya &gt; Asya, Asya &gt;= Asya\n\n(True, False, True)"
  },
  {
    "objectID": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#bileşim-kesişim-fark-simetrik-fark",
    "href": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#bileşim-kesişim-fark-simetrik-fark",
    "title": "Python Programlamaya Giriş 17 - Küme metodları",
    "section": "Bileşim, kesişim, fark, simetrik fark",
    "text": "Bileşim, kesişim, fark, simetrik fark\nİki kümenin bileşim kümesini | işlemi ile elde ederiz.\n\nAvrupa | Asya\n\n{'Almanya',\n 'Fransa',\n 'Hindistan',\n 'Portekiz',\n 'Rusya',\n 'Türkiye',\n 'Çin',\n 'İspanya'}\n\n\nKümelerin kesişim kümesi ise & işlemi ile elde edilir.\n\nAvrupa & Asya\n\n{'Rusya', 'Türkiye'}\n\n\nFark işlemi A-B, A kümesinde olup B kümesinde olmayanları verir.\n\nAvrupa - İberya\n\n{'Almanya', 'Fransa', 'Rusya', 'Türkiye'}\n\n\nSimetrik fark A^B işlemi, ya A kümesinde ya da B kümesinde olan, ama ikisinde birden olmayan elemanları verir. Bu işlem A^B == (A|B) - (A&B) eşitliğini sağlar.\n\nAvrupa ^ Asya\n\n{'Almanya', 'Fransa', 'Hindistan', 'Portekiz', 'Çin', 'İspanya'}"
  },
  {
    "objectID": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#donuk-kümeler",
    "href": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#donuk-kümeler",
    "title": "Python Programlamaya Giriş 17 - Küme metodları",
    "section": "Donuk kümeler",
    "text": "Donuk kümeler\nPython, kümelere alternatif olarak bir de donuk küme (frozen set) nesnesi sunar. İkisi arasındaki tek fark, donuk kümelerin bir kere tanımlandıktan sonra değiştirilemez (immutable) olmasıdır. Yani donuk kümeye eleman eklenip çıkarılamaz, kümede değişiklik yapılamaz. Değiştirilemezlik sayesinde donuk kümeler hashable nesnelerdir. Böylece sözlüklerde anahtar olarak kullanılabilirler, veya küme elemanı olabilirler.\n\ns = frozenset((1,2,\"abc\",frozenset(\"abc\")))\ns\n\nfrozenset({frozenset({'a', 'b', 'c'}), 1, 2, 'abc'})\n\n\nBuraya kadar gösterdiğimiz bütün işlemler, karşılaştırmalar, bileşim, kesişim ve fark işlemleri donuk kümelerde de aynen kullanılabilir. Ancak buradan sonra anlatılacak işlemler kümelerde değişiklik yapmak için kullanıldığından, sadece normal (donuk olmayan) kümeler için geçerlidirler."
  },
  {
    "objectID": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#kümelere-eleman-ekleme-ve-çıkarma",
    "href": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#kümelere-eleman-ekleme-ve-çıkarma",
    "title": "Python Programlamaya Giriş 17 - Küme metodları",
    "section": "Kümelere eleman ekleme ve çıkarma",
    "text": "Kümelere eleman ekleme ve çıkarma\nBir kümeye tek tek eleman eklemek için add() metodunu kullanırız.\n\ns = set()\n\ns.add(1)\ns.add(\"abc\")\ns.add(2)\ns.add(1)\n\ns\n\n{1, 'abc', 2}\n\n\nMevcut bir elemanı kümeden silmek için ise remove() metodu kullanılabilir.\n\ns.remove(2)\ns\n\n{1, 'abc'}\n\n\nAncak, belirtilen eleman kümede yoksa, remove() çağrısı bir KeyError hatası verir.\n\ns.remove(2)\n\nKeyError: 2\n\n\nBu hata mesajını yakalayıp ona göre bir işlem yapmanız gereken durumlar olabilir. Eğer böyle bir niyetiniz yoksa discard() metodunu kullanabilirsiniz. Bu işlem de bir elemanı kümeden kaldırır, ama kümede o eleman mevcut değilse hata mesajı vermez.\n\ns.discard(2)\n\nBir kümedeki bütün elemanları silmek için clear() metodunu kullanırız.\n\ns.clear()\ns\n\nset()\n\n\nBir kümeden herhangi bir elemanı döndüren ve o elemanı kümeden çıkaran bir işlem için pop() metodu kullanılabilir. Kümede eleman kalmadıysa, pop() metodu KeyError hatası verir.\n\ns = {1,\"abc\",(1,2,3)}\ns.pop(), s.pop(), s.pop()\n\n(1, 'abc', (1, 2, 3))\n\n\n\ns.pop()\n\nKeyError: 'pop from an empty set'"
  },
  {
    "objectID": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#küme-güncelleme-işlemleri",
    "href": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#küme-güncelleme-işlemleri",
    "title": "Python Programlamaya Giriş 17 - Küme metodları",
    "section": "Küme güncelleme işlemleri",
    "text": "Küme güncelleme işlemleri\nSayılarda ve listelerde +=, *= gibi güncelleme işlemleri olduğunu görmüştük. Kümelerde de, yukarıda gördüğümüz bileşim, kesişim, fark, simetrik fark işlemlerini |=, &=, -=, ^= yapılarıyla güncelleme işlemi haline getirmek mümkün.\nKesişim kümesi boş olmayan iki küme üretelim:\n\ns1 = set(range(5))\ns2 = set(range(2,7))\ns1, s2\n\n({0, 1, 2, 3, 4}, {2, 3, 4, 5, 6})\n\n\nŞimdi s1 kümesini s1 ve s2’nin bileşim kümesi olacak şekilde güncelleyelim:\n\ns1 |= s2  # s1 = s1 | s2 ile aynı\ns1,s2\n\n({0, 1, 2, 3, 4, 5, 6}, {2, 3, 4, 5, 6})\n\n\ns1’i eski haline getirip, s1 ile s2’nin kesişim kümeleri olacak şekilde güncelleyelim:\n\ns1 = set(range(5))\ns1 &= s2  # s1 = s1 & s2 ile aynı\ns1\n\n{2, 3, 4}\n\n\nAynısını fark ve simetrik fark işlemleriyle yapalım:\n\ns1 = set(range(5))\ns1 -= s2  # s1 = s1 - s2 ile aynı\ns1\n\n{0, 1}\n\n\n\ns1 = set(range(5))\ns1 ^= s2   # s1 = s1 ^ s2 ile aynı\ns1\n\n{0, 1, 5, 6}"
  },
  {
    "objectID": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#uygulamalar",
    "href": "posts/2018/03/09/python-programlamaya-giris-17-kume-metodlari/index.html#uygulamalar",
    "title": "Python Programlamaya Giriş 17 - Küme metodları",
    "section": "Uygulamalar",
    "text": "Uygulamalar\n\nMükerrer elemanları kaldırmak\nBir listeyi kümeye çevirmek mükerrer elemanların atılmasını sağlar. Tekil elemanların listesini bulmak için bu özelliği kullanabiliriz.\n\nL = [1,2,3,4,1,2,3,4,1,3,2,1,4,1,2,1,3,1]\nlist(set(L))\n\n[1, 2, 3, 4]\n\n\nElbette aynı yöntemi çokuzlar ve dizelerle de uygulayabiliriz.\n\ndize = \"korkma sönmez bu şafaklarda yüzen al sancak\"\n\"\".join(sorted(set(dize)))\n\n' abcdefklmnorsuyzöüş'\n\n\n\nElemanın varlığını test etmek\n\nBir kümede belli bir elemanın mevcudiyetini test etmek, listede test etmekten çok daha hızlıdır. Bunun sebebi, bir eleman aranırken listenin baştan sona taranmasıdır. Bu yüzden, liste uzadıkça listede bir elemanın varlığının tespiti için gereken zaman artar. Kümelerde ise hash fonksiyonu kullanarak bir tek işlemde test yapılabilir; işlem kümedeki eleman sayısına bağlı değildir.\nBu hız farkını görmek için 1-1.000.000 arasındaki sayılardan oluşan bir liste ve bir küme oluşturalım. Mükerrer eleman olmadığı için ikisi de aynı uzunlukta olacak.\n\nL = list(range(1,1000001))\ns = set(L)\n\n\nfrom random import randint\n\n1 ile 2.000.000 arasında rastgele bir sayı seçelim ve sayının listede ve kümede varlığını test edelim. Yüzde elli ihtimalle sayı mevcut olmayacak. %%timeit hücre sihri ile bu işlemi defalarca tekrarlayıp ortalama süresini bulalım.\n\n%%timeit\nn = randint(1,2000000)\nn in L\n\n13.4 ms ± 1.08 ms per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\n%%timeit\nn = randint(1,2000000)\nn in s\n\n2.08 µs ± 68.5 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\n\nKüme içinde aramanın listede aramaya göre bin kat daha hızlı olduğunu görebiliyoruz.\nŞimdi aynı işlemi bir sözlük ile yapalım. Anahtar değerleri 1-1.000.000 arasında olan büyük bir sözlük yaratalım ve yine rastgele seçilmiş anahtar değerlerini sorgulayalım.\n\nD = dict.fromkeys(L)\n\n\n%%timeit\nn = randint(1,2000000)\nn in D\n\n2.71 µs ± 247 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\n\nSözlüklerde eleman tespiti kümelerdeki kadar hızlıdır, çünkü sözlüklerde de anahtarlar hash fonksiyonlarıyla aranır. Bütün sözlük elemanlarını taramak gerekmez. Yaptığımız zaman ölçümü de bunu gösteriyor."
  },
  {
    "objectID": "posts/2018/03/01/pandasa-giris-seriler/index.html",
    "href": "posts/2018/03/01/pandasa-giris-seriler/index.html",
    "title": "pandas’a Giriş - Seriler",
    "section": "",
    "text": "Pandas veri analitiği alanında, özellikle veri işleme ve analizi için sıklıkla kullanılan bir Python paketi. Pandas paketi seri (Series) ve veri çerçevesi (DataFrame) isimli iki veri yapısının üzerine kurulmuş. Bunlardan serileri tek boyutlu diziler, veri çerçevelerini ise iki boyutlu matrisler (ya da her kolonu bir seriden oluşan yapı) gibi düşünebiliriz. Ancak Pandas paketi liste ve matrislerden farklı işlevler sunuyor. Örnek olarak SQL tablolarında kullanılan tablo birleştirme (join) gibi işlemleri de Pandas sayesinde yapmak mümkün.\nPandas paketiyle yapabileceğimiz temel işlemleri aşağıda bulabilirsiniz:\n\nVeriyi çeşitli formatlardaki dosyalardan okutmak ve dosyalara yazdırmak mümkün. Pandas, metin ve Excel dosyalarının yanında, Stata ve SAS gibi yazılımların formatlarını da destekliyor.\nEksik değerleri doldurmak/çıkarmak için yöntemler içeriyor.\nÇeşitli veri çerçevelerini birleştirmek (SQL dilindeki JOIN ve MERGE işlemleri) mümkün.\nFarklı türlerde grafikler çizdirebiliriz.\nGroupby fonksiyonu sayesinde veriyi gruplara bölerek, yapacağımız işlemlerle (toplama, sayma, ortalama alma gibi) özetleyebiliriz. Groupby konusunda yazdığımız detaylı bir yazıya linkten erişebilirsiniz.\n\nPandas ile ilgili yazı serisinin ilk bölümünde seri veri yapısını inceleyeceğiz. Burada kullandığımız yöntemlerin çoğu veri çerçeveleri için de geçerli olacaktır. Pandas serilerine giriş amacıyla IMF’nin gayrisafi yurt içi hasıla verisini kullanacağız. Detaylı veri setine linkten erişebilirsiniz. Ben küçük bir örneklemle çalıştığım için veriyi okutmayla ilgili kısımlara, veri çerçeveleriyle ilgili yazıda değineceğim.\n\nSeriler\nSeri, etiketli verilerden oluşan tek boyutlu bir veri yapısıdır. Etiket değerlerine indeks denir. Verinin kendisi sayılar, dizeler ya da başka Python objelerinden oluşabilir. Serileri oluşturmak için listeler, sıralı diziler ya da sözlükler kullanılabilir. 10 ülkenin 2017 yılının GSYİH değerlerinden oluşan bir seri oluşturalım. Dikkat etmemiz gereken nokta indeks ve verinin aynı boyutta olması. Bunu sağlayamazsak hata mesajı alacağız.\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\n\n#Pandas paketini yükleyelim\nimport pandas as pd \nimport numpy as np\n\n#GSYİH değeri en yüksek olan 10 ülkenin değerlerini kullanacağız.\ngdp_data_2017 = [19362.13, 11937.56, 4884.49, 3651.87, 2574.81, 2565.05, 2439.01, 2080.92, 1921.14, 1640.39]\n\n#Seriyi oluşturalım. İndeks değerini vermediğimizde, Pandas 0'dan başlayarak veriyi indeksler.\ngdp_2017 = pd.Series(gdp_data_2017)\nprint(gdp_2017)\n\n0    19362.13\n1    11937.56\n2     4884.49\n3     3651.87\n4     2574.81\n5     2565.05\n6     2439.01\n7     2080.92\n8     1921.14\n9     1640.39\ndtype: float64\n\n\nİndeks değeri vermediğimizde seri pek anlamlı durmuyor. İndeks değerlerini bir liste olarak sonradan atayabilir ya da seriyi oluştururken belirtebiliriz.\n\n# İndeks değerlerini içeren listeyi oluşturalım.\ngdp_index_2017 = ['ABD', 'Çin', 'Japonya', 'Almanya', 'Fransa', 'Birleşik Krallık', 'Hindistan', 'Brezilya', 'İtalya', 'Kanada']\n\n# Serinin indeks değerini oluşturduğumuz listeye eşitleyelim.\ngdp_2017.index = gdp_index_2017\nprint(gdp_2017)\n\n# Seriyi oluştururken indeks değerlerini belirtmek için aşağıdaki satırı kullanabiliriz.\n#gdp_2017 = pd.Series(gdp_data_2017, index = gdp_index_2017)\n\nABD                 19362.13\nÇin                 11937.56\nJaponya              4884.49\nAlmanya              3651.87\nFransa               2574.81\nBirleşik Krallık     2565.05\nHindistan            2439.01\nBrezilya             2080.92\nİtalya               1921.14\nKanada               1640.39\ndtype: float64\n\n\n2016 yılı için de aşağıdaki gibi sözlük veri yapısını kullanarak bir seri oluşturalım. Bu sefer seriyi oluşturmak için bir sözlük kullanacağız.\n\nd = {'ABD':18624.45,\n'Çin':11232.11,\n'Japonya':4936.54,\n'Almanya':3479.23,\n'Fransa':2466.47,\n'Birleşik Krallık':2629.19,\n'Hindistan':2263.79,\n'Brezilya':1798.62,\n'İtalya':1850.74,\n'Kanada':1529.76}\n\ngdp_2016 = pd.Series(d)\n\nprint(gdp_2016)\n\nABD                 18624.45\nAlmanya              3479.23\nBirleşik Krallık     2629.19\nBrezilya             1798.62\nFransa               2466.47\nHindistan            2263.79\nJaponya              4936.54\nKanada               1529.76\nÇin                 11232.11\nİtalya               1850.74\ndtype: float64\n\n\nSözlük yapısıyla girdiğimiz verilerin sırasının değiştiğini, alfabetik olarak sıralandığını görüyoruz. Pandas indeksin değerine göre işlem yaptığı için bunun bir önemi yok.\nVeri kümesini genişletmek istediğimizde iki seçeneğimiz var: * Köşeli parantez ile veriyi girebiliriz. * Oluşturduğumuz ikinci bir seriyi append fonksiyonuyla ilk seriye ekleyebiliriz.\nKöşeli parantezle girdiğimiz veri o indekse sahip bütün girdileri sağladığımız değere eşitler. Eğer o indekse sahip bir değer yoksa seriye yeni bir eleman ekler.\n\n# Kore'nin GSYİH değerini giriyoruz. \n# Seride 'Korea' indeksine sahip bir eleman olmadığı için seriye yeni bir eleman eklenecek.\ngdp_2016['Kore'] = 1411.04\n\nprint(gdp_2016)\n\n#Aşağıdaki satırı eklemiş olsaydık yeni bir gözlem eklemek yerine var olan gözlemi değiştirmiş olacaktık.\n#gdp['China'] = 1411.04 \n\nABD                 18624.45\nAlmanya              3479.23\nBirleşik Krallık     2629.19\nBrezilya             1798.62\nFransa               2466.47\nHindistan            2263.79\nJaponya              4936.54\nKanada               1529.76\nÇin                 11232.11\nİtalya               1850.74\nKore                 1411.04\ndtype: float64\n\n\nappend fonksiyonunu kullandığımızda ise bir seri, diğerinin sonuna eklenir. Burada dikkat etmemiz gereken nokta aynı indekse sahip elemanlar varsa bunların çoğullanacak olmasıdır. Sözlüğün içinde aynı indekse sahip girdiler varsa en sonuncusu alınır. Aşağıdaki örnekte Meksika’nın tek girdisi olmasına rağmen ABD’nin iki girdisi olduğunu görüyoruz.\n\nd1 = {'Rusya' : 1365.865,\n'Avustralya' : 1229.938,\n'İspanya' : 1193.556,\n'Meksika' : np.NaN,\n'Meksika' : 1,\n'Meksika' : 1046.925,\n'ABD' : 0\n}\n\ngdp_2016 = gdp_2016.append(pd.Series(d1))\nprint(gdp_2016)\n\nABD                 18624.450\nAlmanya              3479.230\nBirleşik Krallık     2629.190\nBrezilya             1798.620\nFransa               2466.470\nHindistan            2263.790\nJaponya              4936.540\nKanada               1529.760\nÇin                 11232.110\nİtalya               1850.740\nKore                 1411.040\nABD                     0.000\nAvustralya           1229.938\nMeksika              1046.925\nRusya                1365.865\nİspanya              1193.556\ndtype: float64\n\n\n\n\nTemel Metotlar ve Erişim\nSeriler veri ve indeks değerlerinden oluşur. values ve index metotlarıyla bunlara erişmek mümkündür.\nYazının geri kalanında, kimi çıktılarda kullanılan biçimlendirmeyi (format) öğrenmek için Kaan’ın dize biçimlendirme yazısını inceleyebilirsiniz.\n\nprint('GSYİH değerleri: {}'.format(gdp_2017.values))\nprint('İndeks değerleri: {}'.format(gdp_2017.index))\n\nGSYİH değerleri: [ 19362.13  11937.56   4884.49   3651.87   2574.81   2565.05   2439.01\n   2080.92   1921.14   1640.39]\nİndeks değerleri: Index(['ABD', 'Çin', 'Japonya', 'Almanya', 'Fransa', 'Birleşik Krallık',\n       'Hindistan', 'Brezilya', 'İtalya', 'Kanada'],\n      dtype='object')\n\n\nndim boyutu, shape şekli, size ise serinin uzunluğunu verir.\n\nprint('Boyut: {}'.format(gdp_2017.ndim))\nprint('Şekil: {}'.format(gdp_2017.shape))\nprint('Uzunluk: {}'.format(gdp_2017.size))\n\nBoyut: 1\nŞekil: (10,)\nUzunluk: 10\n\n\nSerideki değerlerin ve indeksin adını da belirtmek mümkün. Bunun için name metodunu kullanabiliriz. İndeksin ülkeler, verinin de GSYİH olduğunu belirtelim.\n\ngdp_2017.name = 'GSYİH'\ngdp_2017.index.name = 'Ülkeler'\nprint(gdp_2017)\n\nÜlkeler\nABD                 19362.13\nÇin                 11937.56\nJaponya              4884.49\nAlmanya              3651.87\nFransa               2574.81\nBirleşik Krallık     2565.05\nHindistan            2439.01\nBrezilya             2080.92\nİtalya               1921.14\nKanada               1640.39\nName: GSYİH, dtype: float64\n\n\nVeriyle ilgili özet bilgiler almak ve serinin içeriğine bakmak için describe ve head fonksiyonlarını kullanabiliriz. head fonksiyonuna sağlayacağınız bir tamsayı, kaç satırlık veriye ulaşacağınızı belirleyecektir (varsayılan değer 5).\n\nprint('Verinin özeti:')\nprint(gdp_2017.describe())\nprint('Serinin ilk beş satırı:')\nprint(gdp_2017.head())\n\nVerinin özeti:\ncount       10.000000\nmean      5305.737000\nstd       5801.849771\nmin       1640.390000\n25%       2170.442500\n50%       2569.930000\n75%       4576.335000\nmax      19362.130000\nName: GSYİH, dtype: float64\nSerinin ilk beş satırı:\nÜlkeler\nABD        19362.13\nÇin        11937.56\nJaponya     4884.49\nAlmanya     3651.87\nFransa      2574.81\nName: GSYİH, dtype: float64\n\n\nErişim için indeksin değerini ya da sırasını verebiliriz. Örnek olarak Çin’in ve 5. sıradaki (indeksi 4 olan) ülkenin GSYİH değerlerine bakalım. Sıra numarasıyla eriştiğimizde indeks değerini ayrıca kontrol etmemiz gerekebilir. Seriyi sözlük kullanarak oluşturduğumuzda girdilerin sırasının değiştiğini hatırlayalım.\n\nprint('gdp_2017[\\'Çin\\']: {}'.format(gdp_2017['Çin']))\nprint('gdp_2017[4]: {}'.format(gdp_2017[4]))\n\ngdp_2017['Çin']: 11937.56\ngdp_2017[4]: 2574.81\n\n\nSıralı nesnelerdeki dilimleme işlemleri Pandas serilerinde de kullanılabilir. Dilimleme için iki seçenek var: indeksin sırası ve kendisi. iloc indeksin sırasıyla, loc indeksin kendisiyle işlem yapmaya olanak verir. loc metotunda ilk eleman da son eleman da dilimlemeye dahil edilir. İlk 3 elemana (iloc) ve Japonya ile İtalya arasındaki elemanlara (loc) erişelim.\n\nprint('gdp_2017.iloc[:3]:\\n{}'.format(gdp_2017.iloc[:3]))\nprint('gdp_2017.loc[\\'Japonya\\':\\'İtalya\\']:\\n{}'.format(gdp_2017.loc['Japonya':'İtalya']))\n\ngdp_2017.iloc[:3]:\nÜlkeler\nABD        19362.13\nÇin        11937.56\nJaponya     4884.49\nName: GSYİH, dtype: float64\ngdp_2017.loc['Japonya':'İtalya']:\nÜlkeler\nJaponya             4884.49\nAlmanya             3651.87\nFransa              2574.81\nBirleşik Krallık    2565.05\nHindistan           2439.01\nBrezilya            2080.92\nİtalya              1921.14\nName: GSYİH, dtype: float64\n\n\ngdp_2016 tablosunda indeksi ABD olan iki girdi var. Şimdi bunlardan birini silelim. ABD’nin GSYİH değerini 18624.450’ye eşitleyerek değerleri drop_duplicate fonksiyonuyla tekilleştirelim.\n\n# Aşağıdaki satır indeksi ABD olan bütün girdileri değiştirir.\ngdp_2016['ABD'] = 18624.450\nprint('Tekilleştirme öncesi')\nprint(gdp_2016)\n# Aşağıdaki satır aynı olan değerleri tekilleştirir. \n# inplace = True sayesinde işlemi serinin kendisi üzerinde yapıyoruz.\ngdp_2016.drop_duplicates(inplace = True)\nprint('Tekilleştirme sonrası')\nprint(gdp_2016)\n\nTekilleştirme öncesi\nABD                 18624.450\nAlmanya              3479.230\nBirleşik Krallık     2629.190\nBrezilya             1798.620\nFransa               2466.470\nHindistan            2263.790\nJaponya              4936.540\nKanada               1529.760\nÇin                 11232.110\nİtalya               1850.740\nKore                 1411.040\nABD                 18624.450\nAvustralya           1229.938\nMeksika              1046.925\nRusya                1365.865\nİspanya              1193.556\ndtype: float64\nTekilleştirme sonrası\nABD                 18624.450\nAlmanya              3479.230\nBirleşik Krallık     2629.190\nBrezilya             1798.620\nFransa               2466.470\nHindistan            2263.790\nJaponya              4936.540\nKanada               1529.760\nÇin                 11232.110\nİtalya               1850.740\nKore                 1411.040\nAvustralya           1229.938\nMeksika              1046.925\nRusya                1365.865\nİspanya              1193.556\ndtype: float64\n\n\nTek bir ülkeyi silmek için drop fonksiyonuna indeks değerini vermemiz yeterli.\n\ngdp_2016.drop('Kanada', inplace = True)\nprint(gdp_2016)\n\nABD                 18624.450\nAlmanya              3479.230\nBirleşik Krallık     2629.190\nBrezilya             1798.620\nFransa               2466.470\nHindistan            2263.790\nJaponya              4936.540\nÇin                 11232.110\nİtalya               1850.740\nKore                 1411.040\nAvustralya           1229.938\nMeksika              1046.925\nRusya                1365.865\nİspanya              1193.556\ndtype: float64\n\n\ndrop fonksiyonuyla birden fazla değer de silebiliriz. Örnek olarak Kore ile İspanya arasındaki bütün değerleri silelim. drop fonksiyonu indeks değerleriyle işlem yaptığı için, Kore ile İspanya arasındaki indeks değerlerini kullanacak.\n\ngdp_2016.drop(gdp_2016.loc['Kore' : 'İspanya'].index, inplace = True)\nprint(gdp_2016)\n\nABD                 18624.45\nAlmanya              3479.23\nBirleşik Krallık     2629.19\nBrezilya             1798.62\nFransa               2466.47\nHindistan            2263.79\nJaponya              4936.54\nÇin                 11232.11\nİtalya               1850.74\ndtype: float64\n\n\n\n\nGrafikler\nPandas, matplotlib paketini kullanarak grafik çizdirmeye de izin veriyor. Bu amaçla plot fonksiyonunu kullanabiliriz. Grafiğin tarzını belirtmek için de kind argümanını kullanabiliriz. Kind argümanı histogram (hist), pasta grafiği (pie) ya da çizgi grafiği (line) gibi temel grafik çeşitlerini destekliyor. İstanbul’un yıl içindeki sıcaklığını (line) ve 2017 yılı için GSYİH dağılımını (pie) görselleştirelim.\n\n\"\"\"\n# Sıcaklık verisini aşağıdaki kodu kullanarak elde ettim. Daha sonra ay isimlerini Türkçeye çevirdim\n# Pandas altındaki okuma ve yazma fonksiyonlarına ileriki yazılarda değineceğiz.\n\ntemp = pd.read_html('http://www.yr.no/place/Turkey/Istanbul/Istanbul/statistics.html', header = 1, index_col=0) \ntemp_ist = pd.Series(temp[1]['Normal'], index= temp[1].index.values)\ntemp_ist = temp_ist.astype(str).str[:-2].astype(np.float)\n\"\"\"\n\ntemp_ist = pd.Series([5.6, 5.9, 7.5, 12., 16.5, 21.1, 23.2, 23., 19.7, 15.3, 11.6, 8.1], \n                     index = ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs','Haziran', \n                              'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık'])\ntemp_ist.name = 'Sıcaklık'\ntemp_ist.index.name = 'Aylar'\nplt.figure(figsize= (10,5))\n# Çizgi grafiği çizdirelim.\ntemp_ist.plot(kind = 'line', xticks=np.arange(0,12), rot = 45)\nplt.ylabel('Derece')\nplt.show()\n\ngdp_2017.name = 'GSYİH'\nplt.figure(figsize= (8,8))\n# Pasta grafiği çizdirelim.\ngdp_2017.plot(kind = 'pie')\nplt.show()\n\n\n\n\n\n\n\n\n\nİşlemler\nSeriler üzerinde dört işlem yapmak mümkündür. Yaptığımız işlemlerde sadece aynı indekse sahip elemanlar bu işlemlerden etkilenir. İşlem yaparken eksik olan gözlemler ya da bir seride bulunmayan gözlemler diğer serilerde olsa bile NaN değerini alır. Bunu engellemek ve eksik olan değerleri doldurmak istiyorsanız işlemlerle ilgili fonksiyonları (add, subtract, divide, multiply) kullanabilirsiniz. fill_value parametresiyle eksik değerleri değiştirmek mümkün. Ancak iki seride de bulunmayan değerler yine NaN değerini alacaktır.\n\nd1 = {'a' : 1, 'b' : 2,'c' : 6, 'f' : np.NaN}\nd2 = {'a' : 4, 'b' : 3.2, 'd' : 7, 'f' : np.NaN}\n\ns1 = pd.Series(d1)\ns2 = pd.Series(d2)\nprint(s1 + s2)\nprint(s1 * s2)\nprint(s1.multiply(s2, fill_value=1))\n\na    5.0\nb    5.2\nc    NaN\nd    NaN\nf    NaN\ndtype: float64\na    4.0\nb    6.4\nc    NaN\nd    NaN\nf    NaN\ndtype: float64\na    4.0\nb    6.4\nc    6.0\nd    7.0\nf    NaN\ndtype: float64\n\n\nAynı indekse sahip birden fazla değer varsa yapılan işlemler o indekse ait bütün değerler üzerinden yapılır. Aşağıdaki örnekte iki seride de a indeksine sahip iki değer var (Birinci seride 1 ve 5, ikinci seride 4 ve 5). Serileri topladığımızda a indeksine ait dört değer görüyoruz.\n\nd1 = {'a' : 1, 'b' : 2,'c' : 6}\nd2 = {'a' : 4, 'b' : 3.2, 'd' : 7}\n\nd3 = {'a' : 5}\ns1 = pd.Series(d1)\ns2 = pd.Series(d2)\ns1 = s1.append(pd.Series(d3))\ns2 = s2.append(pd.Series(d3))\n\nprint(s1 + s2)\n\na     5.0\na     6.0\na     9.0\na    10.0\nb     5.2\nc     NaN\nd     NaN\ndtype: float64\n\n\nPandas altında yapacağınız işlemler indekse bağlı olduğu için indekslerin çoklanması ve bunun sonuçları konusunda dikkat etmeniz gerekli.\n\n\nZaman Serileri\nSerilerin indeks değerlerini zamana çevirerek zaman serilerini elde edebiliriz. Ocak 2017’de her saat başında bir zar atıp bunun değerlerinden oluşan bir zaman serisi oluşturalım. Bunun için 1 Ocak ile 31 Ocak arasındaki saat dilimlerine ihtiyacımız olacak. Saat dilimlerini oluşturmak için date_range fonksiyonunu kullanabiliriz. 31 Ocak 2017 tarihini verirken saati belirtmezsek günün başlangıcını kabul ettiğinden (00:00) saati 23:59 olarak belirtelim. freq argümanı sıklığı (frekansı) belirtir. Sıklığı bir saat olarak belirlediğimiz için ‘H’ değerini kullanıyoruz.\n\n#Her saat için bir indeks oluşturuyoruz.\nts = pd.date_range('1/1/2017', end = '31/1/2017 23:59:00', freq= 'H')\n\n#Bu indekse sahip girdiler için zar atalım.\nzar = pd.Series(np.random.randint(1,7,len(ts)), index= ts )\n\nprint(zar.head())\n\n2017-01-01 00:00:00    3\n2017-01-01 01:00:00    1\n2017-01-01 02:00:00    1\n2017-01-01 03:00:00    5\n2017-01-01 04:00:00    3\nFreq: H, dtype: int32\n\n\nAttığımız ilk 100 zarı çizgi grafiği olarak gösterelim.\n\nplt.figure(figsize = ( 10,5))\nzar.head(100).plot()\nplt.show()\n\n\n\n\nErişim için tarih vererek (indeks değerlerine uygun olacak şekilde), istediğimiz zaman aralığındaki değerleri görebiliriz.\n\n#1 Ocak tarihine ait gözlemler\nprint(zar['2017-01-01'])\n\n#1 Ocak 13:00:00 ile 16:30:00 arasındaki gözlemler\nprint(zar['2017-01-01 13:00:00' : '2017-01-01 16:30:00'])\n\n2017-01-01 00:00:00    3\n2017-01-01 01:00:00    1\n2017-01-01 02:00:00    1\n2017-01-01 03:00:00    5\n2017-01-01 04:00:00    3\n2017-01-01 05:00:00    4\n2017-01-01 06:00:00    1\n2017-01-01 07:00:00    3\n2017-01-01 08:00:00    2\n2017-01-01 09:00:00    5\n2017-01-01 10:00:00    5\n2017-01-01 11:00:00    2\n2017-01-01 12:00:00    6\n2017-01-01 13:00:00    2\n2017-01-01 14:00:00    6\n2017-01-01 15:00:00    1\n2017-01-01 16:00:00    5\n2017-01-01 17:00:00    2\n2017-01-01 18:00:00    6\n2017-01-01 19:00:00    2\n2017-01-01 20:00:00    6\n2017-01-01 21:00:00    5\n2017-01-01 22:00:00    1\n2017-01-01 23:00:00    5\nFreq: H, dtype: int32\n2017-01-01 13:00:00    2\n2017-01-01 14:00:00    6\n2017-01-01 15:00:00    1\n2017-01-01 16:00:00    5\nFreq: H, dtype: int32\n\n\nZaman serilerinin bir avantajı veriyi istediğimiz sıklıkta yeniden şekillendirebilmemiz. Örnek olarak 6 saatlik toplamlara ya da günlük ortalamaya bakabiliriz. İşlemler sonucunda elde edeceğimiz seriler için önceden bahsettiğimiz Pandas fonksiyonlarını kullanabiliriz.\n\n# 6 saatlik toplamlara bakalım.\nzar1 = zar.resample('6H').sum()\nprint(zar1.head())\n\n# Günlük ortalamaya bakalım.\nzar2 = zar.resample('D').mean()\nprint(zar2.head())\n\n# Günlük ortalamaları çizgi grafiği biçiminde çizdirelim.\nplt.figure(figsize=(10,5))\nzar2.plot(kind = 'line')\nplt.show()\nprint('En şanslı olduğumuz gün: {}, zarların ortalaması: {}'.format(zar2.idxmax(), zar2[zar2.idxmax()]))\n\n2017-01-01 00:00:00    17\n2017-01-01 06:00:00    18\n2017-01-01 12:00:00    22\n2017-01-01 18:00:00    25\n2017-01-02 00:00:00    21\nFreq: 6H, dtype: int32\n2017-01-01    3.416667\n2017-01-02    3.291667\n2017-01-03    3.458333\n2017-01-04    3.791667\n2017-01-05    3.291667\nFreq: D, dtype: float64\nEn şanslı olduğumuz gün: 2017-01-14 00:00:00, zarların ortalaması: 4.375\n\n\n\n\n\nBu yazının Jupyter defterine Github dizinimizden ulaşabilirsiniz."
  },
  {
    "objectID": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html",
    "href": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html",
    "title": "Python Programlamaya Giriş 22 - Hata yakalama, try/except",
    "section": "",
    "text": "Hata yakalama (exception handling) beklenmedik durumlarda programınızın bir hata mesajı vermesi ve çalışmayı durdurması yerine, hataya kendi istediğimiz şekilde cevap vermesini sağlamanın bir yoludur. Hata yakalama Python programcılığının önemli bir parçasıdır, kaynak kodunu çok karışık hale getirmeden programınızın güvenilir bir şekilde çalışmasını sağlar.\nDizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut."
  },
  {
    "objectID": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#hatalı-girdiyi-yakalamak",
    "href": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#hatalı-girdiyi-yakalamak",
    "title": "Python Programlamaya Giriş 22 - Hata yakalama, try/except",
    "section": "Hatalı girdiyi yakalamak",
    "text": "Hatalı girdiyi yakalamak\nBir örnekle başlayalım: Etkileşimli çalışarak kullanıcıdan sayılar alan ve aldığı sayıların karesini ekrana basan bir program yazalım. Boş satır okuduğunda program sonlansın.\n\nwhile True:\n    x = input(\"Bir sayı girin: \")\n    if not x:\n        break\n    print(float(x)**2)\n\nÖrnek olarak, programımız şöyle çalışabilir.\nBir sayı girin: 1\n1.0\nBir sayı girin: -45.5\n2070.25\nBir sayı girin: abc\n    ---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-1-297c961843d7&gt; in &lt;module&gt;()\n      3     if not x:\n      4         break\n----&gt; 5     print(float(x)**2)\n\nValueError: could not convert string to float: 'abc'\nSon girdimiz \"abc\" sayıya dönüştürülemediği için float() fonksiyonu bir ValueError hatası (Python terimiyle “exception”) verdi. Böyle hatalar programımızın çalışmasını durdurur. Oysa, bir hata yakalama (exception handling) yapısı kullanırsak bu tür sorunları programımızı durdurmadan halletmemiz mümkün olur. Söz gelişi:\n\nwhile True:\n    x = input(\"Bir sayı girin: \")\n    if not x:\n        break\n    try:\n        y = float(x)\n    except ValueError:\n        print(\"Geçersiz sayı\")\n        continue\n    print(y**2)\n\nBu program hatalı girdi verdiğimizde ekrana bir uyarı yazar ve tekrar girdi alır:\nBir sayı girin: 3\n9.0\nBir sayı girin: -2\n4.0\nBir sayı girin: abc\nGeçersiz sayı\nBir sayı girin: 1.5\n2.25\nBir sayı girin: \nBu programda, hata mesajı çıkarabilecek bölümü try: blokunun içine aldık. Eğer float(x) işlemi valueError hatası verirse except ValueError bloku çalıştırılır, ve kullanıcıya bir uyarı verilerek tekrar döngünün başına dönülür. Bu sayede program durmadan hatayı yakalayıp sorunu gidermiş oluruz."
  },
  {
    "objectID": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#hata-tipleri",
    "href": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#hata-tipleri",
    "title": "Python Programlamaya Giriş 22 - Hata yakalama, try/except",
    "section": "Hata tipleri",
    "text": "Hata tipleri\nYukarıdaki örnekte ValueError hatasını yakaladık, ama başka durumlardaki hata isimlerini nereden bileceğiz?\nÖncelikle, yazdığınız her kod satırında neler olabileceğini düşünün. Hata durumu (exception) yaratan bir çok durum olabilir: Çağırdığınız fonksiyonda bir sayıyı sıfıra bölüyor olmanız mümkün mü? Bir matematiksel fonksiyona verdiğiniz değişken sayısal olmazsa ne olur? Üçüncü elemanını almaya çalıştığınız listede sadece iki eleman varsa? Açmak istediğiniz dosya diskte mevcut değilse?\nBu hata durumlarının ne olduğunu anlamak için komutları çalıştırıp ne tip hata aldığınıza bakabilirsiniz ve sonra buna göre try/except blokları yazabilirsiniz. Yardım belgelerinde de fonksiyonun hangi durumlarda hangi hataları yayınlayacağına dair bilgi mevcuttur.\nÇalışma. Yukarıdaki hata durumlarını yaratan Python kodları yazın ve hangi hataların yayınlandığına bakın. Bu hataları bir try/except yapısı içine koyup uygun bulduğunuz şekilde düzenleyin.\nÇalışma. open() fonksiyonunun yardım belgelerine bakarak hangi durumda hangi hataların yayınlandığını inceleyin.\nPython dilindeki ön tanımlı hataların tam listesini ve hangi durumlarda yayınlandıklarını resmi Python dökümanlarından okuyabilirsiniz."
  },
  {
    "objectID": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#birden-fazla-hata-durumu",
    "href": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#birden-fazla-hata-durumu",
    "title": "Python Programlamaya Giriş 22 - Hata yakalama, try/except",
    "section": "Birden fazla hata durumu",
    "text": "Birden fazla hata durumu\nYukarıdaki örneğimizde, float() fonksiyonuna yanlış parametre vermekle ortaya çıkan ValueError hatasını yakalamıştık. Alternatif olarak şu kodu da kullanabilirdik:\n\nwhile True:\n    x = input(\"Bir sayı girin: \")\n    if not x:\n        break\n    try:\n        y = 1/float(x)\n    except:\n        print(\"Geçersiz sayı\")\n        continue\n    print(y)\n\nBir sayı girin: 0\nGeçersiz sayı\nBir sayı girin: abc\nGeçersiz sayı\nBir sayı girin: 2\n0.5\nBir sayı girin: \nBu değişiklikle try bloku içindeki herhangi bir hata ile except bloku çalıştırılır. Ancak, bu yaklaşımda farklı hataların hepsi aynı except blokuna yönlendirilir. Söz gelişi, yukarıda girdi olarak 0 verdiğimizde de ekrana \"Geçersiz sayı\" yazılır. Oysa bu iki ayrı hata durumunun ayrı şekilde düzenlenmesini isteyebiliriz. O zaman iki farklı except bloku kullanırız:\n\nwhile True:\n    x = input(\"Bir sayı girin: \")\n    if not x:\n        break\n    try:\n        y = 1/float(x)\n    except ValueError:\n        print(\"Geçersiz sayı\")\n        continue\n    except ZeroDivisionError:\n        print(\"Sıfıra bölme\")\n        continue\n    print(y)\n\nBu program farklı hatalar için farklı uyarılar gösterir:\nBir sayı girin: abc\nGeçersiz sayı\nBir sayı girin: 0\nSıfıra bölme\nBir sayı girin: 4\n0.25\nBir sayı girin:"
  },
  {
    "objectID": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#hata-durumu-hiyerarşisi",
    "href": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#hata-durumu-hiyerarşisi",
    "title": "Python Programlamaya Giriş 22 - Hata yakalama, try/except",
    "section": "Hata durumu hiyerarşisi",
    "text": "Hata durumu hiyerarşisi\nHata durumları bir nesne hiyerarşisi içinde tanımlanır. Bunların en geneli BaseException sınıfıdır; diğer daha özelleşmiş hata durumları bunlardan türetilir.\nHata durumları hiyerarşisinin bir bölümü şöyledir (tam bir listeyi Python belgelerinde bulabilirsiniz):\nBaseException\n +-- SystemExit\n +-- KeyboardInterrupt\n +-- Exception\n      +-- StopIteration\n      +-- StopAsyncIteration\n      +-- ArithmeticError\n      |    +-- FloatingPointError\n      |    +-- OverflowError\n      |    +-- ZeroDivisionError\n      +-- ImportError\n      |    +-- ModuleNotFoundError\n      +-- LookupError\n      |    +-- IndexError\n      |    +-- KeyError\n      +-- OSError\n      +-- ValueError\nBu hiyerarşi sebebiyle, alt seviye bir hatayı yayınlayan bir kod, onun üstündeki hataları da yayınlar. Söz gelişi, 1/0 işlemi ZeroDivisionError, ArithmeticError, Exception ve BaseException hatalarının hepsine uyar.\nBir try/except yapısında bir hata durumu belirtmezsek en genel durum olan BaseException yayınlanır.\n\ntry:\n    1/0\nexcept:\n    print(\"Bir hata oldu.\")\n\nBir hata oldu.\n\n\nAma böyle bir kullanım, okunaklı yazılım geliştirme açısından doğru değildir. Eğer try blokumuz genişse ve birden fazla farklı hata olması ihtimali varsa, hepsi birden bu mesajı verir, ve hangi hatanın gerçekleştiğini tespit etmemiz mümkün olmaz.\n\ntry:\n    int(\"abc\")\nexcept:\n    print(\"Bir hata oldu.\")\n\nBir hata oldu.\n\n\nBelirsizliği azaltmak için en iyi yol, hiyerarşide en alt noktadaki (en dar kapsamlı) hata durumunu yakalamak ve ona göre ayrı except blokları içinde sorunu gidermektir.\n\ntry:\n    2.5**1000\nexcept OverflowError:\n    print(\"İşlem çok büyük.\")\nexcept ZeroDivisionError:\n    print(\"Sıfıra bölme.\")\n\nİşlem çok büyük.\n\n\nHatta, yaptığınız işlemin yeni bir hata durumu olmasını da sağlayabilirsiniz. Öntanımlı hata durumlarından yeni hatalar türetmeyi aşağıda göreceğiz."
  },
  {
    "objectID": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#fonksiyonlarımızda-hata-durumu-yayınlamak",
    "href": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#fonksiyonlarımızda-hata-durumu-yayınlamak",
    "title": "Python Programlamaya Giriş 22 - Hata yakalama, try/except",
    "section": "Fonksiyonlarımızda hata durumu yayınlamak",
    "text": "Fonksiyonlarımızda hata durumu yayınlamak\nGördüğümüz gibi birçok Python fonksiyonu normal işleyişe uymayan durumlarda bir hata durumu yayınlıyor, ve programımızda bu hata durumunu yakalayarak işlem yapıyoruz. Kendi yazdığımız fonksiyonların içinde raise komutu kullanarak bir hata durumu yayınlanmasını sağlayabiliriz. Örnek olarak, negatif argüman aldığında ValueError yayınlayan bir faktöriyel fonksiyonu yazalım. Hata mesajını değiştirmemiz de mümkündür:\n\ndef faktöryel(x):\n    x = int(x)    \n    if x&lt;0:\n        raise ValueError(\"Negatif değer\")\n    p = 1\n    for i in range(1,x+1):\n        p *= i\n    return p\n\nŞimdi bu fonksiyonu bir try/except bloku içinde kullanalım.\n\nfor x in [5, -5, \"abc\", 5]:\n    try:\n        y = faktöryel(x)\n    except ValueError as e:\n        print(x,\": \", e)\n        continue\n    print(y)\n\n120\n-5 :  Negatif değer\nabc :  invalid literal for int() with base 10: 'abc'\n120\n\n\nBu koddaki except ValueError as e: komutu ile hata durumu e isimli bir yerel değişkende saklanabilir ve blok içinde kullanılabilir. Yukarıdaki gibi print() içinde kullanıldığında hata mesajını ekrana basarız. Negatif girdi ve harf girdisi durumlarında farklı hata mesajları çıktığına dikkat edin."
  },
  {
    "objectID": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#yeni-hata-durumları-yaratmak",
    "href": "posts/2018/06/25/python-programlamaya-giris-22-hata-yakalama-try-except/index.html#yeni-hata-durumları-yaratmak",
    "title": "Python Programlamaya Giriş 22 - Hata yakalama, try/except",
    "section": "Yeni hata durumları yaratmak",
    "text": "Yeni hata durumları yaratmak\nPython’un standart hata durumlarına ek olarak, kendi hata durumlarımızı da yaratabiliriz. Yukarıda gördüğümüz hata durumu hiyerarşisi, aslında bir nesne hiyerarşisidir. Nesne sınıfları tanımlamayı sonraki bölümlerde göreceğiz, ama buradaki örneği nesne programlama bilmeden de uygulayabilirsiniz.\nYeni bir hata tanımlarken varolan bir hatayı temel alırız. Söz gelişi, genel Exception nesne sınıfından türetilmiş bir VektörBoyuHatası tanımlayalım.\n\nclass VektörBoyuHatası(Exception):\n    pass\n\nBuradaki pass kelimesi etkisiz bir komuttur. Python sözdizimi gereğince doldurulması gereken bir yere herhangi bir kod koymak istemediğimizde kullanırız.\nŞimdi iki sayı listesinin iç çarpımını veren bir fonksiyon yazalım. Listeler aynı uzunlukta değilse iç çarpım tanımlı olmaz; bu durumda VektörBoyuHatası yayınlayalım.\n\ndef iç_çarpım(L1, L2):\n    if len(L1)!=len(L2):\n        raise VektörBoyuHatası(\"Parametreler aynı sayıda elemandan oluşmalı.\")\n    return sum( [a*b for (a,b) in zip(L1,L2)] )\n\n\niç_çarpım([1,2,3], [-1,0,1])\n\n2\n\n\n\niç_çarpım([1,2,3,4], [-1,0,1])\n\nVektörBoyuHatası: Parametreler aynı sayıda elemandan oluşmalı.\n\n\nBu fonksiyonu bir try/except yapısı içinde kullanabiliriz:\n\ntry:\n    iç_çarpım([1,2,3,4], [-1,0,1])\nexcept VektörBoyuHatası as e:\n    print(e)\n\nParametreler aynı sayıda elemandan oluşmalı."
  },
  {
    "objectID": "posts/2018/09/03/bilimsel-programlamaya-kolay-baslangic-2/index.html",
    "href": "posts/2018/09/03/bilimsel-programlamaya-kolay-baslangic-2/index.html",
    "title": "Bilimsel Programlamaya Kolay Başlangıç - 2",
    "section": "",
    "text": "Bilimsel Programlamaya Kolay Başlangıç serisinin ilk yazısında sadece grafikler için matplotlib kütüphanesini kullanarak serbest düşüş problemini modellemiş ve sonuçları grafiklerle görselleştirmiştik. Vesileyle, “fonksiyonları ne zaman nerede kullanmak gerekir” sorusuna da bir başlangıç yapmıştık.\nİlk yazıda Bilimsel Programlama 3 adımdan oluşur dedik, ama aslında birçok problemde dört adımdan bahsetmek mümkün:\n\nHazırlık (Sabitleri başlatma, gerekirse veri yapılarını oluşturma vb.)\nHesaplama\nVeri Analizi (Hesaplama sonuçlarını gerçek veriler ya da başka bir modelle karşılaştırma, diğer bir deyişle Hata ya da Fark Analizi)\nSonuçları Görselleştirme\n\nBu yazıda öncelikle eğik atış problemini çözeceğiz ve sayısal yöntemlerin ne kadar başarılı olduğuna bakacağız. Elimiz değmişken sınıf (class) yapılarının nasıl kullanıldığına dair de basit bir örnek yapmış olacağız.\nEğik atış problemi iki eksende çözülüyor, yatay eksen x ve düşey eksen y.\nİki eksendeki konum değişimi şu şekilde gösterilebilir:\n\\(t\\) anında yatay eksendeki konum: \\(r_x(t) = r_x(0) + v_x(0) t\\)\n\\(t\\) anında düşey eksendeki konum: \\(r_y(t) = r_y(0) + v_y(0) t - \\frac{1}{2} g t^2\\)\nİki eksendeki hız değişimi ise şu şekilde gösterilebilir:\n\\(t\\) anında yatay eksendeki hız: \\(v_x(t) = v_x(0)\\)\n\\(t\\) anında düşey eksendeki hız: \\(v_y(t) = v_y(0) - g t\\)\nParametreler ise şöyle:\n\\(r_x(t), r_y(t) =\\) x ve y ekseninde konum vektörü bileşenleri (\\(m\\))\n\\(v_x(t), v_x(t) =\\) x ve y ekseninde hız vektörü bileşenleri (\\(m/s\\))\n\\(g =\\) yerçekimi sabiti (9.81 \\(m/s^2\\))\n\\(t =\\) zaman (\\(s\\))\nFormüllerin bize anlatmak istediği şey şu:\n\nCisim yatay eksende başlanıç hızında gitmeye devam eder\nCisim düşey eksende başlangıç hızında başlar, hızı yerçekimi ivmesiyle orantılı olarak düşey yönde değişir ve sonuçta düşmeye başlar.\n\n“Bu kadar matematik yeter” diyorsanız, kodlama işine başlayalım o zaman. Öncelikle basit bir vektör sınıfı oluşturalım. Bu sınıf zaman, yatay ve düşey konum ile yatay ve düşey hız bileşenlerinden oluşuyor.\n\nclass zamanKonumHız:\n   'Zaman, 2D konum ve 2D hız değerlerini içeren vektör sınıfı'\n   t = 0\n   rx, ry = 0, 0\n   vx, vy = 0, 0\n\n   def __init__(self, t0, rx0, ry0, vx0, vy0):\n      self.t  = t0\n      self.rx = rx0\n      self.ry = ry0\n      self.vx = vx0\n      self.vy = vy0\n\nBundan sonra belirli bir zamana ait konum ve hız bilgilerimizi bir arada tutmak için bu yapıyı kullanacağız.\nBu sınıfın sadece bir metodu var, o da __init__(). Adından da anlaşılacağı üzere bu sınıfın parametrelerini doldurmak için kullanılıyor. Herhangi bir parametre için varsayılan değer yok, çünkü konum ve hızı içeren bir vektörün başlangıç değerinin ne olduğunu tahmin etmemiz mümkün değil.\nHazırlık kısmına devam edelim. Öncelikle kullanacağımız paketleri ekliyoruz ve yerçekimi sabitini dolduruyoruz. Başlangıç zamanı, bitiş zamanı ve adım büyüklüğünü de burada dolduruyoruz. Tüm bu parametreleri en başta tanımlıyourz ki, sonradan başka değerler kullanmak istersek hepsini derli toplu burada bulabilelim.\nYaptığımız birkaç eğlenceli iş daha var; başlangıç hızının büyüklüğünü ve ilk atış açısını veriyoruz, sonra da pvt0 başlangıç vektörünü bu değerlerle dolduruyoruz. Bu aşamada birimlere dikkat, Python math.sin ve math.cos fonksiyonları derece değil radyan cinsinden parametrelerle çalışıyor. Emin olun dalgınlıkla bunu gözden kaçırmak çok kolay.\nEn son yaptığımız iş ise zamanKonumHız adlı, zaman, konum ve hız bilgisini paketleyen yapılardan oluşan boş bir liste oluşturmak. Her zaman adımında yaptığımız hesaplamalarla oluşturduğumuz bu veri paketlerini buraya istifleyeceğiz.\n\n# sonradan gerekecek kütüphanelerini çağır\nimport matplotlib.pyplot as plt\nimport math\n\n# Kütleçekimi Sabiti [m/s^2]\ngDünya = 9.81\n\n# başlangıç zamanı\nt0 = 0\n# bitiş zamanı (sn)\ntSon = 100\n# adım büyüklüğü (sn)\ntAdım = 0.5\n\n# başlangıç hızı (m/sn) ve atış açısı (derece)\nv0 = 100 \nyükselmeAçısı = 50 \n\n# başlangıç konum ve hız\npvt0 = zamanKonumHız(t0, 0, 0, v0*math.cos(math.radians(yükselmeAçısı)), v0*math.sin(math.radians(yükselmeAçısı)))\n\n# Zaman, yükseklik ve hız bilgilerini içeren vektör listelerini oluştur\npvtList = []\n\nUzun hazırlık evreleri bilimsel programlamacılığın doğasında vardır. Varsayılan değerler, bilimsel sabitler, seçenekler, konfigürasyonlar gibi birçok parametre ve bilgi genellikle ilk adım olarak oluşturulur. Ayrıca gerekli bilgileri tutacak veri yapıları, sınıflar ve o sınıfların alt metodları ya da işlevleri de yine en başta oluşturulur. Bilimsel Programlama işlerinde pek de dile getirilmeyen bir sırrı artık biliyorsunuz: Zamanın önemli bir kısmı bu tür göze gözükmeyen ama mecburi işlerle geçer. Bununla birlikte, bu adımı ne kadar özenli yaparsanız Hesaplama ve sonrasındaki Veri Analizi aşamalarında başınız o kadar az ağrır.\nSonunda Hesaplama adımına ulaşmayı başardık. Bu adım, verilen bir \\(t\\) zamanı için, başlangıç değerlerinden(pvt0) nereye varılacağını hesaplayan bir fonksiyondan ibaret. Fonksiyonun içindeki matematiği yazının başında açıklamıştık zaten - zamana bağlı olarak yatayda ve düşeyde konum ve hız hesaplanıyor. Yeni konum, zaman ve hızdan oluşan bu veri paketi fonksiyon tarafından döndürülüyor, ancak başlangıç değerleri değiştirilmiyor.\n\ndef tAnındaZamanKonumHız(t, pvt0, g=gDünya):\n    \"\"\"Verilen bir t zamanı için yeni konum ve hızı döndürür\"\"\"\n    tYeni  = pvt0.t + t\n    rxYeni = pvt0.rx + pvt0.vx * t\n    ryYeni = pvt0.ry + pvt0.vy * t + (-1/2 * g * t**2)\n    vxYeni = pvt0.vx \n    vyYeni = pvt0.vy + (-g) * t\n    return zamanKonumHız(tYeni, rxYeni, ryYeni, vxYeni, vyYeni)\n\nHesaplama adımında yapmamız gereken tek şey bu fonksiyonu her bir zaman adımı için tekrar tekrar çağırmak. Diğer bir deyişle döngü \\(t \\le t_{Son}\\) olana dek çalışıyor. Ancak ikinci bir kontrol daha var, cismimiz yerin altına düşmesin diye hesaplanan irtifa değeri sıfırın altına inerse de döngüden çıkılıyor.\n\nt = pvt0.t\nh = pvt0.ry \nwhile t&lt;=tSon and h&gt;=0:\n    pvtList.append( tAnındaZamanKonumHız(t, pvt0) )\n    h = pvtList[-1].ry\n    t += tAdım\n\nŞimdilik bir Veri Analizi adımımız yok, bir sonraki örnekte karşımıza çıkacak. Bu nedenle Görselleştirme adımına geçebiliriz. Bu kez zamana karşı değil yatay ve düşey eksenlerdeki konum ve hızı göstereceğiz.\n\n# konum grafiği \nplt.plot( [pvt.rx for pvt in pvtList], [pvt.ry for pvt in pvtList])\n\nplt.title(\"Konum\")\nplt.xlabel(\"x konum (m)\")\nplt.ylabel('y konum (m)')\n\nplt.show()\n\n# hız grafiği\nplt.plot( [pvt.vx for pvt in pvtList], [pvt.vy for pvt in pvtList])\n\nplt.title(\"Hız\")\nplt.xlabel(\"x hız (m/sn)\")\nplt.ylabel('y hız (m/sn)')\n\nplt.show()\n\n\n\n\n\n\n\nKonum grafiği beklediğimiz gibi çıktı, ama hız grafiği biraz tuhaf. Aslında hız grafiğinin bize anlatmaya çalıştığı, yatay hızın hiç değişmediği, düşey hızınsa yaklaşık 80 m/s’den başlayıp -80 m/s civarında sonlandığı.\nİlginç bir nokta daha var: son konum 0’ın altında çıktı. Bunun da sebebi şu; while döngüsü, irtifanın 0’ın altında olduğu bir değer hesaplanıp listeye eklendikten sonra irtifa kontrolünü yapıyor ve döngüden çıkıyor, haliyle 0’ın altında kalan son değer de grafiğe giriyor. İrtifanın tam olarak sıfıra denk geldiği yerde grafiği sonlandırmak isteseydik işler epey karışacaktı, zira bu sefer hangi zamanda irtifanın sıfıra eşit olduğunu bulmak için aradaki değeri tahmin etmemiz (İngilizcesiyle interpolation) ya da benzer başka bir yöntem kullanmamız gerekecekti. Şimdilik yazılımı karmaşıklaştıracak bu işlere girmiyoruz, zira bizi başka konular bekliyor.\nYazının başında Veri Analizi adımından bahsetmiştim, artık buna dair bir örnek yapmanın da zamanı geldi. Sayısal integrasyon ya da sayısal diferansiyel çözümü metodları diye afili isimler verilen, ama aslında “ben tembel adamım, ben çalışacağıma bilgisayar çalışsın” diyenlerin şaşmaz tercihi olan metodların en basitiyle eğik atış problemini çözeceğiz. Sonra da bunu şimdiye dek hesapladığımız “gerçek” değerlerle karşılaştırarak yaptığımız hatayı ölçeceğiz.\nÖncelikle her zaman olduğu gibi işin Hazırlık adımına bakalım. Bu adımda yapılan işler artık tanıdık, ama ufak bir ek yaptık ve konumBüyüklüğü() ile hızBüyüklüğü() metodlarını ekledik. Sınıf yapılarının iki temel özelliği var: bilgi depolamak ve bu sınıfa ait bir işlevi yerine getirmek. Bizim vektör sınıfı da zaman, konum ve hız gibi bilgileri depoluyor ve artık konum ve hız vektörlerinin büyüklüğünü hesaplama işlevini yerine getiriyor. Bu işlevlere daha sonra ihtiyacımız olacak.\n\nclass zamanKonumHız:\n   'Zaman, 2D konum ve 2D hız değerlerini içeren vektör sınıfı'\n   t = 0\n   rx, ry = 0, 0\n   vx, vy = 0, 0\n\n   def __init__(self, t0, rx0, ry0, vx0, vy0):\n      self.t  = t0\n      self.rx = rx0\n      self.ry = ry0\n      self.vx = vx0\n      self.vy = vy0\n\n      \n   def konumBüyüklüğü(self):\n       \"\"\"Konum vektörünün büyüklüğünü döndürür\"\"\"\n       return math.sqrt(self.rx*self.rx+self.ry*self.ry)\n\n   def hızBüyüklüğü(self):\n       \"\"\"Hız vektörünün büyüklüğünü döndürür\"\"\"\n       return math.sqrt(self.vx*self.vx+self.vy*self.vy)\n\nHazırlık işlerinin kalanı da tanıdık. Ama bu kez hata vektörünü de hazırlayıp başlangıç değerlerini 0 olarak giriyoruz. Gerçek değer ile sayısal metodlarla hesaplanan değer arasındaki farkı her adımda bu yapıya kaydedeceğiz.\nBunun yanı sıra sayısal hesaplama ve gerçek vektörleri taşıyacak yapıların da ilk değerlerini dolduruyoruz. Bunu yapma amacımız, hesaplamanın ilk değerlerini bildiğimiz için hesaplama döngüsüne girmelerini engellemek. Daha sonra döngüyü kurarken bu ilk zaman adımını atlayacağız.\n\n# sonradan gerekecek kütüphanelerini çağır\nimport matplotlib.pyplot as plt\nimport math\n\n# Yerçekimi sabiti [m/s^2]\ngEarth = 9.81\n\n# başlangıç zamanı\nt0 = 0\n# bitiş zamanı (sn)\ntSon = 100 \n# adım büyüklüğü (sn)\ntAdım = 0.5\n\n# başlangıç hızı (m/sn) ve atış açısı (derece)\nv0 = 100 \nyükselmeAçısı = 50 \n\n# başlangıç konum ve hız\npvt0 = zamanKonumHız(t0, 0, 0, v0*math.cos(math.radians(yükselmeAçısı)), v0*math.sin(math.radians(yükselmeAçısı)))\n\n# ilk değerleri doldur\ngerçekPvtList = [pvt0]\nnumPvtList    = [pvt0]\nhataPvtList   = [zamanKonumHız(t0, 0, 0, 0, 0)]\n\nGelelim Hesaplama adımına. Kullanacağımız sayısal integrasyon yöntemi Euler Metodu. Yöntemin detaylarına girmeyeceğim ama eğik atış problemi için yapılan iş özetle şöyle: 1. Başlangıç zamanındaki hız ve ivmenin çok kısa bir süre için sabit olduğunu varsayarak, bir sonraki adım için yeni hızı ve yeni konumu hesapla 2. İlk adımda hesaplanan hız ve ivmenin çok kısa bir süre için sabit olduğunu varsayarak, bir sonraki adım için yeni hızı ve yeni konumu hesapla 3. İkinci adımda hesaplanan hız ve ivmenin çok kısa bir süre için sabit olduğunu varsayarak, bir sonraki adım için yeni hızı ve yeni konumu hesapla 4. …\nElbette ivme bizim problemde sabit, ama sabit olmasaydı (örneğin Dünya’dan çok uzaklaşıyor olsaydık) ivmeyi tekrar tekrar hesaplamamız gerekecekti.\nEğik atış probleminde Euler Metodu’nun bir adımının matematiksel ifadesi ise şöyle:\n\\(t_n\\) anında yatay eksendeki konum: \\(r_x(t_n) = r_x(t_{n-1}) + v_x(t_{n-1}) dt\\)\n\\(t_n\\) anında düşey eksendeki konum: \\(r_y(t_n) = r_y(t_{n-1}) + v_y(t_{n-1}) dt\\)\n\\(t_n\\) anında yatay eksendeki hız: \\(v_x(t_n) = v_x(t_{n-1})\\)\n\\(t_n\\) anında düşey eksendeki hız: \\(v_y(t_n) = v_y(t_{n-1}) + g dt\\)\nYani \\(t_n\\) anındaki konum ve hız, \\(t_{n-1}\\) anındaki konum ve hız ile \\(dt\\) ile ifade edilen adım büyüklüğüne bağlı. Yatay eksende hız değişmiyor, çünkü bunu sağlayacak bir kuvvet ya da ivme yok. Düşey hız ise sabit ivmeye bağlı.\ntAnındaZamanKonumHız() metodu bu yazıda verilen bir önceki örnekle aynı ve bize her hesaplama zamanı için “gerçek” konum ve hız değerlerini veriyor. eulerZamanKonumHız() ise, yukarıda bahsettiğimiz matematiksel modelle yaklaşık değerleri her adım için hesaplıyor.\n\ndef tAnındaZamanKonumHız(t, pvt0, g=gDünya):\n    \"\"\"Verilen bir t zamanı için yeni konum ve hızı döndürür\"\"\"\n    tYeni  = pvt0.t + t\n    rxYeni = pvt0.rx + pvt0.vx * t\n    ryYeni = pvt0.ry + pvt0.vy * t + (-1/2 * g * t**2)\n    vxYeni = pvt0.vx \n    vyYeni = pvt0.vy + (-g) * t\n    return zamanKonumHız(tYeni, rxYeni, ryYeni, vxYeni, vyYeni)\n\ndef eulerZamanKonumHız(dt, pvt, g=gDünya):\n    \"\"\"Verilen bir dt adım büyüklüğü için yeni konum ve hızı döndürür\"\"\"\n    tYeni  = pvt.t  + dt\n    rxYeni = pvt.rx + pvt.vx * dt\n    ryYeni = pvt.ry + pvt.vy * dt \n    vxYeni = pvt.vx + 0 * dt\n    vyYeni = pvt.vy + (-g) * dt\n    return zamanKonumHız(tYeni, rxYeni, ryYeni, vxYeni, vyYeni)\n\nHesaplama mekanizmamızı da kurduk, artık hesaplama döngüsüne geçelim. İlk iş, irtifayı gerçek listenin ilk adımına ayarlamak oldu. İlk zaman adımını başta doldurduğumuz için döngüde hesaplanacak hedef zaman adımını da adım büyüklüğü kadar ilerlettik. Sonra da döngüye girdik. Döngüde önce gerçek zaman, konum hız vektörünü, sonra sayısal hesaplamayı, en sonda da bu ikisinin farkına karşılık gelen hata vektörünü doldurduk. Hazırlık adımını detaylı bir şekilde yaptığımız için döngü bu kadar basit oldu.\n\n# Döngüyü çalıştır\nt = gerçekPvtList[0].t + tAdım\nh = gerçekPvtList[0].ry \nwhile t&lt;=tSon and h&gt;=0:\n    pvtGerçek = tAnındaZamanKonumHız(t, pvt0)\n    gerçekPvtList.append( pvtGerçek )\n    \n    pvtNum = eulerZamanKonumHız(tAdım, numPvtList[-1])\n    numPvtList.append( pvtNum )\n    \n    hataPvt = zamanKonumHız(t, pvtNum.rx-pvtGerçek.rx, pvtNum.ry-pvtGerçek.ry, pvtNum.vx-pvtGerçek.vx, pvtNum.vy-pvtGerçek.vy)\n    hataPvtList.append(hataPvt)\n    \n    h = gerçekPvtList[-1].ry\n    t += tAdım\n\nO halde sonuçları görelim. Bu kez aynı grafiğe hem gerçek hem de sayısal yöntemlerle hesaplanan yaklaşık konum ve hızı basacağız. Sonra da hata grafiklerini çizdireceğiz. Grafik başlıklarına ve veri etiketlerine adım büyüklüğünü yazdırıyoruz ki sonradan bu grafiklere baktığımızda hatırlayabilelim.\n\n# konum grafiği \nplt.plot( [pvt.rx for pvt in gerçekPvtList], [pvt.ry for pvt in gerçekPvtList], label=\"gerçek\")\nplt.plot( [pvt.rx for pvt in numPvtList], [pvt.ry for pvt in numPvtList], label=\"Euler (\" + str(tAdım) + \" s)\")\n\nplt.title(r\"Konum\")\nplt.xlabel(\"x konum (m)\")\nplt.ylabel('y konum (m)')\nplt.legend(loc=3)\n\nplt.show()\n\n# hiz grafiği\nplt.plot( [pvt.vx for pvt in gerçekPvtList], [pvt.vy for pvt in gerçekPvtList], label=\"gerçek\")\nplt.plot( [pvt.vx for pvt in numPvtList], [pvt.vy for pvt in numPvtList], label=\"Euler (\" + str(tAdım) + \" s)\")\n\nplt.title(r\"Hız\")\nplt.xlabel(\"x hız (m/s)\")\nplt.ylabel('y hız (m/s)')\nplt.legend(loc=3)\n\nplt.show()\n\n# hata grafikleri \nplt.subplot(211)\nplt.plot( [pvt.t for pvt in hataPvtList], [pvt.konumBüyüklüğü() for pvt in hataPvtList])\n\nplt.title(r\"Konum ve Hız Hatası Değişimi (\" + str(tAdım) + \" s)\")\nplt.xlabel(\"zaman (s)\")\nplt.ylabel('konum hatası (m)')\n\nplt.subplot(212)\nplt.plot( [pvt.t for pvt in hataPvtList], [pvt.hızBüyüklüğü() for pvt in hataPvtList])\n\n# plt.title(r\"Hız Değişimi ($ v = gt $)\")\nplt.xlabel(\"zaman (s)\")\nplt.ylabel('hız hatası (m/s)')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\nHiç fena değil, değil mi? Konum değerlerinde gerçek değerden ne kadar saptığımızı görüyoruz. Hız grafiğinde ise pek bir fark göremiyoruz. Hata analizi için özel olarak ürettiğimiz grafiklere bakarak daha fazla bilgi edinebiliriz elbette. Buna göre konum hatası lineer olarak artıyor ve 16 saniyede 40 metreye ulaşıyor. E zaten 1000 m yol gitmiştik, pek iyi bir performans gösterdiğimiz söylenemez; hatamız %4 nispetinde. Oysa hız konusunda gayet iyiyiz, altı üstü 0.00000000000002 m/s hata yapmışız - grafikte y eksenindeki değerlerin üstündeki “1e-14” ifadesine dikkat.\nKonum ve hızdaki bu kadar farklı hata davranışının sebebi gerçek dinamiğin matematiğinde ve Euler Metodu’nda gizli. Konum değişimi zamanın karesiyle orantılı, hız değişimi ise zamanla doğru orantılı. Euler Metodu lineer sistemleri hatasız olarak modelleyebilirken, lineer olmayan sistemleri hatalı bir şekilde modelleyebiliyor. “Madem lineer sistemler hatasız, hızda niye küçük de olsa bir hata var?” diye soranlar olabilir. Soruyu Orhan Gencebay’dan ilhamla, “hatasız makine olmaz” diye yanıtlayabiliriz; bilgisayarlar çalışma prensipleri gereği gerçel bir sayıyı sınırsız uzunlukta depolayamazlar. Yani bir sayıyı defalarca 1.2345678 ile çarpıp bölerseniz neticede başladığınız yere dönmeyi beklersiniz, ama bilgisayarda bunu yaparsanız küçük de olsa bir hata görürsünüz. İnanmayanlar deneyebilir! Bu örnekte gördüğümüz 10-14 seviyesindeki bu hata “kayan nokta” (İng. floating point) hataları için normal kabul edilebilecek bir seviye.\nSayısal metodların doğruluğu genellikle seçilen adım büyüklüğüne bağlıdır. Konum hatasından memnun olmayanlar hesaplamayı 0.1 saniye adım büyüklüğü için tekrar edebilirler. Spoiler vermiş gibi olacağım ama hata 40 metreden 7.5 metreye düşüyor, lakin bilgisayar 5 kat daha fazla sayıda döngü hesaplamak zorunda kalıyor. Çoğumuzun bilgisayarında bu kadar basit bir problem için sorun olmayacaktır, ama eğik atıştan daha karmaşık problemler için bunun bir sorun teşkil edeceğini size garanti edebilirim.\nAdım büyüklüğü küçüldükçe modeldeki hata azalır, ama daha fazla sayıda işlem yapıldığı için yukarıda kayan nokta meselesinde birazcık bahsettiğimiz, bilgisayarın hesaplama hataları diyeceğimiz hatalar artar. Nitekim 0.1 saniye adım büyüklüğünde hız hatası 10-13 seviyesine yükseliyor.\nBu örneğimizde de saf Python kullandık, hala numpy gibi daha eğlenceli ve yetenekli yapılara giremedik; bir sonraki aşama için sözüm olsun. En azından, hem eğik atış problemini karmaşıklaştırıp sayısal metodlara giriş yaptık, hem de sınıf yapılarına değindik.\nBu yazıyı çalıştırılabilir bir Jupyter defteri halinde, yazıdaki iki örneğin kodlarıyla birlikte GitHub sayfamızda bulabilirsiniz."
  },
  {
    "objectID": "posts/2018/01/19/python-programlamaya-giris-isimsiz-fonksiyonlar/index.html",
    "href": "posts/2018/01/19/python-programlamaya-giris-isimsiz-fonksiyonlar/index.html",
    "title": "Python Programlamaya Giriş 11 - İsimsiz Fonksiyonlar",
    "section": "",
    "text": "Python Programlamaya Giriş yazı dizimizde Python fonksiyonlarının nasıl tanımlandığını, parametre eşleştirmenin ve varsayılan parametrelerin nasıl işlediğini gördük, çeşitli örnekler ve alıştırmalar işledik. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\nFonksiyonların her zaman def komutuyla tanımlanması gerekmez. Başka bir yol, lambda komutunu kullanarak isimsiz (“anonymous” - belli bir isme bağlı olmayan) fonksiyonlar yaratmaktır. İsimsiz fonksiyonlar, def komutuyla üretilen fonksiyonlara göre daha kısıtlıdırlar. Buna karşılık, bir fonksiyon nesnesi gereken yerlerde bazı kolaylıklar sağlarlar.\nFonksiyonların lambda komutuyla üretilmesine basit bir örnek olarak, aşağıdaki ifadeyi ele alalım. Burada, aldığı parametrenin karesini döndüren bir fonksiyon yaratıyoruz ve buna f ismini atıyoruz.\n\nf = lambda x: x*x\n\nBundan sonra f alıştığımız şekilde bir fonksiyon olarak kullanılabilir.\n\nf(1.2), f(4), f(f(4))\n\n(1.44, 16, 256)\n\n\nNitekim aynı f fonksiyonunu def ile de tanımlayabilirdik.\n\ndef f(x): return x*x\n\n\nf(1.2), f(4), f(f(4))\n\n(1.44, 16, 256)\n\n\nPython dinamik bir dildir. Bunun anlamı, verdiğimiz komutların anında işlenmesi, ve gerekli nesnelerin bellekte o anda yaratılıyor olmasıdır. Python’daki her şey gibi fonksiyonlar da (yazılım geliştirmedeki anlamıyla) birer nesnedir. Yukarıdaki lambda x: x*x ifadesi bellekte bir fonksiyon nesnesi yaratır, ve bu nesne ile f ismi birbirine bağlanır. Öz olarak bunun s = \"merhaba\" komutundan farkı yok; burada da önce bellekte \"merhaba\" değerini tutan bir dize nesnesi yaratılır, sonra bu nesne s ismi ile eşleştirilir.\nElbette lambda ile yaratılan fonksiyon nesnesi tek başına da kullanılabilir.\n\n(lambda x: x*x)(1.2)\n\n1.44\n\n\nAma böyle bir kullanımda fonksiyon her seferinde baştan oluşturulacağından programın verimi azalır.\nİsimsiz fonksiyonlar, def ile tanımladığımız genel amaçlı fonksiyonlardan daha kısıtlıdırlar. Genel amaçlı fonksiyonlarda Python’da tanımlı olan her türlü işlemi kullanabiliriz. İsimsiz fonksiyonlarda ise komut (“statement”) bulunamaz, yani mesela atama yapamayız veya if-else, while, for yapılarını kullanamayız. Sadece bir ifade (“expression”, geriye bir değer veren bir işlem) bulunabilir.\nO zaman isimsiz fonksiyonların faydası ne? Bunlar, özellikle fonksiyon alan fonksiyonlara verilen parametreler olarak kullanışlıdırlar.\nİlk okuyuşta çok egzotik bir kullanım gibi görünebilir ama değil. İsimsiz fonksiyonların kullanılabildiği yerlere birkaç örnek verelim.\nÖrnek: Seriler\nÖnceki bir bölümde fonksiyon alan bir fonksiyon tanımlamıştık. Özel olarak, \\(f\\) reel sayı alıp reel sayı veren herhangi bir fonksiyon olmak üzere, \\(f(a) + f(a+1) + f(a+2) +\\cdots + f(b)\\) toplamını hesaplayan bir fonksiyon yazdık. Bu fonksiyon sadece başlangıç ve bitiş değerleri olan a ve b’yi değil, aynı zamanda f fonksiyonunu da parametre olarak alıyor. Böylece herhangi bir fonksiyon için bu toplamı hesaplayabiliyoruz.\nBu toplamı veren fonksiyonu şöyle tanımlayabiliriz:\n\ndef seritoplam(f, a, b):\n    toplam = 0\n    x = a\n    while x&lt;=b:\n        toplam += f(x)\n        x += 1\n    return toplam\n\nTanımladığımız seritoplam fonksiyonu, matematiksel terimle bir “fonksiyonel”dir, yani fonksiyon alıp sayı veren bir fonksiyon. Bunu kullanarak, \\(\\sum_{x=a}^b 2^{-x}\\) değerini hesaplayalım. Bu toplam için f parametresi olarak \\(2^{-x}\\) olarak tanımlanmış bir fonksiyon verilmeli.\n\ndef g(x): return 2.0**(-x)\n\nseritoplam(g, 0, 10)\n\n1.9990234375\n\n\nAynısını bir isimsiz fonksiyonla şöyle yapabiliriz:\n\nseritoplam( lambda x: 2.0**(-x), 0, 10 )\n\n1.9990234375\n\n\nBurada lambda ifadesini doğrudan doğruya seritoplam’a bir parametre olarak verdiğimize dikkat edin. Bunu doğrudan def ile yapamayız, yani\nseritoplam( def f(x): 2.0**(-x), 0, 10 )\nyazmak hatalıdır, çünkü def yapısı bir fonksiyon nesnesi döndürmez. Buna karşılık lambda bir ifadedir (“expression”); konduğu yerde bir fonksiyon nesnesi yaratır.\nseritoplam fonksiyonunu birçok farklı fonksiyon parametresi vererek denemek istiyor olabilirsiniz. Mesela $ 1+ 1/2 + 1/3 + + 1/10$ toplamını bulalım:\n\nseritoplam( lambda x: 1/x, 1, 10 )\n\n2.9289682539682538\n\n\nElbette deneyeceğiniz her türlü fonksiyonu def ile tanımlayarak da aynı sonuca ulaşabilirsiniz. Ama lambda kullanmak burada daha fazla kolaylık sağlıyor.\nÖrnek: Sıralama\nListelere kısaca değinmiştik. Bir listenin elemanlarını sıralamak için sorted fonksiyonu kullanılabilir. Söz gelişi:\n\nL = [ 6.1, 2.3, -5.6, 8.5, 4.0, -1.2, -3.4, 7.8]\nsorted(L)\n\n[-5.6, -3.4, -1.2, 2.3, 4.0, 6.1, 7.8, 8.5]\n\n\nBazen alışılageldik sırayla değil de, başka bir düzene göre sıralamak isteyebilirsiniz. sorted fonksiyonunun key parametresine bir fonksiyon verirseniz, bu fonksiyon bütün elemanlara tek tek uygulanır ve sıralama bu sonuçlara göre yapılır. Söz gelişi, yukarıdaki listeyi sayıların mutlak değerlerine göre sıralamak için key parametresine abs fonksiyonunu verebilirsiniz.\n\nsorted(L, key=abs)\n\n[-1.2, 2.3, -3.4, 4.0, -5.6, 6.1, 7.8, 8.5]\n\n\nGördüğünüz gibi burada da fonksiyon alan bir fonksiyonumuz var. Aynı sıralamayı bir isimsiz fonksiyonla şöyle elde ederdik.\n\nsorted(L, key=lambda x: x if x&gt;0 else -x)\n\n[-1.2, 2.3, -3.4, 4.0, -5.6, 6.1, 7.8, 8.5]\n\n\nÜçlü if-else yapısını başka bir bölümde daha ayrıntılı işlemiştik.\nBaşka bir örnek olarak, listelerden oluşan bir listeyi sıralamayı ele alalım. key parametresini kullanmadan sorted ilk elemana göre sıralama yapar.\n\nL = [ [1, \"merhaba\"], [6, \"hello\"], [-2, \"guten tag\"] ]\nsorted(L)\n\n[[-2, 'guten tag'], [1, 'merhaba'], [6, 'hello']]\n\n\nEğer ikinci elemana göre sıralama yapmak istiyorsak, key parametresine listenin ikinci elemanını (1 indeksli) veren bir fonksiyon koyarız.\n\nsorted(L, key = lambda i: i[1])\n\n[[-2, 'guten tag'], [6, 'hello'], [1, 'merhaba']]\n\n\nÖrnek: Sayısal integral hesaplama\nBir belirli integral \\(\\int_a^b f(x)\\mathrm{d}x\\) matematiksel olarak bir “fonksiyonel”dir: Bir fonksiyon alır ve bir sayı verir. Bir fonksiyonun integralini alırken de isimsiz fonksiyonlar kullanabiliriz.\nBir belirli integrali sayısal olarak hesaplamanın pek çok yöntemi vardır. Bunlara şimdilik hiç girmeden, SciPy paketi içindeki integral alma modülünü kullanalım ve \\(\\int_{-2}^4 6x^3 - 4x^2\\, \\mathrm{d}x\\) integralini hesaplayalım.\n\nimport scipy.integrate\n\nscipy.integrate.quad(lambda x: 6*x**3 - 4*x**2, -2, 4)\n\n(264.00000000000006, 3.703317987014864e-12)\n\n\nİlk sayı belirli integralin değeri, ikinci sayı ise tahmini hata miktarıdır.\n\nÖrnekler çoğaltılabilir: Bir fonksiyonun optimal noktalarını bulan bir fonksiyon, türev alan bir fonksiyon, veya bir fonksiyonun grafiğini çizen bir fonksiyon, isimsiz fonksiyonlar alarak daha kolay şekilde işlenebilirler. Ayrıca grafik arayüz oluştururken de isimsiz fonksiyonlar kolaylık sağlar.\nİsimsiz fonksiyonların iyi ve kötü taraflarını şöyle özetleyebiliriz:\n\nlambda bir fonksiyon nesnesi döndürür, def ise bir komuttur, bir değer döndürmez. Bu yüzden lambda ile tanımlanan isimsiz fonksiyonları başka ifadelerin içine, söz gelişi atamalara veya fonksiyon parametrelerine yerleştirebiliriz.\nİsimsiz fonksiyonlarla karmaşık işlemler yapılamaz. Kısa, bir seferlik kullan-at fonksiyonlar tanımlamak için daha uygundurlar.\nİsimsiz fonksiyonlarla kodunuz daha okunaklı olabilir. Sıralama vb. işlemlerde def ile farklı fonksiyonlar tanımlamak isim alanının bir sürü tek kullanımlık fonksiyon ismiyle dolmasına sebep olur. Dahası, kaynak kodunuz uzunsa, fonksiyonun tanımlandığı yer ile kullanıldığı yer arasında kalan mesafe yüzünden, kodda ne yapıldığını anlamak için yukarı aşağı kaydırmak gerekebilir. Bu tür küçük işlerde lambda ifadeleri kullanmak, fonksiyonun yapısını açıkça gösterdiği için kodun anlaşılırlığını artırır.\n\nİsimsiz fonksiyonlarda parametre kullanımı kuralları isimli fonksiyonlardakilerle aynıdır. Örneğin birden fazla parametre alabilirler.\n\nf = lambda x, y: x+y\nf(4,5)\n\n9\n\n\n\nf(\"hello\",\"world\")\n\n'helloworld'\n\n\nParametre paketleme / parametre çözme kuralları isimsiz fonksiyonlarda da aynen geçerlidir.\n\ng = lambda *p : sum(p)\ng(0.25, 2, 13)\n\n15.25\n\n\nParametrelere varsayılan değerler atanabilir.\n\nh = lambda x, n=2: x**n  # üst alma. Varsayılan kuvvet 2.\nprint(h(3)) # 3**2\nprint(h(3,5)) # 3**5\n\n9\n243"
  },
  {
    "objectID": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html",
    "href": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html",
    "title": "Python Programlamaya Giriş 7 - Fonksiyonlar",
    "section": "",
    "text": "Python Programlamaya Giriş yazı dizimize Python fonksiyonlarının temelleriyle devam ediyoruz. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\nYazı dizimizin şimdiye kadarki bölümlerinde bir programı inşa etmek için gereken bütün yapı taşlarını gördük. Prosedürel programlama denen paradigma içinde programlar birbiri arkasından işlenir, bir karar verilmesi gerektiğinde program akışı iki yoldan birini seçer, veya bir döngü içindeki bir kod parçası tekrarlanır.\nTeorik olarak, her türlü programı yazmak için bu yapılar yeterli. Ancak, Yogi Berra’nın dediği gibi: Teoride teori ve pratik arasında fark yoktur, ama pratikte vardır.\nKod yazarken işlemleri sık sık farklı yerlerde tekrarlamamız gerekir. Söz gelişi, bir yatırımın belli bir dönem sonunda bileşik faizle ne miktara ulaştığını yazmak için bir döngü yazabiliriz. Bu tür bir işlemi büyük bir program içinde değişik yerlerde (mesela farklı yatırım araçları için) kullanmamız gerekebilir. Programcılar böyle tekrarlanan işler için aynı kodu tekrar tekrar yazmaktansa, bunları bir fonksiyon (prosedür veya yordam olarak da bilinir) olarak paketleyip kullanmayı tercih ederler. Fonksiyon kullanmak sayesinde:\nBu faydalar sadece Python değil, her türlü programlama dili için geçerlidir tabii.\nBir fonksiyon bir kara kutu gibi düşünülebilir: Aldığı parametreler onun girdisi, verdiği (“döndürdüğü”) değer ise çıktısıdır. Fonksiyonlara istediğiniz sayıda parametre verebilirsiniz. Parametre almayan ve/veya geriye bir değer vermeyen fonksiyonlar da olabilir."
  },
  {
    "objectID": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#kütüphane-fonksiyonları-kullanma",
    "href": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#kütüphane-fonksiyonları-kullanma",
    "title": "Python Programlamaya Giriş 7 - Fonksiyonlar",
    "section": "Kütüphane fonksiyonları kullanma",
    "text": "Kütüphane fonksiyonları kullanma\nBir kütüphane belli bir işlev için hazırlanan fonksiyonların topluluğudur. Bir kütüphane matematik fonksiyonlarını toplarken, başka bir kütüphane kelime işleme, bir başkası ağ iletişimi, bir başkası oyun modülleri barındırıyor olabilir. Kütüphaneler bir dilin resmi tanımına dahil olabilir ve kurulumda beraber gelebilir (bu durumda onlara standart kütüphane denir), veya üçüncü kişiler tarafından hazırlanmış olabilir.\nPython dili çok zengin bir standart kütüphaneye sahiptir. Matematik işlemleri, istatistik işlemleri, gün ve saat işlemleri, dosya sıkıştırma, internet protokolleri, HTML, işletim sistemi yönetimi, grafik arayüz oluşturma, ve daha bir çok işlem için gereken hazır fonksiyonlar Python ile birlikte gelir. Bunların dışında yüzlerce başka kütüphane de mevcuttur, istediğinizde bunları sisteminize kurup kullanabilirsiniz. Daha sonraki yazılarda kendi kütüphanelerimizi nasıl oluşturacağımızı da göreceğiz. Bu yazıda sadece matematik fonksiyonları kütüphanesini örnek olarak kullanacağız.\nKütüphaneler diskimize kurulu olarak hazır bekliyor olsalar da, onları kullanmak için önce import komutuyla yorumlayıcıya yüklememiz gerekir.\n\nimport math\nprint( math.sqrt(2) )\nprint( math.sin(math.pi/2) )\n\n1.4142135623730951\n1.0\n\n\nBurada math.sqrt(2) ifadesi bir fonksiyon çağrısıdır. Matematik modülü math içindeki karekök fonksiyonu sqrt çağrılır ve 2 argümanı verilir. Aradaki nokta bir üyelik belirtir; sqrt fonksiyonu math modülünün altındadır. Keza math.sin aynı modülün altındaki sinüs fonksiyonudur, math.pi ise \\(\\pi\\) sayısıdır.\nSiz ayrıca pi veya sqrt isimli değişkenler veya fonksiyonlar tanımlamış olsanız da, onlar ile bu isimler karışmaz; pi ile math.pi farklıdır. Burada math bir isim alanı (namespace) oluşturur; kendi tanımlarını ayrı tutar.\nYükleme sırasında modülün adını değiştirebiliriz. Özellikle uzun isimli modülleri daha kısa isimle kullanmak için bu özellik faydalı olur.\n\nimport math as m\nprint( m.sqrt(2) )\nprint( m.sin(m.pi/2) )\n\n1.4142135623730951\n1.0\n\n\nVeya, modüldeki bütün isimlere ihtiyacınız yoksa, onları mevcut isim alanınıza tek tek belirleyerek alabilirsiniz. İsim değiştirme burada da geçerlidir. Modül içindeki isimleri değiştirerek alabilirsiniz.\n\nfrom math import sqrt, sin\nfrom math import pi as π\nprint( sqrt(2) )\nprint( sin(π/2) )\n\n1.4142135623730951\n1.0\n\n\n(Jupyter defterinin kod hücresinde \\(\\pi\\) yazmak için \\pi yazın ve Tab tuşuna basın.)\nBaşka bir alternatif, modüldeki bütün isimleri mevcut isim alanına yüklemektir.\n\nfrom math import *\ncos(pi), tan(pi/4)\n\n(-1.0, 0.9999999999999999)\n\n\nAncak bu usül Python programcıları tarafından tavsiye edilmez. Bir modül adı kullanmak, ister math ister kısaca m, bir isim alanı yaratır ve isim çatışmalarını engeller. Varsayalım ki pi veya tan değişkenlerini kodunuzda bir yerlerde önceden başka bir anlamda tanımladınız. Modülü import * ile yüklemekle önceki tanımları silersiniz, ve kodunuz biraz karmaşık ise bunu farketmeyebilirsiniz bile. Özellikle büyük modüllerde pek çok değişik isim gizli olabilir ve neyi sildiğinizi farketmeyebilirsiniz bile. En doğrusu, birazcık daha fazla yazmayı göze alıp bir modül ismi kullanmaktır.\nBir modülde tanımlı bütün isimlere dir fonksiyonuyla erişilebilir.\n\nimport math\ndir(math)\n\n['__doc__',\n '__file__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__',\n 'acos',\n 'acosh',\n 'asin',\n 'asinh',\n 'atan',\n 'atan2',\n 'atanh',\n 'ceil',\n 'copysign',\n 'cos',\n 'cosh',\n 'degrees',\n 'e',\n 'erf',\n 'erfc',\n 'exp',\n 'expm1',\n 'fabs',\n 'factorial',\n 'floor',\n 'fmod',\n 'frexp',\n 'fsum',\n 'gamma',\n 'gcd',\n 'hypot',\n 'inf',\n 'isclose',\n 'isfinite',\n 'isinf',\n 'isnan',\n 'ldexp',\n 'lgamma',\n 'log',\n 'log10',\n 'log1p',\n 'log2',\n 'modf',\n 'nan',\n 'pi',\n 'pow',\n 'radians',\n 'sin',\n 'sinh',\n 'sqrt',\n 'tan',\n 'tanh',\n 'tau',\n 'trunc']\n\n\nModüldeki belli bir fonksiyonun nasıl kullanıldığını hatırlamanız gerektiğinde help fonksiyonunu kullanabilirsiniz. Bu işlemle, fonksiyonun içine gömülü belgeleme dizesi (docstring) ekrana yazılır. Belgeleme dizelerinin nasıl oluşturulacağını bu yazının sonunda okuyabilirsiniz.\n\nhelp(sin)\n\nHelp on built-in function sin in module math:\n\nsin(...)\n    sin(x)\n    \n    Return the sine of x (measured in radians)."
  },
  {
    "objectID": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#fonksiyon-tanımlama",
    "href": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#fonksiyon-tanımlama",
    "title": "Python Programlamaya Giriş 7 - Fonksiyonlar",
    "section": "Fonksiyon tanımlama",
    "text": "Fonksiyon tanımlama\nŞimdi kendimiz nasıl fonksiyon yaratabileceğimizi görelim. Python’da fonksiyonlar def kelimesiyle tanımlanır. Mesela:\n\ndef f1(x):\n    print(x)\n\nf1(3)\n\n3\n\n\n\nf1(\"merhaba\"), f1(3.0*4.25), f1( (2,37) )\n\nmerhaba\n12.75\n(2, 37)\n\n\n(None, None, None)\n\n\nBu fonksiyon basit bir iş yapıyor, aldığı parametreyi olduğu gibi ekrana basıyor. Herhangi bir nesne alabildiğine dikkat edin. Fonksiyonun geri verdiği bir değer yok. Bu yüzden yukarıdaki komutta çıktı hücresinde (None, None, None) görüyoruz.\nFonksiyonların bir değer geri vermesi istiyorsak return komutunu kullanırız. Bu komut, arkasından gelen ifadenin değerinin, fonksiyonu çağıran programa bildirilmesini sağlar ve fonksiyonun çalışmasını bitirir.\nAşağıdaki fonksiyon aldığı iki parametreye çarpma işlemini uygular ve sonucu geri verir:\n\ndef carp(a,b):\n    return a*b\n\ncarp(2,-7)\n\n-14\n\n\nGeri verilen değeri daha sonraki bir işlemde kullanmak için bir değişkene atayabilirsiniz.\n\ny = carp(2, -7)\ny + 3\n\n-11\n\n\nC, C++, Fortran, Java gibi daha katı dillerden farklı olarak, Python’da fonksiyon tanımlarken, parametrelerin ne tipte (tamsayı, kayan noktalı sayı, dize, liste, vs.) olduğu belirtilmez. Bu özellik sayesinde Python programları farklı veri tipleriyle işlem yapma kolaylığı sağlar. Mesela carp bir dize ile bir tamsayı almaya itiraz etmez. Çarpma işlemini bu iki tiple tanımlandığı gibi yapıp sonucu geri verir.\n\ncarp(\"merhaba\",3)\n\n'merhabamerhabamerhaba'\n\n\nAma bu kolaylığın bir bedeli vardır: Fonksiyonun içinde, kullandığınız veri tipleri ile ilgili işlemlerin uyumlu olması gereklidir. Sözgelişi, iki dizeyi “çarpmak” bir hata mesajına yol açar, çünkü dizeler arasında * işlemi tanımlı değildir.\n\ncarp(\"merhaba\",\"dunya\")\n\nTypeError: can't multiply sequence by non-int of type 'str'\n\n\nBöyle hatalardan kaçınmak için birkaç yol vardır. Bunlardan biri assert komutu ile belli şartların sağlanıp sağlanmadığını önceden yoklamak, bir diğer ise fonksiyonun içinde istisna işlemi (“exception handling”) yapmaktır. Böylece belli bir hata (meselâ yukarıdaki gibi TypeError) oluştuğunda, programı durdurmadan akışı düzenlemek mümkün olur. Bu konulara sonraki bölümlerde yer vereceğiz."
  },
  {
    "objectID": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#birkaç-tane-değer-geri-verme",
    "href": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#birkaç-tane-değer-geri-verme",
    "title": "Python Programlamaya Giriş 7 - Fonksiyonlar",
    "section": "Birkaç tane değer geri verme",
    "text": "Birkaç tane değer geri verme\nFonksiyonlar her tipte nesne geri verebilirler. Bir çokuz nesnesi veren bir fonksiyon kullanarak, birden fazla değer çıkarma davranışı taklit edilebilir:\n\ndef f(x, y):\n    return x+y, x-y\n\ntoplam, fark = f(3,5)\nprint(\"Toplam = {}, Fark = {}\".format(toplam,fark))\n\nToplam = 8, Fark = -2"
  },
  {
    "objectID": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#fonksiyon-veren-fonksiyonlar",
    "href": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#fonksiyon-veren-fonksiyonlar",
    "title": "Python Programlamaya Giriş 7 - Fonksiyonlar",
    "section": "Fonksiyon veren fonksiyonlar",
    "text": "Fonksiyon veren fonksiyonlar\nPython dinamik bir dildir: Programın işleyişi sırasında komutlar yeni nesnelerin üretilmesini ve işlenmesini sağlar. Fonksiyonlar da dinamik olarak def komutuyla yaratılır. Buna karşılık, C gibi derlenen diller böyle davranmaz. Bu tür dillerde fonksiyonlar, program henüz çalıştırılmadan, derleme aşamasında yaratılır ve işletilebilir ikili koda gömülür. Python gibi dillerin dinamik yapısı sayesinde, fonksiyonların başka komutlar ve bloklar içinde, mesela sadece bir şart doğru olduğunda tanımlanmasını sağlayabiliriz.\n\ntest = True\nif test:\n    def f1(): print(5)\nelse:\n    def f2(): print(10)\n\n\nf1()\n\n5\n\n\n\nf2()\n\nNameError: name 'f2' is not defined\n\n\nBir fonksiyon tanımlanmasında, önce belirttiğimiz kod parçasını içeren bir fonksiyon nesnesi yaratılır, sonra bu nesne ona verdiğimiz isme bağlanır. Bu anlamda def komutu atama (=) işlemi gibi çalışır. Bunun bir yan faydası, varolan bir fonksiyona başka isimler verebilme imkânıdır.\n\nyenifonk = f1\nyenifonk()\n\n5\n\n\nİki ismin de aynı nesneye işaret ettiğini is komutuyla doğrulayabiliriz.\n\nyenifonk is f1\n\nTrue\n\n\nYine aynı dinamik özellik sayesinde, fonksiyon veren fonksiyonlar (“fonksiyon fabrikaları”) tanımlanabilir.\n\ndef kuvvetfonk(n):\n    def fonk(x):\n        return x**n\n    return fonk\n\nBuradaki kuvvetfonk fonksiyonu, aldığı parametreyi kullanarak yarattığı bir fonksiyon nesnesini verir. Bu fonksiyon nesnesine bir isim atayıp bu isimle çalıştırabiliriz.\n\nkare = kuvvetfonk(2)\nkup = kuvvetfonk(3)\nkare(5), kup(5)\n\n(25, 125)\n\n\nAslında bu fonksiyon nesneleri bir isme atamadan da çağrılabilir, ama her seferinde bu fonksiyonlar baştan yaratılacağı için hesaplama açısından verimsiz olur.\n\nkuvvetfonk(2)(5), kuvvetfonk(3)(5)\n\n(25, 125)"
  },
  {
    "objectID": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#fonksiyon-alan-fonksiyonlar",
    "href": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#fonksiyon-alan-fonksiyonlar",
    "title": "Python Programlamaya Giriş 7 - Fonksiyonlar",
    "section": "Fonksiyon alan fonksiyonlar",
    "text": "Fonksiyon alan fonksiyonlar\nFonksiyonlar, başka fonksiyonları parametre olarak alabilirler. Basit bir örnek olarak, \\(\\sum_{i=a}^{b} f(i)\\) toplamını veren bir fonksiyon yazalım.\n\ndef fntoplam(f, a, b):\n    i = a\n    toplam = 0\n    while i&lt;=b:\n        toplam += f(i)\n        i += 1\n    return toplam\n\ndef f1(x):\n    return 1.0/x\n\ndef f2(x):\n    return 2.0**-x\n\n\nfntoplam(f1, 1, 10)\n\n2.9289682539682538\n\n\n\nfntoplam(f2, 1, 10)\n\n0.9990234375"
  },
  {
    "objectID": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#değiştirilebilir-parametreler",
    "href": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#değiştirilebilir-parametreler",
    "title": "Python Programlamaya Giriş 7 - Fonksiyonlar",
    "section": "Değiştirilebilir parametreler",
    "text": "Değiştirilebilir parametreler\nFonksiyonlara, listeler gibi değiştirilebilir (mutable) parametreler veriyorsanız, ve bunlar fonksiyon içinde değiştiriliyorsa, bu değişiklik kalıcı olur.\n\ndef f(x):\n    x[0] = -10\n    print(x)\n\nx = [1,2,3]\nf(x)\n\n[-10, 2, 3]\n\n\n\nx\n\n[-10, 2, 3]"
  },
  {
    "objectID": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#değişken-ufku-yerel-ve-global-değişkenler",
    "href": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#değişken-ufku-yerel-ve-global-değişkenler",
    "title": "Python Programlamaya Giriş 7 - Fonksiyonlar",
    "section": "Değişken ufku, yerel ve global değişkenler",
    "text": "Değişken ufku, yerel ve global değişkenler\nBir fonksiyon blokunun dışında ve içinde aynı isimde değişkenler kullanırsanız, içeride olanın değeri kullanılır olur. Fonksiyon, dıştaki değişkenin değerini değiştirmez.\n\nx = 10\ndef f():\n    x = 20\n    print(x)\n\nf()\n\n20\n\n\n\nx\n\n10\n\n\nPython bu iki x ismini farklı değişkenler olarak görür. İkinci x bir yerel değişkendir ve sadece f fonksiyonu içinde tanımlıdır. Birincisi ise global görünürlüğe sahiptir; aşağısında tanımlanan bütün fonksiyonlarda kullanılabilir. Yukarıdaki örnekte f fonksiyonu tanımı altında x=20 satırını silersek fonksiyon ekrana global x değeri olan 10’u basacaktır.\nBir seviye daha karmaşık bir örnek olarak, f fonksiyonu içinde başka bir fonksiyon tanımlayalım.\n\nx = 10\nprint(\"x =\",x)\ndef f():\n    x = 20\n    print(\"f içinde x =\",x)\n    def g():\n        x = 30\n        print(\"g içinde x =\", x)\n    g()\nf()\n\nx = 10\nf içinde x = 20\ng içinde x = 30\n\n\nBir değişken ismine atanmış değerin tespit edilmesi için genel kural şöyledir: Önce program akışının bulunduğu blok içinde bir tanım yapılmış mı diye bakılır. Eğer en içteki blokta bir tanım bulunmazsa, onu çevreleyen dış bloka, yoksa onun da dış blokuna bakılır. En dış bloka gelindiğinde global değişkenler içinde olup olmadığına bakılır. En son olarak öntanımlı (“built-in”) isimler kontrol edilir.\nPeki, diyelim ki tam tersini istiyoruz. Yani, bir fonksiyon içinde, fonksiyonun dışında tanımlanmış bir değişkene yeni bir değer atamak istiyoruz. Somut olarak, iki önceki örnekte, fonksiyon çalıştıktan sonra x’in 20 olmasını istiyoruz. Bunu, fonksiyon içinde global komutuyla sağlarız.\n\nx = 10\ndef f():\n    global x\n    x = 20\n\nf()\nprint(\"x =\",x)\n\nx = 20\n\n\nAncak, global değişkenlerden mümkün olduğunca kaçınmak gerekir. Fonksiyonlara giriş bilgisini parametrelerle sağlamak ve çıkış değerini return komutu aracılığıyla almak daha iyidir. Böylece fonksiyonların düzgün bir akış içinde çalışmasını, bileşenlerin birbirine kolayca bağlanan modüler bir yapıda olmasını, “aldığı belli verdiği belli” olmasını sağlarız. Bu şekilde programlar daha okunaklı ve anlaşılır olur. Global değişkenler ise hem giriş hem çıkış kanalı oldukları için bu akışı bozarlar. Globallerin fazla kullanıldığı programları hem okumak zordur, hem de bilgi akışının karışık bir yumak haline gelmesi mümkündür, hata yapma ihtimali artar. Fonksiyonlara veriyi her zaman fonksiyon parametreleriyle vermeye çalışın."
  },
  {
    "objectID": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#belgeleme-dizeleri",
    "href": "posts/2018/01/06/python-programlamaya-giris-fonksiyonlar/index.html#belgeleme-dizeleri",
    "title": "Python Programlamaya Giriş 7 - Fonksiyonlar",
    "section": "Belgeleme dizeleri",
    "text": "Belgeleme dizeleri\nFonksiyon tanımına bir belgeleme dizesi (docstring) eklemek mümkündür. Bir belgeleme dizesi, fonksiyon başlığının hemen altında başlayıp biten bir açıklama metnidir. Normal bir Python dizesinden hiç bir farkı yoktur, ama genellikle üç tırnak (\"\"\") ile sınırlandırılırlar, böylece birkaç satıra yayılabilirler. Fonksiyonun çalışmasını etkilemezler. Birçok Python aracı, sözgelişi etkileşimli help fonksiyonu bu dizeleri otomatik olarak alıp kullanabilir.\n\ndef fntoplam(f, a, b):\n    \"\"\"f(a) + f(a+1) + ... + f(b) toplamını döndürür.\"\"\"\n    i = a\n    toplam = 0\n    while i&lt;=b:\n        toplam += f(i)\n        i += 1\n    return toplam\n\n\nhelp(fntoplam)\n\nHelp on function fntoplam in module __main__:\n\nfntoplam(f, a, b)\n    f(a) + f(a+1) + ... + f(b) toplamını döndürür.\n\n\n\nBütünleşik geliştirme ortamlarında (IDE’lerde) çalışırken, fonksiyonu yazdığınız sırada bu belgeleme dizesine ulaşabilirsiniz. Sözgelişi Jupyter defterinde Shift-Tab basarsanız bir yardım penceresi açılır.\n\n\n\njupyter_online_help.png"
  },
  {
    "objectID": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html",
    "href": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html",
    "title": "Python Programlamaya Giriş 9 - Fonksiyonlara örnekler",
    "section": "",
    "text": "Python Programlamaya Giriş yazı dizimizde Python fonksiyonlarının nasıl tanımlandığını, parametre eşleştirmenin ve varsayılan parametrelerin nasıl işlediğini gördük. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\nÖnceki yazılarda verdiğimiz basit örneklerin ötesine geçip biraz daha elle tutulur fonksiyon örnekleri verelim."
  },
  {
    "objectID": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#asallık-testi",
    "href": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#asallık-testi",
    "title": "Python Programlamaya Giriş 9 - Fonksiyonlara örnekler",
    "section": "Asallık testi",
    "text": "Asallık testi\nDöngülerden bahsederken, bir sayının asal olup olmadığını belirleyen bir program yazmıştık. Şimdi bunu bir fonksiyon haline getirelim. Parametre değeri bir asal sayıysa fonksiyonumuz True verecek, değilse False verecek.\n\ndef asal_mı(x):\n    i = 2\n    while i*i &lt; x:\n        if x % i == 0:\n            return False\n        i += 1\n    else:\n        return True\n\n\nasal_mı(8)\n\nFalse\n\n\n\nasal_mı(79)\n\nTrue"
  },
  {
    "objectID": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#asal-çarpanlar",
    "href": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#asal-çarpanlar",
    "title": "Python Programlamaya Giriş 9 - Fonksiyonlara örnekler",
    "section": "Asal çarpanlar",
    "text": "Asal çarpanlar\nÖnceki bir bölümde bir sayının asal çarpanlarını ekrana basan bir döngü yazmıştık. O döngüyü bir fonksiyon içine koyalım ve verilen sayının asal çarpanları bir liste olarak geri verilsin.\n\ndef asalçarpanlar(N):\n    çarpanlar = []  # boş liste    \n    x = 2\n    while N &gt; 1:\n        # x asal mı?\n        asal = True\n        i = 2\n        while i*i &lt;= x:\n            if x % i == 0:\n                asal = False\n                break\n            i += 1\n\n        if asal and N % x == 0:  # x asalsa ve N'yi bölüyorsa...\n            çarpanlar.append(x)  # x'i listenin sonuna ekle\n            while N % x == 0 :   # N x'e bölünebildiği sürece...\n                N = N / x        # N'yi x'e böl, x çarpanı kalmasın.\n        x += 1\n    return çarpanlar\n\n\nasalçarpanlar(600851475143)\n\n[71, 839, 1471, 6857]\n\n\nBu fonksiyonu, yukarıda tanımladığımız asal_mı() fonksiyonunu kullanarak kısaltabiliriz.\n\ndef asalçarpanlar(N):\n    çarpanlar = []  # boş liste    \n    x = 2\n    while N &gt; 1:\n        if asal_mı(x) and N % x == 0:   # x asalsa ve N'yi bölüyorsa...\n            çarpanlar.append(x)         # x'i listenin sonuna ekle.\n            while N % x == 0 :          # N x'e bölünebildiği sürece...\n                N = N / x               # N'yi x'e böl, x çarpanı kalmasın.\n        x += 1\n    return çarpanlar\n\nasalçarpanlar(600851475143)\n\n[71, 839, 1471, 6857]"
  },
  {
    "objectID": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#standart-sapma",
    "href": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#standart-sapma",
    "title": "Python Programlamaya Giriş 9 - Fonksiyonlara örnekler",
    "section": "Standart sapma",
    "text": "Standart sapma\nElimizde \\(N\\) tane \\(x_1, x_2,\\ldots,x_N\\) sayısı olsun. Sayıların ortalamasına \\(\\bar{x}\\) diyelim. Bu sayıların standart sapması şöyle tanımlanır:\n\\[ \\sigma = \\sqrt{ \\frac{1}{N-1} \\left[ (x_1-\\bar{x})^2 + (x_2-\\bar{x})^2 + \\ldots + (x_N-\\bar{x})^2\\right]}\\]\nBelirsiz sayıda parametre alan ve bu parametrelerin standart sapmasını veren stdsap() isimli bir fonksiyon yazalım. Standart sapmanın tanımlanabilmesi için fonksiyon en az iki parametre almalı. Bunun dışında parametre sayısında bir kısıtlama olmayacak. Bu şartı sağlamak için fonksiyon arayüzünü stdsap(x1, x2, *y) şeklinde yazmamız gerekir.\n\nimport math   # karekök için\n\ndef stsapma(x1, x2, *y):\n    N = len(y) + 2 # Fonksiyona verilen parametre sayısı\n\n    # ortalamayı hesapla\n    toplam = x1 + x2\n    for z in y:\n        toplam += z\n    ort = toplam / N\n\n    karetoplam = (x1-ort)**2 + (x2-ort)**2\n    for z in y:\n        karetoplam += (z-ort)**2\n    stsap = math.sqrt(karetoplam / (N-1))\n\n    return stsap\n\n\nprint(stsapma(1,2))\nprint(stsapma(1,2,2,3,3,3,3,4,4,5,5))\n\n0.7071067811865476\n1.250454462839956\n\n\nTipik bir uygulamada, verileri önceden kullanıcıdan veya bir dosyadan tek tek almış ve bir listeye yazmış olabilirsiniz. O durumda parametre çözme (link) kullanarak listeyi bu fonksiyona parametre olarak verebilirsiniz.\n\ndata = [1,2,2,3,3,3,3,4,4,5,5]\nstsapma( *data )\n\n1.250454462839956"
  },
  {
    "objectID": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#collatz-dizisi-uzunluğu",
    "href": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#collatz-dizisi-uzunluğu",
    "title": "Python Programlamaya Giriş 9 - Fonksiyonlara örnekler",
    "section": "Collatz dizisi uzunluğu",
    "text": "Collatz dizisi uzunluğu\nCollatz dizisini önceki bölümlerde görmüştük. Bir dizide belli bir \\(n_0\\) sayısından başlayıp \\(n_1\\)’i buluruz, \\(n_1\\) ile \\(n_2\\)’yi buluruz, ve böyle gider. Collatz dizisinde bir sonraki sayıyı bulma kuralı şöyledir:\n\n\\(n_i\\) çift sayıysa: \\(n_{i+1} = n_i/2\\)\n\\(n_i\\) tek sayıysa: \\(n_{i+1} = 3n_i+1\\)\n\\(n_i = 1\\) ise dur.\n\nSöz gelişi, 13 ile başlayan bir dizi aşağıdaki gibi olur.\n13, 40, 20, 10, 5, 16, 8, 4, 2, 1\nCollatz dizisi, bildiğimiz kadarıyla, hangi sayıyla başlarsak başlayalım hep 1’e gelir ve durur (ama bunun her zaman böyle olacağı ispat edilememiştir). Öyle bir fonksiyon yazalım ki, verilen bir başlangıç değeriyle Collatz dizisini üretsin ve 1’e kaç adımda ulaşıldığını saysın. Bunu yaparken dizinin en fazla kaça çıktığını da kaydetsin ve bu iki değeri geri versin.\n\ndef collatz_uzunluk(n):\n    enbüyük = n\n    uzunluk = 0\n    while n &gt; 1:\n        if n % 2==0:\n            n = n/2\n        else:\n            n = 3*n + 1\n\n        uzunluk += 1\n        if n &gt; enbüyük:\n            enbüyük = n\n    return uzunluk, enbüyük\n\n\nfor n0 in [11, 79]:\n    u, m = collatz_uzunluk(n0)\n    print(\"Başlangıç = {}, dizi uzunluğu = {}, en büyük değer = {}\".format(n0, u, m))\n\nBaşlangıç = 11, dizi uzunluğu = 14, en büyük değer = 52.0\nBaşlangıç = 79, dizi uzunluğu = 35, en büyük değer = 808.0\n\n\n11 ile başlayan Collatz dizisi 14 adım sonra 1’e ulaşıyor ve arada aldığı en büyük değer 52. Diziyi 79 ile başlatırsak 1’e ulaşana kadar 35 adım atıyor; ara değerler 808’e kadar çıkıyor."
  },
  {
    "objectID": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#taylor-serisiyle-üstel-fonksiyon",
    "href": "posts/2018/01/13/python-programlamaya-giris-fonksiyonlara-ornekler/index.html#taylor-serisiyle-üstel-fonksiyon",
    "title": "Python Programlamaya Giriş 9 - Fonksiyonlara örnekler",
    "section": "Taylor serisiyle üstel fonksiyon",
    "text": "Taylor serisiyle üstel fonksiyon\nDöngü alıştırmaları bölümünde üstel fonksiyon \\(e^x\\) değerini Taylor serisi ile bulmaktan bahsetmiştik.\n\\[ e^x = \\sum_{n=0}^{\\infty} \\frac {x^n}{n!} = 1 + x + \\frac{1}{2}x^2 + \\frac{1}{6}x^3 + \\cdots\\]\nBu açılımı kullanarak, üstel fonksiyonu bir Python fonksiyonu olarak yazalım.\nBu serinin sonsuz terimi olduğu için bir yerde kesmek zorundayız. Bu kesme bir hataya yol açacak, ve biz ne kadarlık bir hataya göz yumabileceğimizi (toleransımızı) önceden belirleyeceğiz. Her yeni terim bir öncekinden küçük olduğu için, yeni terim toleranstan küçükse hesabı durduracağız.\nAyrıca, kaç tane terim kullanabileceğimizin katı bir sınırı da olacak. Belki öyle bir \\(x\\) sayısı ile başlarız ki, seriye ne kadar terim eklersek ekleyelim bir türlü toleransın altına inemeyiz. Tabii bu serinin her \\(x\\) değeri için yakınsak olduğunu biliyoruz, ama bu ek emniyet tedbiri bu tür iteratif algoritmalarda genelde faydalıdır. Eğer azami terim sayısına ulaşılmasına rağmen terimler toleransın altına inmediyse ekrana bir uyarı mesajı basılsın ve fonksiyon elde ettiği sonucu geri versin.\nTolerans ve azami terim sayısı için makul varsayılan değerler verelim, böylece fonksiyonu kullanırken her seferinde yazmak zorunda kalmayalım. Sadece deney yapmak istediğimizde değiştirelim.\n\ndef üstel(x, hata = 1e-8, maxterim = 20):\n    n = 1\n    sonterim = 1 # serideki ilk terimimiz\n    toplam = sonterim\n    while sonterim &gt;= hata:\n        if n &gt; maxterim :\n            print(\"{} terimde yakınsama sağlanamadı\".format(maxterim))\n            break\n        sonterim = sonterim * x/n # yeni terim bir öncekini x ile çarpıp terim sıra numarasına bölerek bulunuyor.\n        toplam += sonterim\n        n += 1\n    return toplam\n\nFonksiyonumuzu standart kütüphanedeki üstel fonksiyonla karşılaştıralım:\n\nimport math\nprint(math.exp(2))\nprint(üstel(2))\n\n7.38905609893065\n7.389056098516415\n\n\nVirgülden sonra dokuz basamağa kadar uyum sağlanıyor. Daha iyi uyum için toleransı küçültebiliriz. Ama çok küçültürsek yirmi terim yeterli olmayacaktır.\n\nüstel(2, hata=1e-15)\n\n20 terimde yakınsama sağlanamadı\n\n\n7.389056098930604\n\n\nBu sınıra takılmadan daha yüksek hassasiyet sağlamak için maxterim değerini artırabiliriz.\n\nprint(math.exp(2))\nprint(üstel(2, hata=1e-15, maxterim=30))\n\n7.38905609893065\n7.389056098930649\n\n\nBüyük \\(x\\) değerleri kullanmak da varsayılan terim sayısının yetmemesine sebep olabilir.\n\nüstel(10)\n\n20 terimde yakınsama sağlanamadı\n\n\n21991.482025665064\n\n\n\nprint(math.exp(10))\nprint(üstel(10, maxterim=50))\n\n22026.465794806718\n22026.46579480579\n\n\nBurada bir örnek olsun diye üstel fonksiyon için kod yazdık, ama pratik uygulamalarda bu kodu kullanmamalısınız. Matematiksel işlemler için Python’un matematik kütüphanesini kullanmanız daha iyi olur. Bu kütüphane C dilinde yazılmış ve derlenerek makine diline çevrilmiş kod kullandığı için çok daha hızlıdır. Tek çalıştırmada bu hız farkı çok belli olmasa da çok sayıda işlem yapıldığında ciddi bir fark görülür.\n\n%timeit üstel(2)\n\n3.11 µs ± 584 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\n\n\n%timeit math.exp(2)\n\n138 ns ± 6.25 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)\n\n\nGörüldüğü gibi math.exp fonksiyonu işlemi 140 nanosaniyede yaparken, bizim yazdığımız üstel fonksiyonuyla yapılan işlem yaklaşık 3 mikrosaniye sürüyor, yirmi kat yavaş. Üstelik math.exp daha yüksek hassasiyette sonuç veriyor ve fazladan kontroller içeriyor.\nMeraklısı için: math.exp içinde üstel fonksiyon Taylor serisiyle hesaplanmaz. Python matematik işlemlerinde C dilinin standart matematik kütüphanesini kullanır. Bu kütüphanede üstel fonksiyon hızlı ve isabetli hesaplanabilecek şekilde özel olarak düzenlenmiştir. C’de üstel fonksiyonun tanımı şurada görülebilir. Özetle, önce öyle bir tamsayı \\(k\\) ve \\(|r|&lt;0.5\\ln 2\\) sağlayan reel sayı \\(r\\) bulunur ki, parametremiz \\(x = k\\ln 2 + r\\) biçiminde olsun. O zaman \\(e^x = 2^k + e^r\\) şeklinde yazılabilir. Bunun avantajı şudur: Bilgisayarda 2’nin tamsayı kuvvetini almak kolaydır (sayı bitlerini sola kaydırmak yeter). Kalan \\(r\\) sayısı küçük olduğu için \\(e^r\\) içinse yüksek hassasiyetli özel bir formül kullanılabilir. Ara hesaplar, bayt seviyesi işlemler kullanılarak mümkün olduğunca hızlandırılır."
  },
  {
    "objectID": "posts/2018/01/23/foursquare-api/index.html",
    "href": "posts/2018/01/23/foursquare-api/index.html",
    "title": "Foursquare API",
    "section": "",
    "text": "İnternet üzerindeki açık veri kaynakları, bu verileri kullanan uygulamalar geliştirmek isteyenler ya da üzerinde çalıştıkları problemlere farklı alanlardan derledikleri verileri de katmak isteyenler için birçok imkan sunuyor. Örnek olarak Twitter üzerindeki tweetleri kullanarak duygu analizi yapmak ya da hava durumu, hisse senedi fiyatları gibi verileri de analizinize katmak açık veri kaynakları sayesinde mümkün.\nİlker, Star Wars filmlerinin verisi kullanılarak hazırlanmış bir uygulama ara yüzünden (Application Programming Interface, API) bahsetmişti. Bu yazıda benzer bir uygulamayı Foursquare API’ı üzerinden yapacağız.\nBildiğiniz gibi, Foursquare konum temelli arama yapmanızı sağlayan ve istediğiniz konularda (restoran, ziyaret edilecek yerler) tavsiyeler alabileceğiniz bir servis. Konum temelli uygulamalar geliştirmek ya da konuma bağlı sorularınıza cevap aramak için Foursquare üzerindeki verilerden yararlanabilirsiniz.\nFoursquare API’ını kullanmak için ilk yapmamız gereken Foursquare üzerinden bir geliştirici (developer) hesabı açmak. Geliştirici hesabı üzerinden ’Yeni bir uygulama oluştur’a girerek uygulamanızın detaylarını oluşturabilirsiniz.\n\nUygulamanız için bir isim ve web sayfası girmeniz gerekiyor.\n\nBir sonraki aşamada hesap tipini seçmelisiniz. Ben deneme amacıyla ‘Sandbox’ tipi bir hesap kullandım. ‘Sandbox’ hesabının kötü yanı günlük 1000 adet sorguyla kısıtlı olması. Hesabınızı doğrulatarak, ücretsiz olarak ‘Personal’ tipi bir hesap açabilir ve daha fazla sorgulama yapabilirsiniz.\n\nHesap tipini seçtikten sonra, Foursquare size ‘Client ID’ ve ‘Client Secret’ adlı iki anahtar sağlayacak. Bu anahtarlar API ile haberleşmenize olanak verecek kişisel bilgilerinizdir. Bu nedenle aşağıdaki dosyada bu anahtarları gizledim.\n\nBu işlemleri yaptıktan sonra artık API’ı kullanabilirsiniz. Kayıt için gerekli adımları FourSquare API dokümanında bulabilirsiniz. API’ı kullanmak için ilk olarak ‘Client ID’ ve ‘Client Secret’ anahtarlarını tanıtıyoruz. Anahtarları aşağıda da gizledim.\n\nclient_id = 'EP3...............'\nclient_secret = 'YYG...............'\n\nArtık API’ı kullanmaya hazırız. Daha önce Star Wars API’nda olduğu gibi Foursquare API’ndan çekeceğimiz veri de JSON formatında. Yani veri alan anahtarı: değer şeklinde ikililer olarak tutuluyor. Süslü parantezler yardımıyla iç içe geçmiş bir yapı kurmak da mümkün. JSON formatı Kaan’ın yazısında değindiği Python sözlükleri ile aynı yapıda.\nİlk olarak mekan aramayı deneyelim. Veriler JSON formatında olduğu için json paketini ve API’a sorgu göndermek için de requests paketini kullanacağız. Aşağıdaki örnekte Ayasofya’yı bularak başlayalım.\n\n# API'a sorgu göndermek için requests paketini kullanıyoruz.\nimport requests\n# JSON formatındaki verileri almak ve yazdırmak için json paketine ihtiyacımız var.  \nimport json\n\n# Arama yapmak istediğimiz için aşağıdaki URL'yi kullanıyoruz. Arama dışındaki örneklerde URL değişecek.\nurl = 'https://api.foursquare.com/v2/venues/search'\n\n# Sorgu parametrelerini tanımlayalım. \n\"\"\"\nclient_id ve client_secret kendimizi Foursquare'e tanımlamak için kullandığımız anahtarlar.\nv değeri API'ın hangi versiyonunu kullandığımızı gösteriyor ve zorunlu bir alan.\nquery değeri de yapmak istediğimiz sorgunun arama kelimesi\n\"\"\"\nparams = dict(\n  client_id=client_id,\n  client_secret=client_secret,\n  v='20170801',\n  query='Ayasofya'\n)\nresp = requests.get(url=url, params=params)\ndata = json.loads(resp.text)\nprint(json.dumps(data,indent = 4))\n\n{\n    \"meta\": {\n        \"code\": 400,\n        \"errorType\": \"param_error\",\n        \"errorDetail\": \"Must provide parameter ll\",\n        \"requestId\": \"5a634a4b9fb6b764642942b1\"\n    },\n    \"response\": {}\n}\n\n\nKodumuz çalıştı gibi görünse de aslında bir hata aldık. Arama yaparken arama yaptığımız yaklaşık yeri de vermemiz gerekiyor. Bunu yapmanın iki yolu var. ll ile bir yer koordinatı verebiliriz (Tarihi yarımada yaklaşık olarak 41.01 enleminde ve 28.97 boylamında) ya da near ile bulunduğu bölge hakkında bir ipucu verebiliriz. Ben, ayrıca, döndürülen sonuç sayısını limitlemeyi tercih ettim. Bu sayede karşımıza tek bir sonuç çıkacak ve adında Ayasofya olan diğer yerlerin de veri setinde yer almasını engelleyeceğiz.\n\n\"\"\"\nll değeri enlem ve boylam cinsinden aramak istediğimiz yeri belirtiyor ve tarihi yarımadanın koordinatlarına denk geliyor.\nlimit değeriyle tek bir sonuç döndürmeyi tercih ettik.\n\"\"\"\nparams = dict(\n  client_id=client_id,\n  client_secret=client_secret,\n  v='20170801',\n  ll=\"41.01,28.97\",\n  query='Ayasofya',\n  limit=1\n)\nresp = requests.get(url=url, params=params)\ndata = json.loads(resp.text)\nprint(json.dumps(data,indent = 4, ensure_ascii= False))\n\n{\n    \"meta\": {\n        \"code\": 200,\n        \"requestId\": \"5a634a4bf594df01e978d8db\"\n    },\n    \"response\": {\n        \"venues\": [\n            {\n                \"id\": \"4bc8088f15a7ef3b6b857ada\",\n                \"name\": \"Ayasofya | Hagia Sophia (Ayasofya)\",\n                \"contact\": {\n                    \"phone\": \"+902125221750\",\n                    \"formattedPhone\": \"+90 212 522 17 50\"\n                },\n                \"location\": {\n                    \"address\": \"Ayasofya Myd. Sultanahmet\",\n                    \"lat\": 41.0082839956457,\n                    \"lng\": 28.979008518719493,\n                    \"distance\": 780,\n                    \"postalCode\": \"34122\",\n                    \"cc\": \"TR\",\n                    \"city\": \"Fatih\",\n                    \"state\": \"İstanbul\",\n                    \"country\": \"Türkiye\",\n                    \"formattedAddress\": [\n                        \"Ayasofya Myd. Sultanahmet\",\n                        \"34122 Fatih\",\n                        \"Türkiye\"\n                    ]\n                },\n                \"categories\": [\n                    {\n                        \"id\": \"4bf58dd8d48988d190941735\",\n                        \"name\": \"History Museum\",\n                        \"pluralName\": \"History Museums\",\n                        \"shortName\": \"History Museum\",\n                        \"icon\": {\n                            \"prefix\": \"https://ss3.4sqi.net/img/categories_v2/arts_entertainment/museum_history_\",\n                            \"suffix\": \".png\"\n                        },\n                        \"primary\": true\n                    }\n                ],\n                \"verified\": true,\n                \"stats\": {\n                    \"checkinsCount\": 224502,\n                    \"usersCount\": 184348,\n                    \"tipCount\": 1149\n                },\n                \"url\": \"http://ayasofyamuzesi.gov.tr\",\n                \"allowMenuUrlEdit\": true,\n                \"beenHere\": {\n                    \"lastCheckinExpiredAt\": 0\n                },\n                \"specials\": {\n                    \"count\": 0,\n                    \"items\": []\n                },\n                \"venuePage\": {\n                    \"id\": \"81118933\"\n                },\n                \"hereNow\": {\n                    \"count\": 36,\n                    \"summary\": \"36 people are here\",\n                    \"groups\": [\n                        {\n                            \"type\": \"others\",\n                            \"name\": \"Other people here\",\n                            \"count\": 36,\n                            \"items\": []\n                        }\n                    ]\n                },\n                \"referralId\": \"v-1516456523\",\n                \"venueChains\": [],\n                \"hasPerk\": false\n            }\n        ]\n    }\n}\n\n\nVeri setinde reponse anahtarının altında sorgulamamızla ilişkili sonuçlara erişebiliriz. Sonucun altında koyduğumuz limit sayesinde tek bir mekan (venues) bulunmakta. Burada önemli olan anahtarlar:\n\n\n\n\n\n\n\n\nAnahtar\nAnlam\nDeğer\n\n\n\n\nid\nMekanın belirteci\n4bc8088f15a7ef3b6b857ada\n\n\nname\nMekanın adı\nAyasofya Hagia Sophia (Ayasofya)\n\n\nlat\nBoylamı\n41.00824813964318\n\n\nlng\nEnlemi\n28.978616263778942\n\n\ndistance\nAradığımız koordinatlara uzaklık\n749 metre\n\n\ncheckinsCount\nCheck-in sayısı\n223738\n\n\nusersCount\nKullanıcı sayısı\n183768\n\n\ntipCount\nTavsiye sayısı\n1147\n\n\n\nAyasofya’nın Foursquare sayfasını ziyaret ederek yukarıdaki değerleri kontrol edebilirsiniz. Özellikle check-in sayısı, kullanıcı sayısı, tavsiye sayısı ve tavsiyeler konumların popülerliği hakında ipucu verecek bilgiler.\nBir diğer arama yöntemi olarak da Paris yakınındaki Eyfel Kulesi’ni arayalım. Bu sefer koordinat vermek yerine yaklaşık yeri belirteceğiz (near = \"Paris\")\n\nparams = dict(\n  client_id=client_id,\n  client_secret=client_secret,\n  v='20170801',\n  near = \"Paris\",\n  query='Eiffel Tower', \n  limit = 1\n)\nresp = requests.get(url=url, params=params)\ndata = json.loads(resp.text)\nprint(json.dumps(data['response']['venues'],indent = 4, ensure_ascii= False))\n\n[\n    {\n        \"id\": \"51a2445e5019c80b56934c75\",\n        \"name\": \"Tour Eiffel\",\n        \"contact\": {\n            \"phone\": \"+33892701239\",\n            \"formattedPhone\": \"+33 892 70 12 39\",\n            \"twitter\": \"latoureiffel\",\n            \"instagram\": \"toureiffelofficielle\",\n            \"facebook\": \"141184112585566\",\n            \"facebookUsername\": \"TourEiffel\",\n            \"facebookName\": \"Tour Eiffel\"\n        },\n        \"location\": {\n            \"address\": \"5 avenue Anatole France\",\n            \"crossStreet\": \"Parc du Champ-de-Mars\",\n            \"lat\": 48.858249354605626,\n            \"lng\": 2.2944259643554683,\n            \"labeledLatLngs\": [\n                {\n                    \"label\": \"display\",\n                    \"lat\": 48.858249354605626,\n                    \"lng\": 2.2944259643554683\n                }\n            ],\n            \"postalCode\": \"75007\",\n            \"cc\": \"FR\",\n            \"city\": \"Paris\",\n            \"state\": \"Île-de-France\",\n            \"country\": \"France\",\n            \"formattedAddress\": [\n                \"5 avenue Anatole France (Parc du Champ-de-Mars)\",\n                \"75007 Paris\",\n                \"France\"\n            ]\n        },\n        \"categories\": [\n            {\n                \"id\": \"4bf58dd8d48988d12d941735\",\n                \"name\": \"Monument / Landmark\",\n                \"pluralName\": \"Monuments / Landmarks\",\n                \"shortName\": \"Landmark\",\n                \"icon\": {\n                    \"prefix\": \"https://ss3.4sqi.net/img/categories_v2/building/government_monument_\",\n                    \"suffix\": \".png\"\n                },\n                \"primary\": true\n            }\n        ],\n        \"verified\": true,\n        \"stats\": {\n            \"checkinsCount\": 254582,\n            \"usersCount\": 193249,\n            \"tipCount\": 2331\n        },\n        \"url\": \"http://www.paris.fr\",\n        \"beenHere\": {\n            \"lastCheckinExpiredAt\": 0\n        },\n        \"specials\": {\n            \"count\": 0,\n            \"items\": []\n        },\n        \"storeId\": \"\",\n        \"hereNow\": {\n            \"count\": 11,\n            \"summary\": \"11 people are here\",\n            \"groups\": [\n                {\n                    \"type\": \"others\",\n                    \"name\": \"Other people here\",\n                    \"count\": 11,\n                    \"items\": []\n                }\n            ]\n        },\n        \"referralId\": \"v-1516456525\",\n        \"venueChains\": [],\n        \"hasPerk\": false\n    }\n]\n\n\nGördüğünüz gibi koordinat yerine yaklaşık olarak yer vermek de aynı işi görüyor. Şimdi Eyfel Kulesi’yle ilgili en popüler 10 yorumu görelim. Bir mekanla ilgili tavsiyeleri görmek için mekanın belirtecini de url’ye eklememiz gerekiyor. Yorumların metin kısmıyla ilgileneceğimiz için, süslü parantez yapısına göre, response - tips - items alanlarına erişmemiz gerekiyor. Hangi alanlara erişmemiz gerektiğini aşağıdaki kodda bulunan data sözlüğünün yapısını inceleyerek bulabilirsiniz. Bu alanların altındaki her bir yorum için de text alanının değerini bastıralım.\n\n# Dokümandaki url \"https://api.foursquare.com/v2/venues/VENUE_ID/tips\" şeklinde.\n# VENUE_ID'yi sorgulayacağımız mekana göre değiştirmemiz gerekiyor.\n# Eiffel Kulesi'nin belirteci: 51a2445e5019c80b56934c75\nurl = \"https://api.foursquare.com/v2/venues/51a2445e5019c80b56934c75/tips\"\n    \nparams = dict(\n  client_id=client_id,\n  client_secret=client_secret,\n  v='20170801',\n  sort = \"popular\",\n  limit=10\n)\nresp = requests.get(url=url, params=params)\ndata = json.loads(resp.text)\n\nfor tavsiye in data['response']['tips']['items']:\n    print(tavsiye['text'])\n\nIcon of Paris. Nuff said. Go to the top and enjoy the view.\nApparently the Eiffel Tower grows in summer! Made of iron, it expands with heat & can get more than 15 cm taller.\nLa tour Eiffel est l'icône de Paris, pourtant, à l'exception de vos photos traditionnelles avec la tour sur l'arrière-plan il n'y a pas grand-chose. Vous devriez aller avant 9h00.\nAussi, vous devriez y aller la nuit. Vous devriez avoir une vue incroyable avec une superbe photo.\nWelcome to one of the world's most iconic monuments 😜 From the 🔝 you can take beautiful shots 😜😍📸👍\nI went there for fun, the joy of being on the top, and sightseeing. I'd suggest buying the tickets in advance to avoid the long queues.\nSit by the river right next to the tower for best view at midnight when it sparkles for 5 mins. Another option is to see it from louvre that's a further view! Beautiful 5 mins of ur life!\nThe famous landmark! Take a tour to the summit that cost €17 for an adult. Beware of pickpocket in the elevator! Enjoy the view on 2nd and top floor and visit the souvenirs shop. Bring jacket!\n5/14/13: you have two options 1) first level only and about €8, or 2) all the way to the top €14,50. Both are great views, but might as well go to the top! Will take at least 30 min wait time\nTarihi olmayan bir demir yığınının dümdüz Paris'te sağladığı mükemmel manzara. Sırasında beklerken bile çıksak mı dediğimiz kuleye çıkmadan etmeyin. Ayrı bir tecrübe. Gün batımına denk getirin.\n\n\nEyfel Kulesi’yle ilgili tavsiyeleri almak için Eyfel Kulesi’nin belirtecini de url’ye eklemek durumunda kaldık. Bunu yapmadan da tavsiyelere ulaşmak mümkün. Foursquare API’ını kullanmanın bir diğer yolu linkteki Github dizinindeki kütüphane. Python için API’ı kullanmayı kolaylaştıran foursquare kütüphanenesini aşağıdaki sihirli ifadeyle yükleyebilirsiniz. Sadece diyez işaretini kaldırmanız gerekecek.\n\n# Yanlışlıkla yüklemeyi engellemek için sihirli ifade yorum olarak girildi.\n# foursquare paketini yüklemek için aşağıdaki satırda # işaretini kaldırmanız yeterli.\n# !pip install foursquare\n\nPaketi yükledikten sonra, kendimizi tanıtmamız gerekiyor. Kendimizi tanıtmak için yukarıda oluşturduğunuz anahtarları kullanabilirsiniz.\n\nimport foursquare as fs\n#Anahtarlarımızı tanıtarak izin alıyoruz.\nclient = fs.Foursquare(client_id=client_id, client_secret=client_secret)\nauth_uri = client.oauth.auth_url()\n\nŞimdi Ayasofya yakınlarındaki restoranları arayalım. 1.5 km mesafedeki en popüler 10 restoranı bulalım ve uzaklıklarıyla birlikte sonuçları görelim. Kullanabileceğiniz başka sıralama yöntemleri ve parametreleri öğrenmek için API dokümantasyonu size yardımcı olacaktır.\n\nparams = dict(\n  query = 'restaurant',\n  ll = '41.00824813964318,28.978616263778942',\n  radius = 1500,\n  sort = \"popular\",\n  limit=10\n)\n\ndata = client.venues.search(params=params)\nfor restaurant in data['venues']:\n    print(\"Restoran adı: {} Uzaklık: {} metre\".format(restaurant['name'], restaurant[\"location\"][\"distance\"]))\n\nRestoran adı: Neyzen Restaurant Uzaklık: 1253 metre\nRestoran adı: Sefa-i Hürrem Cafe & Restaurant Uzaklık: 1393 metre\nRestoran adı: Meşale Restaurant & Cafè Uzaklık: 299 metre\nRestoran adı: Hamdi Restaurant Uzaklık: 1235 metre\nRestoran adı: Afrodit Restaurant Uzaklık: 1247 metre\nRestoran adı: Namlı Cafe Şarküteri Restaurant Uzaklık: 1191 metre\nRestoran adı: Fuego Cafe & Restaurant Uzaklık: 116 metre\nRestoran adı: Seoul Restaurant Uzaklık: 349 metre\nRestoran adı: Albura Kathisma Cafe & Restaurant Uzaklık: 316 metre\nRestoran adı: Olive Anatolian Restaurant Uzaklık: 463 metre\n\n\nİki sorgununda da parametrelerini sözlük yapısında vermemiz gerekti. Aynı zamanda kullandığımız parametreler de aynıydı. Orijinal API’ı kullanmakla foursquare paketini kullanmak arasında gözüken iki fark var:\n\nSonuçları görmek için response alanına erişmek zorunda kalmadık. foursquare paketi bize zaten response alanını döndürüyor, sorgunuzla ilgili üst veriyi (metadata) döndürmüyor.\nSorgu için herhangi bir url girmemiz gerekmedi. foursquare paketi sayesinde adresi ezberlemenize ya da araştırmanıza gerek kalmadı. Ancak paketin altındaki fonksiyonları öğrenmeniz gerekiyor.\n\nBahsettiğim konular dışında bir fark yok gibi. Eyfel Kulesi’yle ilgili tavsiyeleri bir de foursquare paketiyle alalım.\n\nparams = dict(\n  sort = \"popular\",\n  limit=10\n)\ndata = client.venues.tips('51a2445e5019c80b56934c75', params=params)\nfor tavsiye in data['tips']['items']:\n    print(tavsiye['text'])\n\nIcon of Paris. Nuff said. Go to the top and enjoy the view.\nApparently the Eiffel Tower grows in summer! Made of iron, it expands with heat & can get more than 15 cm taller.\nLa tour Eiffel est l'icône de Paris, pourtant, à l'exception de vos photos traditionnelles avec la tour sur l'arrière-plan il n'y a pas grand-chose. Vous devriez aller avant 9h00.\nAussi, vous devriez y aller la nuit. Vous devriez avoir une vue incroyable avec une superbe photo.\nWelcome to one of the world's most iconic monuments 😜 From the 🔝 you can take beautiful shots 😜😍📸👍\nI went there for fun, the joy of being on the top, and sightseeing. I'd suggest buying the tickets in advance to avoid the long queues.\nSit by the river right next to the tower for best view at midnight when it sparkles for 5 mins. Another option is to see it from louvre that's a further view! Beautiful 5 mins of ur life!\nThe famous landmark! Take a tour to the summit that cost €17 for an adult. Beware of pickpocket in the elevator! Enjoy the view on 2nd and top floor and visit the souvenirs shop. Bring jacket!\n5/14/13: you have two options 1) first level only and about €8, or 2) all the way to the top €14,50. Both are great views, but might as well go to the top! Will take at least 30 min wait time\nTarihi olmayan bir demir yığınının dümdüz Paris'te sağladığı mükemmel manzara. Sırasında beklerken bile çıksak mı dediğimiz kuleye çıkmadan etmeyin. Ayrı bir tecrübe. Gün batımına denk getirin.\n\n\nfoursquare paketini kullanmadığımızda sorgu adresini değiştirmemiz (adresin içine mekanın belirtecini girmemiz) gerekmişti. foursquare paketiyle mekan belirtecini bir parametre olarak sorguya vermemiz yeterli oldu. Paketi kullanmak, adresleri girmemek ve değiştirmek zorunda kalmamak nedeniyle bana daha kolay geldi. Ancak paketin dokümantasyonunun çok da iyi olmadığını belirtmem gerek.\nHem Foursquare API’ı hem de foursquare paketi üzerinden başka bilgilere erişmek mümkün. Kullanıcıların check-in yaptığı ve beğendiği yerlere, diğer bilgilerine, yüklediği fotoğraflara API üzerinden erişebiliyoruz. Mekanlarla ilgili olarak da çalışma saatleri, mekanın fotoğrafları, tavsiyeler gibi verileri derleyebiliyoruz. Aynı zamanda fotoğraf, check-in ve tavsiyeler için API sorguları da mevcut.\nBu yazıya Jupyter defteri olarak Github dizinimizden erişebilirsiniz."
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "",
    "text": "Python’daki veri tiplerini daha önce kısaca ele almıştık; bir önceki bölümde de liste tipine ait metodların kullanımını örneklerle incelemiştik. Bu yazıda sözlük tipine ait olan metodları örneklerle açıklıyoruz. Bundan sonraki bölümlerde dize ve küme tiplerine ait metodları inceleyeceğiz.\nDizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\nSözlükler, listeler gibi, birden fazla elemanı bir araya toplayan yapılardır. Listelerden farkları sıralı nesne olmamalarıdır. Bir listenin indeksleri üzerinden doğal bir sırası varken, sözlüklerin elemanlarında doğal bir sıralama mevcut değildir.\nBir sözlük birleşmeli dizi (associative array) olarak anılan bir veri yapısıdır. Bu yapıdaki her eleman bir anahtar-değer (key-value) çiftinden oluşur. Belli bir değere ulaşmak için o değere ait tekil anahtarı kullanmak gerekir. Bu anahtar bir sayı, dize veya çokuz olabilir.\nListelerde elemanlar sıfırdan başlayarak tamsayılarla indekslenirken, sözlük elemanlarını anahtarlarla indekslenir. Bu anlamda sözlükler listelerden daha geneldirler."
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlük-yaratma",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlük-yaratma",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "Sözlük yaratma",
    "text": "Sözlük yaratma\nDiyelim bir kişinin ismini ve yaşını barındıran bir sözlük oluşturacaksınız. Bu sözlüğü Python’da oluşturmanın dört değişik yolu vardır.\n\nDoğrudan bir sözlük nesnesi yaratmak\n\n\nD = {\"isim\" : \"Ali\", \"yaş\" : 45}\nD\n\n{'isim': 'Ali', 'yaş': 45}\n\n\n\nBoş bir sözlük yarattıktan sonra anahtar ve değerleri tek tek eklemek:\n\n\nD = {}\nD[\"isim\"] = \"Ali\"\nD[\"yaş\"] = 45\nD\n\n{'isim': 'Ali', 'yaş': 45}\n\n\n\ndict fonksiyonunu isimli parametrelerle kullanmak:\n\n\nD = dict(isim=\"Ali\", yaş=45)\nD\n\n{'isim': 'Ali', 'yaş': 45}\n\n\n\ndict fonksiyonuna (anahtar, değer) çiftleri dizisi vermek:\n\n\nD = dict([(\"isim\",\"Ali\"),(\"yaş\",45)])\nD\n\n{'isim': 'Ali', 'yaş': 45}\n\n\nBu sonuncu yöntem genellikle, anahtarlar ve değerler ayrı ayrı listelerde verilmişse, onları zip fonksiyonuyla birleştirilerek kullanılır.\n\nanahtarlar = ['isim', 'yaş']\ndegerler = ['Ali', 45]\nD = dict( zip(anahtarlar, degerler) )\nD\n\n{'isim': 'Ali', 'yaş': 45}"
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#len-del-in",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#len-del-in",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "len, del, in",
    "text": "len, del, in\nBir nesnenin içindeki eleman sayısını veren len fonksiyonu, bir nesneyi veya elemanını silen del komutu, belirli bir elemanın mevcut olup olmadığını veren in işlemi sözlüklerde de kullanılabilir.\n\nD = {'bir': 1, 'iki': 2.0, 'pi': 3.14159}\n\n\nlen(D)\n\n3\n\n\n\n\"bir\" in D\n\nTrue\n\n\nin komutu sadece anahtarlar üzerinde tarama yapar. Değerler arasında belli bir değer bulunup bulunmadığını bulmakta kullanılmaz.\n\n1 in D\n\nFalse\n\n\n\ndel D[\"bir\"]\nD\n\n{'iki': 2.0, 'pi': 3.14159}"
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlük-metodları",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlük-metodları",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "Sözlük metodları",
    "text": "Sözlük metodları\nBir sözlük nesnesine ait metodları dir fonksiyonuyla görebiliriz.\n\ndir(dict)\n\n['__class__',\n '__contains__',\n '__delattr__',\n '__delitem__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getitem__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__iter__',\n '__le__',\n '__len__',\n '__lt__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__setitem__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n 'clear',\n 'copy',\n 'fromkeys',\n 'get',\n 'items',\n 'keys',\n 'pop',\n 'popitem',\n 'setdefault',\n 'update',\n 'values']\n\n\nBaşında ve sonunda altçizgi olan metodlar nesne içi kullanım içindir."
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlükteki-bütün-maddeleri-silmek",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlükteki-bütün-maddeleri-silmek",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "Sözlükteki bütün maddeleri silmek",
    "text": "Sözlükteki bütün maddeleri silmek\nclear metodu ile bir sözlükteki bütün anahtar-değer çiftleri silinebilir.\n\nD = {'bir': 1, 'iki': 2.0, 'pi': 3.14159}\nD.clear()\nD\n\n{}"
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlüğün-kopyasını-çıkarmak",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlüğün-kopyasını-çıkarmak",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "Sözlüğün kopyasını çıkarmak",
    "text": "Sözlüğün kopyasını çıkarmak\nBazen bir sözlükteki orijinal bilgileri değiştirmeden, bir kopya üzerinde işlemler yapmanız gerekebilir. Bir sözlüğün kopyasını copy metoduyla elde edebilirsiniz.\n\nD = {'bir': 1, 'iki': 2.0, 'pi': 3.14159}\nD2 = D.copy()\nD2\n\n{'bir': 1, 'iki': 2.0, 'pi': 3.14159}\n\n\nBundan sonra D2’de yapacağımız değişiklikler D’yi etkilemez.\n\nD2[\"bir\"] = \"uno\"\nprint(\"D =\",D)\nprint(\"D2 =\",D2)\n\nD = {'bir': 1, 'iki': 2.0, 'pi': 3.14159}\nD2 = {'bir': 'uno', 'iki': 2.0, 'pi': 3.14159}"
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#iki-sözlüğü-birleştirmek",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#iki-sözlüğü-birleştirmek",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "İki sözlüğü birleştirmek",
    "text": "İki sözlüğü birleştirmek\nSözlüklerin update metodu ile varolan bir sözlüğe yeni bir sözlükten anahtar-değer çiftleri ekleyebilirsiniz. Aynı anahtara sahip iki değer varsa, eskisi yenisiyle değiştirilir. Bu metod nesne içi (in-place) değişiklik yapar.\n\ntelefonlar = {\"Ali\": 3762, \"Zeynep\": 8249, \"Mehmet\": 2652}\ntelf_2 = {\"Fatma\": 9212, \"Deniz\": 1129, \"Mehmet\": 1212}\ntelefonlar.update(telf_2)\ntelefonlar\n\n{'Ali': 3762, 'Deniz': 1129, 'Fatma': 9212, 'Mehmet': 1212, 'Zeynep': 8249}"
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlüklerden-liste-üretmek",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlüklerden-liste-üretmek",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "Sözlüklerden liste üretmek",
    "text": "Sözlüklerden liste üretmek\nBazen bir sözlükteki elemanları teker teker işlemek için bir döngü kurmak isteyebilirsiniz. Ancak sözlükler sıralı nesne olmadıkları için for döngüsü ile kullanılamazlar. Bir sözlüğün içeriğini iterasyona uygun bir biçime getirmek için dict.items metodunu kullanmalıyız.\n\ntelefonlar = {\"Ali\": 3762, \"Zeynep\": 8249, \"Mehmet\": 2652}\nfor isim,tel in telefonlar.items():\n    print(\"Adı: {}, İç Hat: {}\".format(isim,tel))\n\nAdı: Ali, İç Hat: 3762\nAdı: Zeynep, İç Hat: 8249\nAdı: Mehmet, İç Hat: 2652\n\n\n\nlist(telefonlar.items())\n\n[('Ali', 3762), ('Zeynep', 8249), ('Mehmet', 2652)]\n\n\nDikkat: Yazdığımız döngüde elemanları sözlüğe verdiğimiz orijinal sırada geri aldık. Ama bunun her zaman böyle olacağının garantisi yok. Sözlüklerde herhangi bir varsayılan sıra olmaz. Yapacağınız işlem belli bir sıralama gerektiriyorsa, işlemden önce elemanlar listesinde açık komutla sıralama yapın.\n\ntelefonlar = {\"Ali\": 3762, \"Zeynep\": 8249, \"Mehmet\": 2652}\nfor isim,tel in sorted(telefonlar.items()):\n    print(\"Adı: {}, İç Hat: {}\".format(isim,tel))\n\nAdı: Ali, İç Hat: 3762\nAdı: Mehmet, İç Hat: 2652\nAdı: Zeynep, İç Hat: 8249\n\n\nSadece anahtarlardan oluşan bir liste elde etmek için dict.keys metodunu kullanırız.\n\nlist(telefonlar.keys())\n\n['Ali', 'Zeynep', 'Mehmet']\n\n\nSadece değerlerden oluşan bir liste için dict.values metodu kullanılır.\n\nlist(telefonlar.values())\n\n[3762, 8249, 2652]\n\n\nEğer iki çağrı arasında sözlükte bir değişiklik yapılmadıysa, keys ve values metodlarıyla elde ettiğimiz listelerin elemanları karşılıklı olarak sözlükteki mevcut anahtar-değer çiftlerine denk gelir. Böylece zip ile bu listeleri birleştirerek orijinal sözlüğü elde edebiliriz.\n\nisimler = list(telefonlar.keys())\ntelnolar = list(telefonlar.values())\ndict(zip(isimler,telnolar))\n\n{'Ali': 3762, 'Mehmet': 2652, 'Zeynep': 8249}"
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#elemanlara-erişmek",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#elemanlara-erişmek",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "Elemanlara erişmek",
    "text": "Elemanlara erişmek\nBir D sözlüğünde saklanan bir değere erişmenin en basit yolu D[anahtar] komutunu kullanmak. Fakat anahtar referansı sözlükte tanımlı değilse bir hata mesajı çıkar, bu da programınızın akışınızı bozabilir.\n\ntelefonlar = {\"Ali\": 3762, \"Zeynep\": 8249, \"Mehmet\": 2652}\ntelefonlar[\"Ali\"]\n\n3762\n\n\n\ntelefonlar[\"Kaan\"]\n\nKeyError: 'Kaan'\n\n\nVerilen anahtarın sözlükte bulunmaması durumunda varsayılan bir değer döndürülmesini istiyorsanız, get metodunu kullanabilirsiniz. D.get(k, d) ifadesi, k anahtarı sözlükte varsa D[k] değerini, yoksa varsayılan d değerini geri verir.\n\nfor isim in [\"Ali\",\"Kaan\"]:\n    print(\"{} telefonu {}\".format(isim, telefonlar.get(isim, \"mevcut değil\")))\n\nAli telefonu 3762\nKaan telefonu mevcut değil"
  },
  {
    "objectID": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlüğe-yeni-anahtarlar-eklemek",
    "href": "posts/2018/02/03/python-programlamaya-giris-sozluk-metodlari/index.html#sözlüğe-yeni-anahtarlar-eklemek",
    "title": "Python Programlamaya Giriş 14 - Sözlük Metodları",
    "section": "Sözlüğe yeni anahtarlar eklemek",
    "text": "Sözlüğe yeni anahtarlar eklemek\nBir D sözlüğüne yeni bir anahtar-değer çiftini dinamik olarak kolayca ekleyebiliriz.\n\nD = {}\nD[\"abc\"] = 3\nD\n\n{'abc': 3}\n\n\nBunun başka bir yolu da setdefault metodunu kullanmaktır. Bu metod, get gibi çalışır, mevcut olmayan bir anahtar verildiğinde bir varsayılan değer döndürür. Ama get’ten farklı olarak, verilen yeni anahtarı sözlüğe ekler.\n\nprint(D.get(\"def\",42))\nprint(D) # sözlük eski halinde kalır.\n\n42\n{'abc': 3}\n\n\n\nprint(D.setdefault(\"def\",42))\nprint(D) # sözlüğe \"def\" anahtarı eklendi.\n\n42\n{'abc': 3, 'def': 42}"
  },
  {
    "objectID": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html",
    "href": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html",
    "title": "Python Programlamaya Giriş 16 - Dize Biçimlendirme",
    "section": "",
    "text": "Python Programlamaya Giriş dizimizin bir önceki bölümünde dizelerle yapılabilecek işlemleri ve yaygın dize metodlarını özetledik. Bu yazıda dize metodlarından biri olan format() ile dize biçimlendirmeyi daha ayrıntılı işleyeceğiz. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\nBirçok durumda bir değişkende barındırılan bir değeri uygun bir biçimde düzenleyerek ekrana basmamız gerekir. Bu düzenlemeler ve biçimlendirmeler örneğin şöyle olabilirler: * Bir kalıp dize içindeki boşlukları doldurmak, İsim:...., Yaş:.... gibi. * Sayıları ondalıktan sonra sabit sayıda basamakla vermek: 9.340, -18.731 gibi. * Sayıları sıfırlarla doldurmak: 099.45, 001.12 gibi. * Tablo halinde basılan listeleri hizalı olarak, belli boşluklar ayırarak basmak. * Tablo içeriklerini sağa veya sola yaslamak, ortalamak.\nBu tür düzenlemeler için Python’da kapsamlı bir mini-dil mevcut. Bu tür düzenlemeler, format() metoduyla beraber şu şekilde kullanılır:\nDize biçimlendirmenin bütün ayrıntıları için Python belgelerine bakabilirsiniz."
  },
  {
    "objectID": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#konumla-yerleştirme-ve-isimle-yerleştirme",
    "href": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#konumla-yerleştirme-ve-isimle-yerleştirme",
    "title": "Python Programlamaya Giriş 16 - Dize Biçimlendirme",
    "section": "Konumla yerleştirme ve isimle yerleştirme",
    "text": "Konumla yerleştirme ve isimle yerleştirme\nEn basit kullanımda, format()’a verilen değerler, kalıp dizesinin içinde küme parantezleri ({}) ile bırakılan boşluklara sırayla yerleştirilir.\n\n\"İsim: {}, Telefon: {}, Boy: {} m\".format(\"Kaan\", \"5555\", 1.80)\n\n'İsim: Kaan, Telefon: 5555, Boy: 1.8 m'\n\n\nYukarıdaki örnekte birinci boşluğa birinci değer (\"Kaan\"), ikinci boşluğa ikinci değer (\"5555\"), üçüncü boşluğa da üçüncü değer (1.80) yerleştirildi. Bu sırayı değiştirmek için, küme parantezlerinin içine arzu ettiğimiz konum numaralarını koyabiliriz.\n\n\"İsim: {0}, Boy: {2} m, Telefon: {1}\".format(\"Kaan\", \"5555\", 1.80)\n\n'İsim: Kaan, Boy: 1.8 m, Telefon: 5555'\n\n\nBaşka bir yol da, yer tutuculara isim vermek ve format()’a bu isimlerle parametreler vermektir.\n\n\"Alıcı Adı: {isim}, Yaşı: {yaş}, Şehir: {şehir}\".format(yaş=32, isim=\"Fatma\", şehir=\"Tekirdağ\")\n\n'Alıcı Adı: Fatma, Yaşı: 32, Şehir: Tekirdağ'\n\n\nÖrneklerden gördüğümüz gibi, format() fonksiyonu kalıp dizesindeki boşluklarla değerleri eşleştirirken, fonksiyonlardaki parametre eşleştirme kurallarını kullanıyor. İlk gördüğümüz örnek konumla eşleştirmeye denk iken, son örneğimiz isimle eşleştirme yapıyor.\nBu sebepten, fonksiyon çağrılarındaki parametre çözme kuralları da aynen uygulanabilir. Mesela:\n\np = (\"Kaan\",\"5555\",1.80)\n\"İsim: {}, Telefon: {}, Boy: {} m\".format(*p)\n\n'İsim: Kaan, Telefon: 5555, Boy: 1.8 m'\n\n\nBiraz daha gelişkin bir örnek olarak, önceden hazırlanmış bir veri listesi üzerinden döngü çalıştıralım.\n\nliste = [\n    (\"Kaan\",\"5555\",1.80), \n    (\"Meral\",\"5628\",1.50),\n    (\"Ziya\",\"9879\",1.40)]\nfor p in liste:\n    print(\"İsim: {0}, Boy: {2} m, Telefon: {1}\".format(*p))\n\nİsim: Kaan, Boy: 1.8 m, Telefon: 5555\nİsim: Meral, Boy: 1.5 m, Telefon: 5628\nİsim: Ziya, Boy: 1.4 m, Telefon: 9879\n\n\nVerileri çokuzlar olarak değil de sözlük olarak saklıyor olabiliriz. O zaman sözlüklerde kullandığımız parametre çözme yöntemi geçerli olur.\n\nD = dict(isim=\"Filiz\", yaş=55, şehir=\"İstanbul\")\n\"Alıcı Adı: {isim}, Yaşı: {yaş}, Şehir: {şehir}\".format(**D)\n\n'Alıcı Adı: Filiz, Yaşı: 55, Şehir: İstanbul'\n\n\n\nliste = [\n    {\"isim\": \"Filiz\", \"yaş\":\"55\", \"şehir\":\"İstanbul\"}, \n    {\"isim\": \"Meral\", \"yaş\":\"40\", \"şehir\":\"Ankara\"},\n    {\"isim\": \"Ziya\",  \"yaş\":\"10\", \"şehir\":\"Bursa\"}\n]\nfor D in liste:\n    print(\"Alıcı Adı: {isim}, Yaşı: {yaş}, Şehir: {şehir}\".format(**D))\n\nAlıcı Adı: Filiz, Yaşı: 55, Şehir: İstanbul\nAlıcı Adı: Meral, Yaşı: 40, Şehir: Ankara\nAlıcı Adı: Ziya, Yaşı: 10, Şehir: Bursa\n\n\nformat()’a verilen parametre bir liste veya sözlük ise, kalıp dizesinde indeksleme uygulanabilir.\n\nlistem = [3,6,7,9]\n\"İlk eleman: {0[0]}, son eleman: {0[3]}\".format(listem)\n\n'İlk eleman: 3, son eleman: 9'\n\n\n\nkayıt = {\"isim\":\"Kaan\", \"boy\":1.80, \"telefon\":\"5555\"}\n\"İsim: {D[isim]}, Tel: {D[telefon]}, Boy: {D[boy]}\".format(D=kayıt)\n\n'İsim: Kaan, Tel: 5555, Boy: 1.8'"
  },
  {
    "objectID": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#yana-yaslama-ve-ortalama",
    "href": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#yana-yaslama-ve-ortalama",
    "title": "Python Programlamaya Giriş 16 - Dize Biçimlendirme",
    "section": "Yana yaslama ve ortalama",
    "text": "Yana yaslama ve ortalama\nDizeleri biçimlendirirken, alt alta olan dizelerin belli bir hizada olmasını sağlamak isteyebiliriz. Bunun için, dizenin basılacağı yerde kaç karakterlik alan ayrılacağını belirlememiz, sağa veya sola yaslamamız, veya ortalamamız mümkündür.\nÖnce hizalama yapılmayan bir örnek görelim:\n\nisimler = [\"Ziya\", \"Meral\", \"Hüsamettin\", \"Zebercet\"]\nyaşlar = [9, 32, 45, 28]\nşehirler = [\"İstanbul\", \"Ankara\", \"Van\", \"Diyarbakır\"]\n\nfor i, y, ş in zip(isimler, yaşlar, şehirler):\n    print(\"Alıcı Adı: {}, Yaşı: {}, Şehir: {}\".format(i, y, ş))\n\nAlıcı Adı: Ziya, Yaşı: 9, Şehir: İstanbul\nAlıcı Adı: Meral, Yaşı: 32, Şehir: Ankara\nAlıcı Adı: Hüsamettin, Yaşı: 45, Şehir: Van\nAlıcı Adı: Zebercet, Yaşı: 28, Şehir: Diyarbakır\n\n\nKalıp dizesinde yer tutucuları (mesela) {:10} biçiminde yazmakla 10 karakter genişlikte bir alan ayırmış oluruz. Aksi belirtilmedikçe dizeler sola, sayılar ise sağa yaslanır.\n\nfor i, y, ş in zip(isimler, yaşlar, şehirler):\n    print(\"Alıcı Adı: {:11} Yaşı: {:3} Şehir: {:10}\".format(i, y, ş))\n\nAlıcı Adı: Ziya        Yaşı:   9 Şehir: İstanbul  \nAlıcı Adı: Meral       Yaşı:  32 Şehir: Ankara    \nAlıcı Adı: Hüsamettin  Yaşı:  45 Şehir: Van       \nAlıcı Adı: Zebercet    Yaşı:  28 Şehir: Diyarbakır\n\n\nSola yaslanmış olarak basmak için {:&lt;10}, sağa yaslanmış olarak basmak için {:&gt;10}, ortalanmış olarak basmak içinse {:^10} yazımı kullanırız.\n\nfor i, y, ş in zip(isimler, yaşlar, şehirler):\n    print(\"Alıcı Adı: {:&gt;11} Yaşı: {:&lt;3} Şehir: {:^10}\".format(i, y, ş))\n\nAlıcı Adı:        Ziya Yaşı: 9   Şehir:  İstanbul \nAlıcı Adı:       Meral Yaşı: 32  Şehir:   Ankara  \nAlıcı Adı:  Hüsamettin Yaşı: 45  Şehir:    Van    \nAlıcı Adı:    Zebercet Yaşı: 28  Şehir: Diyarbakır\n\n\nBoş bırakılan yerleri bir karakterle doldurmak istiyorsak, bu karakteri : işaretinden hemen sonra koyarız. Mesela, * işaretiyle doldurmak için:\n\nfor i in isimler:\n    print(\"{:*&gt;11}\".format(i))\n\n*******Ziya\n******Meral\n*Hüsamettin\n***Zebercet\n\n\nYer tutucuları indeksle veya isimle eşleştirmek istediğimizde, iki nokta üstüste işaretinden önce indeksi veya ismi yazarız; {0:10} veya {isim:10} gibi.\n\nfor i, y, ş in zip(isimler, yaşlar, şehirler):\n    print(\"{1:3} yaşındaki {0:11} isimli alıcı {2:10} şehrinde oturuyor.\".format(i, y, ş))\n\n  9 yaşındaki Ziya        isimli alıcı İstanbul   şehrinde oturuyor.\n 32 yaşındaki Meral       isimli alıcı Ankara     şehrinde oturuyor.\n 45 yaşındaki Hüsamettin  isimli alıcı Van        şehrinde oturuyor.\n 28 yaşındaki Zebercet    isimli alıcı Diyarbakır şehrinde oturuyor.\n\n\n\nfor i, y, ş in zip(isimler, yaşlar, şehirler):\n    print(\"{yaş:3} yaşındaki {isim:11} isimli alıcı {şehir:10} şehrinde oturuyor.\".format(isim=i, yaş=y, şehir=ş))\n\n  9 yaşındaki Ziya        isimli alıcı İstanbul   şehrinde oturuyor.\n 32 yaşındaki Meral       isimli alıcı Ankara     şehrinde oturuyor.\n 45 yaşındaki Hüsamettin  isimli alıcı Van        şehrinde oturuyor.\n 28 yaşındaki Zebercet    isimli alıcı Diyarbakır şehrinde oturuyor.\n\n\nGenel olarak, kalıp dizesindeki yer tutucunun içinde : işaretinin solunda eşleştirme bilgisi (indeks veya isim) yer alır; sağında ise o değerin nasıl biçimlendirileceğinin bilgisi bulunur."
  },
  {
    "objectID": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#sayı-biçimlendirme",
    "href": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#sayı-biçimlendirme",
    "title": "Python Programlamaya Giriş 16 - Dize Biçimlendirme",
    "section": "Sayı biçimlendirme",
    "text": "Sayı biçimlendirme\nYer tutucu içine bir sayı koyacağımız zaman, tamsayılarda {:d}, ondalıklı sayılarda ise {:f} kodlarını kullanırız.\n\n\"Yaş: {:d}, Boy: {:f}\".format(42, 1.76) \n\n'Yaş: 42, Boy: 1.760000'\n\n\nBelli miktarda, söz gelişi 5 karakterlik yer ayırmak için {:5d} yazımını kullanabiliriz. Ondalıklı sayılar için {:5.2f} yazımı, noktadan sonra 2 basamak olmak üzere en az 5 karakterlik yer ayrılmasını sağlar (ondalık noktası dahil). Türkçeye uygun olarak virgüllerle ayırma yöntemi için bir sonraki bölüme bakın.\n\n\"Yaş: {:5d}, Boy: {:5.3f}\".format(42, 1.76) \n\n'Yaş:    42, Boy: 1.760'\n\n\nAyırdığımız alanda, sayının değerini değiştirmeden boşlukların sıfırlarla doldurulmasını istiyorsak {:05d} veya {05.3f} gibi yazımlar kullanırız.\n\n\"Yaş: {:05d}, Boy: {:06.3f}\".format(42, 1.76) \n\n'Yaş: 00042, Boy: 01.760'\n\n\nNegatif sayıların başına her zaman eksi gelir; pozitif sayıların da her zaman artı ile başlaması için {:+d} yazımını kullanırız.\n\n\"{:+d}, {:+d}\".format(42, -45)\n\n'+42, -45'\n\n\nBir sayıyı ikili, sekizli, onaltılı tabanda göstermek için sırasıyla b, o, x kullanırız.\n\nprint(\"Onluk tabanda {:d}\\nİkili tabanda {:b}\\nSekizli tabanda {:o}\\nOnaltılı tabanda {:x}\".format(42,42,42,42))\n\nOnluk tabanda 42\nİkili tabanda 101010\nSekizli tabanda 52\nOnaltılı tabanda 2a\n\n\nBu dönüşümleri yapınca sayının tabanının da belli olmasını istersek #b, #o, #x kullanırız. Bu kodlar sayının başına sırasıyla \"0b\", \"0o\", \"0x\" konmasını sağlar.\n\nprint(\"Onluk tabanda {:d}\\nİkili tabanda {:#b}\\nSekizli tabanda {:#o}\\nOnaltılı tabanda {:#x}\".format(42,42,42,42))\n\nOnluk tabanda 42\nİkili tabanda 0b101010\nSekizli tabanda 0o52\nOnaltılı tabanda 0x2a\n\n\nBüyük sayıları virgülle üçer basamaklı ayırmak için {:,} kullanırız (Türkçeye uygun olarak noktalarla ayırmak için sonraki bölüme bakın).\n\n\"{:,}\".format(123456789)\n\n'123,456,789'\n\n\nOndalıklı sayıları göstermek için şu kodlar kullanılabilir: * {:f} veya {:F} (fixed): Ondalıktan sonra sabit sayıda basamak (varsayılan 6). * {:e} veya {:E} (exponential): Sayıyı bilimsel notasyonda gösterir; üsteli \"e\" veya \"E\" harfinden sonra koyar. * {:g} veya {:G} (genel): Yerine göre f veya e. Belirli bir basamak sayısını (varsayılan 6) verecek şekilde yuvarlar; sayının büyüklüğüne göre f veya e biçimine getirir. * {:%}: Sayıyı 100 ile çarpar ve sonuna yüzde işareti koyar.\n\nx = 12345.6789\nprint(\"Sabit biçim: {:f}, {:F}\".format(x,x))\nprint(\"Üstel biçim: {:e}, {:E}\".format(x,x))\nprint(\"Genel biçim: {:g}, {:G}\".format(x,x))\n\nSabit biçim: 12345.678900, 12345.678900\nÜstel biçim: 1.234568e+04, 1.234568E+04\nGenel biçim: 12345.7, 12345.7\n\n\n\nx = 12345.6789\nprint(\"Sabit biçim: {:4.2f}, {:4.4F}\".format(x,x))\nprint(\"Üstel biçim: {:1.3e}, {:1.4E}\".format(x,x))\nprint(\"Genel biçim: {:.10g}, {:.2G}\".format(x,x))\n\nSabit biçim: 12345.68, 12345.6789\nÜstel biçim: 1.235e+04, 1.2346E+04\nGenel biçim: 12345.6789, 1.2E+04\n\n\nYüzdeleri gösterirken % kodunu kullanabiliriz.\n\ngeçen = 57\nbaşvuran = 245\n\"Başarı oranı {:.2%}\".format(geçen/başvuran)\n\n'Başarı oranı 23.27%'"
  },
  {
    "objectID": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#sayıları-türk-standartlarında-biçimlendirmek",
    "href": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#sayıları-türk-standartlarında-biçimlendirmek",
    "title": "Python Programlamaya Giriş 16 - Dize Biçimlendirme",
    "section": "Sayıları Türk standartlarında biçimlendirmek",
    "text": "Sayıları Türk standartlarında biçimlendirmek\nYukarıdaki örneklerde, Amerikan standardına uygun olarak, sayı grupları virgülle ayrıldı ve ondalık için nokta kullanıldı. Oysa Türkiye’deki sayı yazma standartlarında sayı grupları noktayla ayrılır, ondalık için ise virgül kullanılır. Türk standartlarına uygun biçimlendirme yapmak için biraz dolaylı bir yoldan gidip, yerelleştirme işlemleri için kullanılan locale kütüphanesini kullanmamız gerekir.\n\nimport locale\nloc = locale.getlocale()\nlocale.setlocale(locale.LC_ALL,\"tr_TR.UTF-8\")\n\n'tr_TR.UTF-8'\n\n\nYerelleştirme ayarlarını yapsak da, bu ayarlar str.format metodunu etkilemeyecektir. Bunun yerine, locale.format fonksiyonunu kullanmalıyız. Bu fonksiyonun dize biçimleme sintaksı eski usül olarak bilinir. Basit bir örnek olarak:\n\nlocale.format(\"%f\", 1234567.89, grouping=True)\n\n'1.234.567,890000'\n\n\nŞimdi de virgülden sonra 3 hane olmak üzere toplam 13 karakterlik yer ayırarak biçimlendirelim.\n\nlocale.format(\"%013.3f\", 1234567.89, grouping=True)\n\n'001.234.567,890'\n\n\nlocale.format() sadece bir tek biçim dizesi alır (%f veya %d gibi). Daha geniş bir kalıp kullanmak için locale.format_string() fonksiyonunu kullanmamız gerekir.\n\nisimler = [\"Ziya\", \"Meral\", \"Hüsamettin\", \"Zebercet\"]\nboylar = [1.42, 1.50, 1.74, 1.81]\nmaaşlar = [100.73, 5555.62, 12446.43, 2300.12]\n\nfor i, b, m in zip(isimler, boylar, maaşlar):\n    print(locale.format_string(\"İsim: %-12s Boy: %6.2f Maaş: %10.2f\", (i,b,m), grouping=True))\n\nİsim: Ziya         Boy:   1,42 Maaş:     100,73\nİsim: Meral        Boy:   1,50 Maaş:   5.555,62\nİsim: Hüsamettin   Boy:   1,74 Maaş:  12.446,43\nİsim: Zebercet     Boy:   1,81 Maaş:   2.300,12\n\n\nNe yazık ki locale.format_string() sadece daha sınırlı olan eski usül biçimlendirme sintaksıyla çalışıyor. Yine de, ileri Python sürümlerinde yeni usule geçilmesi muhtemeldir.\nSayıların biçimlerini yerelleştirmeyi, son kullanıma yönelik raporlar üretme amacıyla sınırlı tutmanız iyi olur. Bu amaç dışında, mesela veriler bir dosyaya yazıp sonradan okumayı hedefliyorsanız yerel ayarları değil varsayılan ayarları (Amerikan standardını) kullanın. Dosyadaki verilerde, söz gelişi, ondalıklar virgülle ayrılmışsa, sonradan veri dosyasını okumakta sorunlar yaşayabilirsiniz. Yazılım paketlerindeki otomatik araçların çoğu Amerikan tarzı sayı yazımını temel alır. Bunun etrafından dolaşmak mümkündür ama hem dolambaçlıdır hem de sorunlara gebedir."
  },
  {
    "objectID": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#nesne-içi-değişkenleri-kullanmak",
    "href": "posts/2018/02/23/python-programlamaya-giris-16-dize-bicimlendirme/index.html#nesne-içi-değişkenleri-kullanmak",
    "title": "Python Programlamaya Giriş 16 - Dize Biçimlendirme",
    "section": "Nesne içi değişkenleri kullanmak",
    "text": "Nesne içi değişkenleri kullanmak\nNesnelerin iç değişkenleri (“attributes”) kalıp dizede kullanılabilir. Örneğin, karmaşık sayıların gerçek kısımları real, sanal kısımları imag isimli iç değişkenlerde saklanır.\n\nz = 3+2j\nz.real, z.imag\n\n(3.0, 2.0)\n\n\nDize biçimlendirmede bu iç değişkenlerin isimlerini doğrudan kullanabiliriz.\n\n\"Gerçek kısım {0.real}, sanal kısım {0.imag}\".format(3+2j)\n\n'Gerçek kısım 3.0, sanal kısım 2.0'"
  },
  {
    "objectID": "posts/2017/11/03/yeni-baslayanlar-icin-veri-kumeleri-cicekler-bebekler-filmler/index.html",
    "href": "posts/2017/11/03/yeni-baslayanlar-icin-veri-kumeleri-cicekler-bebekler-filmler/index.html",
    "title": "Yeni başlayanlar için veri kümeleri : Çiçekler, bebekler, filmler",
    "section": "",
    "text": "Veri analizine yeni başladınız diyelim. Gayretlisiniz, R, Python, pandas, SQL, ne bulursanız öğrenmeye çalışıyorsunuz. Malum, en iyi öğrenme yaparak öğrenmedir. Oysa okuduğunuz kitaplar veya ders malzemelerindeki veriler ya çok basit, ya da çok yapay. Bazı veri tabanları ise dişinizi geçiremeyeceğiniz kadar büyük ve karmaşık. Size gereken, ne çok küçük ve basit, ne de alelade bir laptopla işlenemeyecek kadar büyük bir veri kümesi.\nBu yazıda, kolayca indirebileceğiniz, “temiz”, veri işlemeye başlangıç seviyesinde kullanabileceğiniz birkaç veri kümesini listeleyeceğiz.\n\nSüsen çiçeği türleri \nÜnlü istatistikçi R.A. Fisher’in 1938’de yayınladığı bir makalesinden alınan küçük bir veri kümesi. Süsen (iris) çiçeğinin üç türünden alınan 50’şer numunenin çiçek ve taç yapraklarının uzunluk ve genişliklerinin ölçümlerini barındırıyor. Klasik, temel ders kitabı örneği olan bir veri kümesidir. Veri görselleme ve sınıflandırma işlemlerinde kullanabilirsiniz.\n\nTitanic yolcu listesi\nKara talihli Titanic’in ilk ve son seferindeki yolcu listesi. İsimler, ünvanlar, yaş, cinsiyet, hangi mevkide seyahat ediyor, eşi, çocukları, kardeşi yanında mı? Hayatta kalmış mı?\nVeri düzenleme, gruplandırma, ve tahmin için kullanabilirsiniz.\n\nMNIST el yazısı rakamlar\nHer biri 28x28 pikselden oluşan, gri tonlarında el yazısı rakamlar. 250 kişiden alınan toplam 60.000 numune mevcut. Bir veri satırının ilk sütununda resimde gösterilen rakam, kalan 784 sütunda ise piksellerin satır satır yanyana konmuş halde gri tonlarının sayı değerleri var.\nGüdümlü öğrenme ve tahmin algoritmalarında ilk adım olan bir veri kümesidir.\n\nABD bebek isimleri\nABD’de 1880’den başlayarak günümüze kadar, yeni doğanlar için yapılan sosyal güvenlik kartı başvurularından derlenen isimlerin sayımı. Veri kümesinin içinde her bir yıl için ayrı bir dosyada, o yıl doğan çocuklara verilen isimler, çocuğun cinsiyeti, ve her bir ismin kaç kere verildiği yazılı.\nÇoklu dosyalardan veri derlemek, zamanda değişimleri görsellemek, verileri filtrelemek, trendleri incelemek için uygun.\n\nDepremler\nKandilli Rasathanesi’nin web sitesindeki form arayüzüyle istediğiniz tarih aralığında, istediğiniz enlem ve boylamlar içindeki sismik hareketlerin dökümünü alabilirsiniz. Depremlerin zaman ve mekandaki dağılımlarını görselleyebilir, Gutenberg-Richter yasasını teyit edebilirsiniz.\n\nParolalar\nÇeşitli kaynaklardan sızdırılmış ve halka açık hale gelmiş parolaların listesi. Dosyada 2 milyon tekil parola mevcut. Parolaların yapısını inceleyebilir, harf-rakam-işaret dağılımına bakabilirsiniz. Metin işleme çalışmaları için uygun.\n\nMovielens film puanlama\nMovielens film değerlendirme sitesine gelen kullanıcıların istedikleri filmlere verdiği puanlamaları içeren bir veri kümesi. Ana küme sürekli büyümekte; ama araştırma amaçları için sabit olarak tutulan bazı alt kümeler de var. 1000 kullanıcının 1700 filme verdiği 100.000 ayrı puanı içeren “100k” kümesiyle başlayabilirsiniz. Filmlerin bilgileri ile kullanıcıların demografik verilerini birleştirerek ilginç bağlantılar yakalayabilir, bir tavsiye sistemi oluşturmak üzerinde çalışabilirsiniz.\n\nElektrik sarfiyatı\nBir evin dört yıl harcadığı elektriğin dakika dakika kaydedildiği iki milyon satırlık bir veri dosyası. Bütün evde kullanılan anlık gücün yanında, ayrı odalarda tüketilen enerji de kaydedilmiş. Boş kalmış satırlar da var. Büyükçe bir veri dosyasını işlemenin inceliklerini keşfedebilir, zaman serisini analiz etmek, saatlik/günlük/haftalık/mevsimlik değişimleri görmek gibi işlemler yapabilirsiniz.\nGelir seviyesi\n1994 ABD nüfus sayımı verisi içinden alınmış, gelir seviyesi tahmini için kullanılan bir veri kümesi. 50.000’e yakın yetişkinin demografik bilgilerini, ve gelirlerinin 50.000$ üzerinde olup olmadığının bilgisini içeriyor. Veri analizi, gruplandırma, güdümlü öğrenme işlemleri için kullanılabilir."
  },
  {
    "objectID": "posts/2017/11/07/asiri-ogrenme-ve-eksik-ogrenme/index.html",
    "href": "posts/2017/11/07/asiri-ogrenme-ve-eksik-ogrenme/index.html",
    "title": "Aşırı Öğrenme ve Eksik Öğrenme",
    "section": "",
    "text": "Makine öğrenmesi uygulamalarında temel amaç eldeki veriden örüntüler öğrenmek, bu örüntüleri kullanarak değer oluşturmaktır. Örnek olarak müşterilerin özelliklerine bakarak terk edecek ya da kampanyanızdan yararlanacak müşterileri tahmin etmeye çalışabilirsiniz. Bir tavsiye sistemi kurarak müşterilerinize ilgilenecekleri ürünleri önermeye çalışabilirsiniz. Ya da bir bölgedeki evlerin özelliklerine ve fiyatlarına bakarak ilgilendiğiniz evin fiyatının düşük ya da yüksek olup olmadığını yorumlamak isteyebilirsiniz. Bulacağınız örüntüler gerçek hakkında size ipucu verecek modellere denk geliyor. Gerçeği tam olarak tahmin etmeniz imkansız olsa da model kurarken kaçınmanız gereken iki hata tipi var. Bu Veri Defteri’nde Aşırı Öğrenme (overfitting) ve Eksik Öğrenme (underfitting) kavramlarından bahsedeceğiz.\n\nEksik Öğrenme: Modelin gözlemlerdeki örüntüyü eksik yakalaması durumuna denir. Örnek olarak karekök fonksiyonunu ya da ikinci dereceden bir denklemi bir doğru ile yakınsamayı gösterebiliriz.\nAşırı Öğrenme: Modelin örüntüler yerine gözlemleri öğrenmeye başlamasıdır. Bu durumda öğrenme için kullandığınız veri setini öğrenirsiniz. Ancak bu şekilde oluşturacağınız modeller yeni ve daha önceden görmediğiniz gözlemlerle karşılaştığında başarılı bir tahmin yapma olasılığınızı azaltır.\n\nBu kavramlara bir kaç örnekle bakmayı deneyelim. İlk olarak kullanacağımız paketleri yükleyelim.\n\n%matplotlib inline\n# Aşağıdaki iki satır uyarı mesajlarını kapatmaya yarıyor\nimport warnings\nwarnings.simplefilter(\"ignore\")\n\nfrom IPython.display import display, HTML\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#Veri setini bölmek için\nfrom sklearn.model_selection import train_test_split\n\n#Kullanacağımız doğrusal bağlanım (linear regression) ve gradient boosting yöntemleri\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import GradientBoostingClassifier\n\n#Yapay sınıflandırma verisi oluşturmak için gerekli bir fonksiyon\nfrom sklearn.datasets import make_classification\n\n#Sonuçları değerlendirmek için gerekli fonksiyonlar\nfrom sklearn.metrics import mean_squared_error, accuracy_score\n\n#Veriyi istediğimiz dereceden değişkenlerden oluşturmak için PolynomialFeatures kullanacağız.\nfrom sklearn.preprocessing import PolynomialFeatures\n\nKavramları göstermek için yapay bir veri seti oluşturalım. Çıktı ile girdi arasında doğrusal bir ilişki kurduğum için doğrusal bağlanım yöntemiyle bu veri setindeki örüntüyü öğrenmeye çalışacağız. İlk olarak 75 gözlemden oluşan bir yapay veri seti oluşturalım. train_test_split() fonksiyonu veriyi öğrenme (training) ve sınama (testing) için iki kümeye ayıracak.\nKuracağımız ilişki \\(y = 2.5 x + \\epsilon\\) şeklinde olacak. Burada en sondaki terim rassal olarak eklediğimiz bir gürültüye (noise) denk geliyor.\n\nnum_obs = 75\n#Random seed her bilgisayarda aynı sonucu elde etmek için kullanılan bir fonksiyon. \n#Ancak versiyon değişiklikleri gibi nedenlerle farklı sonuçlar elde edebilirsiniz.\n\nnp.random.seed(1)\nX = np.random.rand(num_obs)*10\ny = 2.5 * X + np.random.randn(num_obs)*2\n\n#Veriyi %80 öğrenme ve %20 sınama şeklinde ikiye ayırıyoruz.\nX_train, X_test, y_train, y_test = train_test_split(X,y, train_size = 0.8, random_state = 0)\n\nÖrüntüyü görmek için bir serpme (scatter) grafiği kullanalım.\n\nplt.figure(figsize=(8,8))\nplt.scatter(X_train,y_train)\nplt.show()\n\n\n\n\nGördüğümüz gibi veri setinde girdi ve çıktı arasında doğrusal bir ilişki var. x değeri bir birim arttığında y değişkeninin değeri yaklaşık olarak 2.5 birim artıyor. Bir doğrusal bağlanım (linear regression) modeliyle bu ilişkiyle ilgili bilgileri elde edebiliriz. Bu amaçla LinearRegression() fonksiyonunu kullanacağız.\n\n#Modeli oluşturalım.\nlr = LinearRegression()\n#X_train ve y_train değerleriyle modeli eğitelim. \n#.reshape(-1,1) kısmı tek boyutlu değişkenlerle çalıştığımız için gerekli olan bir fonksiyon.\nlr.fit(X_train.reshape(-1,1),y_train.reshape(-1,1))\nprint(\"Kesişim (Intercept): \" + str(lr.intercept_))\nprint(\"Eğim (Slope): \" + str(lr.coef_[0]))\n\nKesişim (Intercept): [0.82241911]\nEğim (Slope): [2.43747185]\n\n\nModele göre x değişkeninin değeri bir birim arttığı zaman y değişkeninin değeri 2.44 birim artıyor. Bu da bizim oluşturduğumuz örüntüye (2.5x) oldukça yakın bir değer. x değeri sıfıra eşit olduğunda ise y değeri 0.82 oluyor. Bu bilgiyi test edeceğimiz veri setinde kullanarak sonuçları değerlendirebiliriz.\nAşağıdaki şekilde mavi noktalar öğrenme verisini, kırmızı noktalar sınama verisini ve yeşil çizgi de elde ettiğimiz modelin çıktısını temsil ediyor.\n\n#0 ile 10 arasındaki değerler için modelin sonuçlarını elde edelim.\nline_X = np.arange(0,11, 0.1)\nline_y = lr.predict(line_X.reshape(-1,1))\n\nplt.figure(figsize=(8,8))\nplt.scatter(X_train,y_train, alpha = 0.5, label = 'Öğrenme')\nplt.scatter(X_test, y_test, c='red', alpha = 0.7, label = 'Sınama')\nplt.plot(line_X, line_y, c='green', linewidth=3, alpha=0.6, label = 'Doğrusal Bağlanım')\nplt.legend(loc = 4)\nplt.show()\n\n\n\n\nGördüğümüz gibi doğrusal bağlanım sınama verisini başarıyla tahmin edebiliyor.\nAşırı Öğrenme ve Eksik Öğrenme kavramlarını anlatmak için veride doğrusal olmayan bir ilişki oluşturalım. Kullanacağımız yeni modelde ilişkiyi bu şekilde değiştiriyoruz: \\(y' = y + 80 y^2 - 4 y^3\\). Ben doğrusal olmayan örüntüyü daha belirgin hale getirmek için yeni çıktıları hesaplarken eski çıktı değerlerini kullanmayı tercih ettim.\n\ny_train = y_train +  80* np.power(y_train, 2) - 4 * np.power(y_train, 3)\ny_test = X_test +  80* np.power(y_test, 2) - 4 * np.power(y_test, 3) \n\nTekrar bir doğrusal bağlanımla modelin öğrenme yeteneğini inceleyelim. Öğrenme yeteneğini daha objektif bir şekilde incelemek için de karesel ortalama hatanın kareköküne (root mean square error, RMSE) bakacağız. Karesel ortalama hata hesaplanırken gözlemin gerçek değeriyle model sonucu elde edilen tahmin arasındaki farkların karelerinin ortalaması alınır ve bu değerin karekökü hesaplanır. Bu şekilde tahmin ettiğimiz değerlerle gerçek gözlemlerin birbirinden ne kadar uzak olduğu bilgisi elde edilir. Kabaca bu değerin düşük olması modelin tahmin yeteneğinin güçlü olduğunu işaret eder diyebiliriz.\n\n#Modeli oluşturuyoruz.\nlr = LinearRegression()\n#X ve y değerleriyle modelin öğrenmesini sağlıyoruz.\nlr.fit(X_train.reshape(-1,1),y_train)\n#Modelin sonucunu görmek için 0 ve 10 aralığında tahmin yapıyoruz.\nline_y = lr.predict(line_X.reshape(-1,1))\n\n\nprint(\"Öğrenme verisinde karesel ortalama hata (Root Mean Square Error, RMSE): \" \n      + str(np.sqrt(mean_squared_error(y_train, lr.predict(X_train.reshape(-1,1))))))\nprint(\"Sınama verisinde karesel ortalama hata (Root Mean Square Error, RMSE): \" \n      + str(np.sqrt(mean_squared_error(y_test, lr.predict(X_test.reshape(-1,1))))))\n\nplt.figure(figsize=(8,8))\nplt.scatter(X_train,y_train, alpha = 0.3)\nplt.scatter(X_test, y_test, c='red', alpha = 0.7)\nplt.plot(line_X, line_y, c='green', linewidth=3)\nplt.ylim((-30000, 10000))\nplt.show()\n\nÖğrenme verisinde karesel ortalama hata (Root Mean Square Error, RMSE): 5204.605138576858\nSınama verisinde karesel ortalama hata (Root Mean Square Error, RMSE): 4694.645928019619\n\n\n\n\n\nDoğrusal bağlanım tek bir değişkenle üçüncü dereceden bir denklemi öğrenemedi. İkinci ve üçüncü dereceden değişkenler eklersek modelin öğrenme yeteneği artacaktır. Bu değişkenleri eklemek için PolynomialFeatures() fonksiyonunu kullanıyoruz. Öncelikle ikinci dereceden değişkenler oluşturalım.\n\n# Degree değerini iki yaparak x ve x^2 değişkenlerini modele ekliyoruz.\npf = PolynomialFeatures(degree=2, include_bias=False)\n\n#Polynomial features fit/transform fonksiyonlarını kullanıyor.\nX_train_new = pf.fit_transform(X_train.reshape(-1,1))\nX_test_new = pf.transform(X_test.reshape(-1,1))\n#0 ve 10 değerleri arasında bağlanım değerlerini çizdirmek için kullanacağız.\nline_X_new = pf.transform(line_X.reshape(-1,1))\n\n#Modeli oluşturup öğrenmesini sağlıyoruz.\nlr = LinearRegression()\nlr.fit(X_train_new,y_train)\nprint(\"Öğrenme verisinde karesel ortalama hata (Root Mean Square Error, RMSE): \" \n      + str(np.sqrt(mean_squared_error(y_train, lr.predict(X_train_new)))))\nprint(\"Sınama verisinde karesel ortalama hata (Root Mean Square Error, RMSE): \" \n      + str(np.sqrt(mean_squared_error(y_test, lr.predict(X_test_new)))))\n\n#0 ve 10 değerleri arasında bağlanım değerlerini çizdirmek için kullanacağız.\nline_y = lr.predict(line_X_new)\n\n\nplt.figure(figsize=(8,8))\nplt.scatter(X_train,y_train, alpha = 0.3)\nplt.scatter(X_test, y_test, c='red', alpha = 0.7)\nplt.plot(line_X, line_y, c='green', linewidth=3)\nplt.ylim((-30000, 10000))\nplt.show()\n\nÖğrenme verisinde karesel ortalama hata (Root Mean Square Error, RMSE): 3414.8825409044716\nSınama verisinde karesel ortalama hata (Root Mean Square Error, RMSE): 2199.330416057473\n\n\n\n\n\nİkinci dereceden değişkenler sayesinde hem öğrenme hem de sınama veri setinde hatayı azaltmayı başardık. Ancak örüntüyü tam olarak yakalayamadığımız da açık. Şimdi bir de üçüncü dereceden değişkenleri deneyelim.\n\n# Degree değerini üç yaparak x, x^2 ve x^3 değişkenlerini modele ekliyoruz.\npf = PolynomialFeatures(degree=3, include_bias=False)\n\n#Polynomial features fit/transform fonksiyonlarını kullanıyor.\nX_train_new = pf.fit_transform(X_train.reshape(-1,1))\nX_test_new = pf.transform(X_test.reshape(-1,1))\n#0 ve 10 değerleri arasında bağlanım değerlerini çizdirmek için kullanacağız.\nline_X_new = pf.transform(line_X.reshape(-1,1))\n\n#Modeli oluşturup öğrenmesini sağlıyoruz.\nlr = LinearRegression()\nlr.fit(X_train_new,y_train)\nprint(\"Öğrenme verisinde karesel ortalama hata (Root Mean Square Error, RMSE): \" \n      + str(np.sqrt(mean_squared_error(y_train, lr.predict(X_train_new)))))\nprint(\"Sınama verisinde karesel ortalama hata (Root Mean Square Error, RMSE): \" \n      + str(np.sqrt(mean_squared_error(y_test, lr.predict(X_test_new)))))\n\n#0 ve 10 değerleri arasında bağlanım değerlerini çizdirmek için kullanacağız.\nline_y = lr.predict(line_X_new)\n\n\nplt.figure(figsize=(8,8))\nplt.scatter(X_train,y_train, alpha = 0.3)\nplt.scatter(X_test, y_test, c='red', alpha = 0.7)\nplt.plot(line_X, line_y, c='green', linewidth=3)\nplt.ylim((-30000, 10000))\nplt.show()\n\nÖğrenme verisinde karesel ortalama hata (Root Mean Square Error, RMSE): 2751.4685999151775\nSınama verisinde karesel ortalama hata (Root Mean Square Error, RMSE): 1238.2399802882837\n\n\n\n\n\nHatayı azaltmayı başardık. Değişken sayısını arttırırsak daha iyi sonuçlar elde edeceğiz gibi duruyor. Belki de on beşinci dereceden değişkenleri modele ekleyerek daha iyi bir sonuç elde edebiliriz.\n\n# Degree değerini on beş yapıyoruz.\npf = PolynomialFeatures(degree=15, include_bias=False)\n\n#Polynomial features fit/transform fonksiyonlarını kullanıyor.\nX_train_new = pf.fit_transform(X_train.reshape(-1,1))\nX_test_new = pf.transform(X_test.reshape(-1,1))\n#0 ve 10 değerleri arasında bağlanım değerlerini çizdirmek için kullanacağız.\nline_X_new = pf.transform(line_X.reshape(-1,1))\n\n#Modeli oluşturup öğrenmesini sağlıyoruz.\nlr = LinearRegression()\nlr.fit(X_train_new,y_train)\nprint(\"Öğrenme verisinde karesel ortalama hata (Root Mean Square Error, RMSE): \" \n      + str(np.sqrt(mean_squared_error(y_train, lr.predict(X_train_new)))))\nprint(\"Sınama verisinde karesel ortalama hata (Root Mean Square Error, RMSE): \" \n      + str(np.sqrt(mean_squared_error(y_test, lr.predict(X_test_new)))))\n\n#0 ve 10 değerleri arasında bağlanım değerlerini çizdirmek için kullanacağız.\nline_y = lr.predict(line_X_new)\n\n\nplt.figure(figsize=(8,8))\nplt.scatter(X_train,y_train, alpha = 0.3)\nplt.scatter(X_test, y_test, c='red', alpha = 0.7)\nplt.plot(line_X, line_y, c='green', linewidth=3)\nplt.ylim((-30000, 10000))\nplt.show()\n\nÖğrenme verisinde karesel ortalama hata (Root Mean Square Error, RMSE): 2194.1279169602035\nSınama verisinde karesel ortalama hata (Root Mean Square Error, RMSE): 13654.583865130366\n\n\n\n\n\nŞekilde gördüğümüz gibi model veriyi çok başarılı bir şekilde öğrenmeyi başardı. Öğrenme verisindeki hata da düşmüş durumda. Ama aynı şeyi sınama verisi için söyleyemeyiz. Sınama verisinde hatanın tam tersine arttığını görüyoruz. Şimdi PolynomialFeatures altındaki degree (derece) değişkeninin birden 15’e çıkararak her bir değer için hataların durumuna bakalım.\n\n#Karesel Ortalama Hata değerleri, öğrenme ve sınama veri setleri için\nscore_train = np.zeros(16)\nscore_test = np.zeros(16)\n\n#1 ile 15 arasında dereceyi değiştirerek sonuçları tutuyoruz.\nfor i in range(1,16):\n    pf = PolynomialFeatures(degree=i, include_bias=False)\n    X_train_new = pf.fit_transform(X_train.reshape(-1,1))\n    X_test_new = pf.transform(X_test.reshape(-1,1))\n    lr = LinearRegression()\n    lr.fit(X_train_new,y_train)\n    score_train[i] = np.sqrt(mean_squared_error(y_train, lr.predict(X_train_new)))\n    score_test[i] = np.sqrt(mean_squared_error(y_test, lr.predict(X_test_new)))\n\n#Sonuçları daha güzel çizmek için ilk değeri boş bırakıyoruz\nscore_test[0] = np.nan\nscore_train[0] = np.nan\n\nplt.figure(figsize=(10,5))\nplt.plot(score_train, color = 'blue', label = 'Öğrenme')\nplt.plot(score_test, color = 'red', label = 'Sınama')\nplt.xlabel('Derece')\nplt.ylabel('RMSE')\nplt.legend()\nplt.show()\n\n\n\n\nGördüğümüz gibi PolynomialFeatures altındaki derece sayısını arttırdıkça öğrenme veri setini daha iyi öğreniyoruz. Ancak öğrendiğimiz örüntüler sınama verisinde işimize yaramıyor. Üçüncü dereceden itibaren hata artıyor. Dokuzuncu derecedeki düşüş de muhtemelen bir örüntüden çok şansla ilgili.\nAşırı Öğrenme ve Eksik Öğrenme sınıflandırma problemlerinde de karşımıza çıkabilecek bir durum. Bunu da yine yapay bir veri seti üzerinde inceleyelim. Bu amaçla scikit-learn altındaki make_classification() fonksiyonunu kullanacağız.\nÖğrenme algoritması olarak GradientBoostingClassifier() yöntemini seçtik. Bu yöntem iterasyonlarla ilerleyen bir yöntem. Her iterasyonda bir önceki iterasyonun hatalarını düzeltmeyi amaçlıyor. İterasyon sayısının öğrenme yeteneğindeki etkisine bakalım. Değerlendirme için isabetlilik (accuracy) değerine bakacağız. Bu da modelin yaptığı doğru tahminin yüzdesine denk geliyor.\n\n# 3000 örnek ve 100 öznitelikten oluşan bir veri seti oluşturuyoruz. \n# flip_y değeri sayesinde etiketlerin %25'inin değerini değiştiriyoruz. Bu sayede daha zor bir problem elde edeceğiz.\nX,y = make_classification(n_samples = 3000, n_features=100, flip_y = 0.25, random_state= 100 )\n\n#Veriyi öğrenme ve sınama veri setlerine ayırıyoruz.\nX_train, X_test, y_train, y_test = train_test_split(X,y,train_size = 0.80, random_state = 100)\n\n#Öğrenme için iteratif bir yöntem olan GradientBoosting'i kullanacağız.\n#İterasyon sayısını az tuttuğumuzda yeterince öğrenememe, fazla tuttuğumuzda ise ezberleme durumu ortaya çıkabilir.\n#200 iterasyon kullanarak modeli ouşturup öğrenmesini sağlayalım.\n#Modelin performansını değerlendirmek için doğru tahmin yüzdesini (accuracy) kullanacağız.\nclf = GradientBoostingClassifier(n_estimators = 200, random_state= 0 )\nclf.fit(X_train, y_train)\n\nprint('Öğrenme versinde isabetlilik: ' + str(accuracy_score(clf.predict(X_train),y_train)))\nprint('Sınama verisinde isabetlilik: ' + str(accuracy_score(clf.predict(X_test),y_test)))\n\nÖğrenme versinde isabetlilik: 0.935\nSınama verisinde isabetlilik: 0.8066666666666666\n\n\nGördüğümüz gibi öğrenme verisinde isabetlilik gayet yüksekken, sınama verisinde bu değer daha düşük. Bu normal bir durum olsa da aradaki fark aşırı öğrenmeye işaret ediyor olabilir. Şimdi bir de her iterasyonda ne olduğunu inceleyelim.\n\n# İsabetlilik değerlerini içeren diziler\nscore_test = np.zeros((200,), dtype=np.float64)\nscore_train = np.zeros((200,), dtype=np.float64)\n\n#İsabetlilik değerlerini dolduruyoruz. Staged_predict fonksiyonu her iterasyonun sonuçlarını döndürmek için kullanılıyor.\nfor i, y_pred in enumerate(clf.staged_predict(X_test)):\n    score_test[i] = accuracy_score(y_test, y_pred)\n\nfor i, y_pred in enumerate(clf.staged_predict(X_train)):\n    score_train[i] = accuracy_score(y_train, y_pred)\n\n\nprint('Enbüyük isabetlilik değeri: ' + str(score_test.max()) )\nprint('Enbüyük isabetlilik değerinin elde edildiği iterasyon: ' + str(score_test.argmax()) )\n\nplt.figure(figsize = (10,5))\nplt.plot(score_train, label='Öğrenme', c= 'blue')\nplt.plot(score_test, label='Sınama', c = 'red')\nplt.ylim((0.8,0.95))\nplt.xlabel('İterasyon')\nplt.ylabel('İsabetlilik')\nplt.legend(loc=5)\nplt.show()\n\nEnbüyük isabetlilik değeri: 0.8166666666666667\nEnbüyük isabetlilik değerinin elde edildiği iterasyon: 46\n\n\n\n\n\nGördüğümüz gibi öğrenme verisinde hatamız gitgide düşüyor. Muhtemelen iterasyon sayısını arttırırsak öğrenme verisini tamamen doğru bir şekilde öğrenebileceğiz. Gerçi buna öğrenmek yerine ezberlemek demek daha doğru. Sınama verisinde en iyi isabetliliği 46. iterasyonda elde ediyoruz. Bu iterasyondan önce ve sonra isabetlilik değerleri daha düşük. Öncesinde veriyi öğrendiğimizi (underfitting) sonrasında ise ezberlediğimizi (overfitting) söyleyebiliriz. Bu örnekte fark küçük de olsa gerçek uygulamalarda bu dengeyi başarılı bir şekilde tutturmak projenizin başarısını belirleyen faktör olabilir.\nBu Veri Defteri’ni github dizininde bulabilirsiniz."
  },
  {
    "objectID": "posts/2017/11/17/algoritmalara_guvenebilir_miyiz.html",
    "href": "posts/2017/11/17/algoritmalara_guvenebilir_miyiz.html",
    "title": "Muhabbet Teorisi - Algoritmalara güvenebilir miyiz?",
    "section": "",
    "text": "Geçtiğimiz Salı akşamı, haftalık Muhabbet Teorisi cep yayınının 91. bölümünde İlker Birbil ve Kaan Öztürk yapay öğrenme algoritmalarını konuştu. Yapay zeka ve öğrenme algoritmalarının şeffaflığı ve anlaşılabilirliği, hukuki sonuçları olan kararları verirken “kara kutu” algoritmalar kullanmanın ne kadar uygun olduğu, yapay öğrenme insanları devreden çıkarabilir mi gibi konular üzerinde tartıştılar.\nMUHABBET TEORİSİ #91: ALGORİTMALARA GÜVENEBİLİR MİYİZ? cepyayınını Açık Bilim sitesinden dinleyebilirsiniz."
  },
  {
    "objectID": "posts/2017/10/30/jupyter-notebook-nedir/index.html",
    "href": "posts/2017/10/30/jupyter-notebook-nedir/index.html",
    "title": "Jupyter Notebook nedir?",
    "section": "",
    "text": "Kısa cevap: Oldukça yararlı bir şeydir. Uzun cevap: Aldığınız notları ve hesaplamalarınızı bir arada tutmak için kullanabileceğiniz en başarılı araçlardan biridir. Tekrar edilebilir araştırmada ve veri biliminde sıkça kullanılır. Veri Defteri’nde okuyacağınız yazıları (bu dahil) biz de Jupyter Notebook kullanarak yazacağız ve hazırladığımız defterleri GitHub sayfamızda sizlerle paylaşacağız. Böylece sadece okumakla kalmayıp, paylaştığımız defterlerdeki hesaplamaları siz de bilgisayarınızın başında deneyebilirsiniz.\nDaha önce Bol Bilim için genel bir yazı hazırlamıştım. Orada da Jupyter Notebook’tan bahsettim. Şimdi o tanıtımı biraz daha genişletip, sizleri Veri Defteri’nden daha fazla yararlanabilecek hale getirelim."
  },
  {
    "objectID": "posts/2017/10/30/jupyter-notebook-nedir/index.html#kurulum",
    "href": "posts/2017/10/30/jupyter-notebook-nedir/index.html#kurulum",
    "title": "Jupyter Notebook nedir?",
    "section": "Kurulum",
    "text": "Kurulum\n\nJupyter Notebook tek başına da yüklenebilir. Ancak benim tavsiyem Anaconda dağıtımını, Python 3.6 seçeneği ile kurmanız. Bu dağıtım ile birlikte bilgisayarınıza hem Jupyter Notebook kurulacak, hem de çeşitli paketlerle zenginleştirilmiş bir Python programlama diline sahip olacaksınız. Veri Defteri’nde her ne kadar farklı dilleri kullanmayı planlıyorsak da, en sık kullanacağımız dilin Python olacağını düşünebilirsiniz. Bu noktada şunu da söylemem yerinde olur. Jupyter Notebook’u Python dışında başka pek çok programlama dili ile de kullanabilirsiniz. İsterseniz kullanılabilen dillerin bir listesine bir göz atın. Özellikle veri bilimi camiasında çokça kullanılan R ve Julia dillerini yüklemeyi düşünebilirsiniz.\nAnaconda dağıtımını bilgisayarınıza kurduktan sonra Anaconda Navigator diye bir programın yüklendiğini göreceksiniz. Bu program ile yeni Python paketleri yükleyebilir ve güncellemeleri yapabilirsiniz. Ayrıca soldaki menüyü kullanarak veri analizi konusundaki ders notlarına, eğitim videolarına ve çalışma gruplarına erişebilirsiniz. Ana sayfada karşınıza birkaç program çıkacak. Onların arasından notebook programı ile Veri Defteri sayfalarını kurcalamaya başlayabilirsiniz. Bilgisayarınıza Jupyter Notebook kurmadan önce bir denemek isterseniz şu sayfaya bir göz atabilirsiniz."
  },
  {
    "objectID": "posts/2017/10/30/jupyter-notebook-nedir/index.html#kullanım",
    "href": "posts/2017/10/30/jupyter-notebook-nedir/index.html#kullanım",
    "title": "Jupyter Notebook nedir?",
    "section": "Kullanım",
    "text": "Kullanım\nAnaconda Navigator üzerinde notebook seçeneğine tıklayınca, varsayılan internet tarayıcınız açılacak. Bu ekrandan daha önce kaydettiğiniz bir defteri açabilir ya da yeni bir deftere başlayabilirsiniz. Yeni deftere başlamak için sağ üst köşeden bir programlama dili seçmeniz yeterli. İlk başta sizin listenizde sadece Python 3 gözükecektir. Arzu ederseniz zamanla diğer dilleri de ekleyebilirsiniz.\nGelelim açılan defterlerin nasıl kullanılacağına. Kabaca her defterin alt alta sıralanmış kutucuklardan oluştuğunu düşünebilirsiniz. Bu kutucuklarda kodlama ve hesaplama işlerinizi yapabilirsiniz. Bir hücrenin içine yazılanları çalıştırmak için, hücrenin içine tıklayıp, Ctrl ve Enter tuşlarına birlikte basmanız (Ctrl + Enter) yeterli. Shift + Enter ya da Alt + Enter tuşlarını da deneyebilirsiniz. İlki hücreyi çalıştırıp bir sonraki hücreye geçer. İkincisi ise hücreyi çalıştırıp hemen altına yeni boş bir hücre açar. Ben bu sayfayı Python defteri olarak açtım. Onun için basit bir işlemi hemen deneyebilirim.\n\n(3**4) + (2*4)\n\n89\n\n\nBu çok basit oldu. Bir de kod yazmaya bakalım. Şu sayfadaki örnek işimizi görür.\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\nsns.set()\nr = np.linspace(0, 10, num=100)\ndf = pd.DataFrame({'r': r, 'slow': r, 'medium': 2 * r, 'fast': 4 * r})\ndf = pd.melt(df, id_vars=['r'], var_name='speed', value_name='theta')\ng = sns.FacetGrid(df, col=\"speed\", hue=\"speed\",\n                  subplot_kws=dict(projection='polar'), height=4.5,\n                  sharex=False, sharey=False, despine=False)\ng.map(plt.scatter, \"theta\", \"r\")\n\n\n\n\nAyrıca bu hücrelere metin ve matematiksel denklemler de yazabilirsiniz. O yazılar için Markdown adı verilen ve basit kurallar ile metin biçimlendirmeye yarayan bir dil kullanılıyor. Örneğin bir kelimeyi koyu harflerle yazmak isterseniz, kelimenin önüne ve arkasına **** işaretlerini koymanız yeterli. İlk başta garip gözükse de, alıştıktan sonra metni çok hızlı düzenleyebildiğinizi göreceksiniz. Benzer şekilde matematiksel ifadeleri de LaTeX komutları ile yazabilirsiniz:\n\\[\n\\frac{\\partial \\Psi}{\\partial x^2} + \\frac{8 \\pi^2}{h^2}(E - V)\\Psi = 0.\n\\]\nBurada Jupyter Notebook ile ilgili temel birkaç noktayı yazdım. Kullandıkça daha pek çok özelliği olduğunu keşfedeceğinize eminim. Bu noktada bir ara verip şu sayfayı ziyaret etmenizi öneririm. Orada Jupyter Notebook kullanarak farklı programlama dilleri ile hazırlanmış pek çok sayfa, ders notları ve hatta kitaplar var. Başkalarının hazırladıkları incelemek çok öğretici olabilir.\n\nGitHub sayfamıza koyduğumuz dosyaları doğrudan bilgisayarınıza indirmek yerine sürüm kontrol programı Git’i kullanmanızı tavsiye ederim. Aslına bakarsanız veri işleme konularına bulaşacak herkes için Git bilmek neredeyse şart diyebilirim. Eğer daha önce hiç kullanmadıysanız ve öğrenmek isterseniz, şu sayfadan başlayabilirsiniz."
  },
  {
    "objectID": "posts/2017/12/26/python-programlamaya-giris-dongulerle-problem-cozme/index.html",
    "href": "posts/2017/12/26/python-programlamaya-giris-dongulerle-problem-cozme/index.html",
    "title": "Python Programlamaya Giriş 5 - Döngülerle Problem Çözme",
    "section": "",
    "text": "Python Programlamaya Giriş yazı dizimizin bir önceki bölümünde döngüleri nasıl kullanacağımızı gördük. Programların temel yapı taşı olan döngüleri hemen hemen her programda kullanırız. Önceki yazıdaki basit örneklere ek olarak, somut hesaplama problemlerine dair birkaç örnek daha verelim.\nDizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\n\nAsal sayıları listelemek\nVerilen bir \\(N\\) sayısından küçükeşit bütün asalları listeleyen bir program yazalım.\nBir önceki yazıda, belli bir sayının asal olup olmadığını tespit eden bir program yazmıştık. Burada, o programı 2 ile \\(N\\) arasındaki her tamsayı için çalıştıracağız.\n\nN = int(input(\"Bir pozitif tamsayı girin: \"))\nx = 2\nwhile x &lt;= N:\n    i = 2\n    while i*i &lt;= x:\n        if x % i == 0:\n            break\n        i += 1\n    else:\n        print(x)\n    x += 1\n\nBir pozitif tamsayı girin: 20\n2\n3\n5\n7\n11\n13\n17\n19\n\n\nGördüğünüz gibi, verilen bir sayının asallığını tespit etmek için kullandığımız döngünün etrafına bir döngü daha sararak \\(N\\)’ye kadar olan bütün sayıları yokluyoruz.\nAlıştırma. Yukarıdaki programı değiştirerek ilk \\(k\\) asal sayıyı basmasını sağlayın. Yani, meselâ 6 girildiğinde 2, 3, 5, 7, 11, 13 sayılarını çıkarsın.\n\n\nVerilen bir sayının asal çarpanlarını listelemek\nBu öncekine göre biraz daha zahmetli bir iş, ama ilkokulda öğrendiğimiz yöntemi uyarlamak yeterli.\nVerilen sayıya \\(N\\) diyelim. Bir \\(x\\) değişkenine başta 2 atayalım. Eğer \\(x\\) asal sayıysa, ve \\(N\\) sayısı \\(x\\)’e bölünüyorsa, \\(x\\)’i ekrana basalım. Ardından \\(N\\)’yi \\(x\\)’e bölebildiğimiz kadar bölelim, böylece içinde \\(x\\) çarpanı kalmasın. \\(N\\) birden büyük olduğu sürece, \\(x\\)’i bir artırıp tekrarlayalım.\n\nN = int(input(\"Bir pozitif tamsayı girin: \"))\nx = 2\nwhile N &gt; 1:\n    # x asal mı?\n    asal = True\n    i = 2\n    while i*i &lt;= x:\n        if x % i == 0:\n            asal = False\n            break\n        i += 1\n\n    if asal and N % x == 0:\n        print(x, end=\" \")\n        while N % x == 0 :\n            N = N / x\n    x += 1\n\nBir pozitif tamsayı girin: 13860\n2 3 5 7 11 \n\n\nBu programdaki döngüde else kullanmadık.\n\n\nFibonacci dizisi\nTemel programlama derslerinin olmazsa olmazı Fibonacci dizisi şöyle tanımlanır:\n\\[\\begin{array}{rcl} F_0 &=& 1 \\\\ F_1 &=& 1 \\\\ F_n &=& F_{n-1} + F_{n-2}\\end{array}\\]\nYani, dizideki her terim, önceki iki terimin toplamıdır. Dizideki sayılar şöyle gider: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …\nFibonacci dizisinin ilk elli terimini ekrana yazacak bir program yazalım.\n\na, b = 1, 1\nprint(a)\nprint(b)\ni = 2\nwhile i&lt;=50:\n    a,b = b, a+b\n    print(b)\n    i += 1\n\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n4181\n6765\n10946\n17711\n28657\n46368\n75025\n121393\n196418\n317811\n514229\n832040\n1346269\n2178309\n3524578\n5702887\n9227465\n14930352\n24157817\n39088169\n63245986\n102334155\n165580141\n267914296\n433494437\n701408733\n1134903170\n1836311903\n2971215073\n4807526976\n7778742049\n12586269025\n20365011074\n\n\nDöngüde, Python’a özgü bir çokuz ataması yaptığımıza dikkat edin:\na,b = b, a+b\nBu işlemin sonunda b’nin eski değeri a’ya, a+b toplamının eski değeri de b’ye atanır. Başka dillerde çokuz ataması bulunmayabilir. Aynı işi başka türlü nasıl yaparız? İlk akla gelen şey şu olabilir:\na = b\nb = a + b   # yanlış\nBu yanlış, çünkü ikinci atamada eşitliğin sağ tarafında a’nın yeni değeri kullanılıyor. Bir önceki ifadede a’ya b’nin değerini atamıştık. Böylece atamanın sonunda sadece b’yi iki katına çıkarmış oluruz.\nDoğru yöntem, eski değerler için ayrı değişkenler kullanmaktır. Yukarıdaki programı bu yaklaşımla tekrar yazalım:\n\na = 1\nb = 1\nprint(a)\nprint(b)\ni = 2\nwhile i&lt;=50:\n    a_eski = a\n    b_eski = b\n    a = b_eski\n    b = a_eski + b_eski\n    print(b)\n    i += 1\n\nİki programı karşılaştırınca, çoklu atama kullanan programın daha sade ve okunaklı olduğunu görebiliyoruz.\n\n\nCollatz dizisi\nCollatz dizisi pozitif tamsayılardan oluşur. Diziyi oluşturma kuralı şöyledir:\n\\(n_i\\) çift sayıysa: \\(n_{i+1} = n_i/2\\)\n\\(n_i\\) tek sayıysa: \\(n_{i+1} = 3n_i+1\\)\nDizi 1’e ulaştığında durur. Sözgelişi, diziye 13 ile başlarsak\n13, 40,20, 10, 5, 16, 8, 4, 2,1\nelde ederiz. Collatz dizisi adı verilen bu diziyi basit bir Python programıyla üretebiliriz:\n\nn = int(input(\"Başlangıç değeri: \"))\nwhile n &gt; 1:\n    if n % 2 == 0:  # n çift sayıysa\n        n = n/2\n    else:   # n tek sayıysa\n        n = 3*n + 1\n    print(int(n), end=\" \")\n\nBaşlangıç değeri: 11\n34 17 52 26 13 40 20 10 5 16 8 4 2 1 \n\n\n\n\nSeriler\nTerimleri belli bir formüle göre değişen serileri hesaplamak için döngüleri kullanabiliriz. Sözgelişi, \\(\\pi\\) sayısını Leibniz formülü ile hesaplayalım.\n\\[\\frac{\\pi}{4} = \\sum_{i=0}^{\\infty} (-1)^i \\frac{1}{2i+1} = 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\ldots\\]\nBu eşitlik sonsuz sayıda terim kullandığımızda tam doğru olur. Pratikte bu mümkün olmadığından toplamayı bir yerde bitirmek gerekir, bu da kesme hatası (truncation error) denen hataya yol açacaktır. Buna ek olarak, bilgisayarın içinde sayıları tam olarak temsil edememekten kaynaklanan yuvarlama hatası (roundoff error) da vardır.\nBu toplamı nerede kesmeliyiz? Önce, serinin yavaş yakınsadığına dikkat edin. Her yeni terim, büyüklük olarak bir öncekine yakın. O yüzden çok sayıda toplama yapmak gerekecek (\\(\\pi\\) sayısını hesaplamak için daha iyi formüller vardır. Bazılarını alıştırmalarda kullanacağız). Diyelim \\(\\pi\\)’yi virgülden sonra dört basamak doğrulukta belirlemek istiyoruz. O zaman hata payının \\(10^{-5}\\) kadar olmasını isteriz. Terimlerin mutlak değeri tekdüze olarak azaldığından, mutlak değeri \\(10^{-5}\\)’den küçük terimlere geldiğimizde döngüyü durdururuz.\nBaşka bir deyişle, döngüyü durdurmak için \\(1/(2i+1) \\leq 10^{-5}\\), veya, \\(2i+1 \\geq 10^5\\) şartı geçerlidir. Böylece yaklaşık 50 000 terim toplamak gerektiğini görürüz.\n\ntoplam = 0.0 # ara toplam\nisaret = 1 # +1 veya -1 olarak dönüşümlü olarak değişecek\npayda = 1.0  # 1,3,5,7,...\nterim = isaret / payda\nsayac = 1\nwhile abs(terim) &gt; 0.00001:\n    toplam += terim\n    payda += 2\n    isaret *= -1\n    terim = isaret / payda\n    sayac += 1\n\nprint(\"pi ~\", 4*toplam)\nprint(sayac,\"terim toplandı.\")\n\npi ~ 3.1415726535897814\n50001 terim toplandı.\n\n\n\n\nFonksiyon tablolama\nAşağıdaki program, \\(x\\) değişkenini 0 ile 1 arasında 0.1 adımlarla artırarak, \\(x\\) ve \\(\\sin(x)\\) değerlerini bir tablo olarak yazar.\nBu programda matematik modülünü kullanıyoruz. Matematiksel fonksiyon ve sabitlerin bulunduğu math modülü Python standart kütüphanesine dahildir. Bu modülden daha sonra bahsedeceğiz. Ayrıntılı bilgi için Python başvuru belgelerine bakabilirsiniz.\n\nimport math\nx = 0.0\ndx = 0.1\nprint(\"x\", \"sin x\")\nwhile x &lt;= 1.0:\n    print(x, math.sin(x))\n    x += dx\n\nx sin x\n0.0 0.0\n0.1 0.09983341664682815\n0.2 0.19866933079506122\n0.30000000000000004 0.2955202066613396\n0.4 0.3894183423086505\n0.5 0.479425538604203\n0.6 0.5646424733950354\n0.7 0.644217687237691\n0.7999999999999999 0.7173560908995227\n0.8999999999999999 0.7833269096274833\n0.9999999999999999 0.8414709848078964\n\n\nBu çıktı pek göze hitap etmiyor, hizalanma iyi değil. Daha iyi bir görünüm için dize biçimlendirme (string formatting) uygulayabiliriz.\n\nimport math\nx = 0.0\ndx = 0.1\nprint(\"{:6s} {:6s}\".format(\"x\", \"sin x\"))\nwhile x &lt;= 1.0:\n    print(\"{:1.4f} {:1.4f}\".format(x, math.sin(x)))\n    x += dx\n\nx      sin x \n0.0000 0.0000\n0.1000 0.0998\n0.2000 0.1987\n0.3000 0.2955\n0.4000 0.3894\n0.5000 0.4794\n0.6000 0.5646\n0.7000 0.6442\n0.8000 0.7174\n0.9000 0.7833\n1.0000 0.8415\n\n\nDize biçimlendirme, belli kurallara göre hazırlanmış bir kalıp dizesine işlem yapar. Bu kalıp içinde { ve } işaretleri bir yer tutucu görevi görür. Bu örnekte {:6s} yer tutucusu 6 karakterlik yer içine bir dize (“s”) geleceğini belirtiyoruz. Daha sonraki {:1.4f} yer tutucusu ise bir reel sayının (“f”) ondalık noktadan önce bir basamak, noktadan sonra ise dört basamak olarak gösterileceğini düzenliyor.\nDize biçimlendirme kalıplarını oluşturma kuralları çok zengindir. Buradaki amaçlarımız için daha fazla derine girmemiz gerekmiyor. Meraklısı için daha ayrıntılı bilgi şurada bulunabilir.\n\nBaşka bir örnek olarak, sinüs fonksiyonunun değişik derecelerdeki Taylor yaklaştırımını veren bir tablo üretelim. Bilindiği gibi, \\(\\sin\\) fonksiyonunun 0 çevresindeki Taylor açılımı şu şekildedir:\n\\[\\sin x = x - \\frac{x^3}{6} + \\frac{x^5}{120} - \\frac{x^7}{5040} + \\ldots\\]\nArtan derecelerdeki yaklaştırım fonksiyonlarını şöyle tanımlayabiliriz:\n\\[\\begin{eqnarray}\nf_1(x) &=& x - \\frac{x^3}{6} \\\\\nf_2(x) &=& x - \\frac{x^3}{6} + \\frac{x^5}{120}\\\\\nf_3(x) &=& x - \\frac{x^3}{6} + \\frac{x^5}{120} - \\frac{x^7}{5040}\n\\end{eqnarray}\\]\nve 0 ile 1 arasında değişen \\(x\\) değerleri için, her satıra \\(x\\), \\(f_1(x)\\), \\(f_2(x)\\), \\(f_3(x)\\), \\(\\sin x\\) değerlerini ekrana yazalım.\n\nimport math\nx = 0.0\ndx = 0.1\nprint(\"{:6s} {:6s} {:6s} {:6s} {:6s}\".format(\"x\", \"f1\", \"f2\", \"f3\", \"sin x\"))\nwhile x &lt;= 1.0:\n    f1 = x - x**3 /6\n    f2 = f1 + x**5/120\n    f3 = f2 + x**7/5040\n    print(\"{:1.4f} {:1.4f} {:1.4f} {:1.4f} {:1.4f}\".format(x, f1, f2, f3, math.sin(x)))\n    x += dx\n\nx      f1     f2     f3     sin x \n0.0000 0.0000 0.0000 0.0000 0.0000\n0.1000 0.0998 0.0998 0.0998 0.0998\n0.2000 0.1987 0.1987 0.1987 0.1987\n0.3000 0.2955 0.2955 0.2955 0.2955\n0.4000 0.3893 0.3894 0.3894 0.3894\n0.5000 0.4792 0.4794 0.4794 0.4794\n0.6000 0.5640 0.5646 0.5647 0.5646\n0.7000 0.6428 0.6442 0.6443 0.6442\n0.8000 0.7147 0.7174 0.7174 0.7174\n0.9000 0.7785 0.7834 0.7835 0.7833\n1.0000 0.8333 0.8417 0.8419 0.8415\n\n\n\n\nİteratif denklem sistemleri\nDiyelim, radyoaktif bir \\(A\\) izotopu bozunuyor ve yine radyoaktif olan \\(B\\) izotopunu üretiyor, o da bozunarak kararlı (radyoaktif olmayan) \\(C\\) izotopunu üretiyor. \\(A\\)’nın bozunma sabiti (birim zamanda bozunan atomların oranı) \\(\\lambda_A\\), \\(B\\)’ninki ise \\(\\lambda_B\\) olsun. Düzenli zaman aralıklarında \\(A\\), \\(B,\\) ve \\(C\\) atomlarının sayılarını veren bir program yazalım.\nDenklemler şöyle olur:\n\\[\\begin{eqnarray}\na_{t+1} &=& a_t - a_t \\lambda_A \\Delta t\\\\\nb_{t+1} &=& b_t - b_t \\lambda_B \\Delta t + a_t \\lambda_A \\Delta t\n\\end{eqnarray}\\]\nBurada \\(a_t\\) ve \\(b_t\\), \\(t\\) adımında \\(A\\) ve \\(B\\) atomlarının sayısı, \\(\\Delta t\\) ise zaman adımı. Birinci denklemde her adımda bir miktar \\(A\\) atomu kaybediliyor. İkinci denklemde ise her adımda bir miktar \\(B\\) atomu kaybediliyor, buna karşılık kaybedilen \\(A\\) atomu kadar yeni \\(B\\) atomu ekleniyor. Toplam atom sayısı \\(N\\) sabit olduğundan $C $ atomları için ayrı bir denklem yazmaya lüzum yok, \\(c_t =N-a_t-b_t\\) ile bulunabilir.\nSomut bir örnek olarak, \\(^{135} \\mathrm{I} \\rightarrow ^{135}\\mathrm{Xe} \\rightarrow ^{135} \\mathrm{Cs}\\) zincirini ele alalım. İyot-135’in yarılanma ömrü 6.57 saat, Ksenon-135’in ise 9.14 saattir. Sezyum-135 kararlı izotop olmasa da, yarılanma ömrü 2.3 milyon yıl olduğundan, diğerlerine göre sabit sayılır. Yarılanma ömrü \\(\\tau\\) ise, bozunma sabiti \\(\\lambda = \\ln 2 / \\tau\\) olur.\n\nimport math\n\na,b,c = 1000, 0, 0\nN = a+b+c\n\nlam_a = math.log(2) / 6.57 # I-135, 1/saat biriminde\nlam_b = math.log(2) / 9.14 # Xe-135, 1/saat biriminde\nt = 0\n\n# Sütun başlıkları sağa yaslansın.\nprint(\"{:&gt;6s} {:&gt;6s} {:&gt;6s} {:&gt;6s}\".format(\"saat\", \"I\",\"Xe\",\"Cs\"))\n\n# Bir saatlik aralıklarla a,b,c miktarını ekrana bas.\nwhile t &lt;= 20:\n    print(\"{:6d} {:6d} {:6d} {:6d}\".format(t, int(a), int(b), int(c)))\n    a = (1-lam_a)*a\n    b = (1-lam_b)*b + lam_a*a\n    c = N-a-b\n    t += 1\n\n  saat      I     Xe     Cs\n     0   1000      0      0\n     1    894     94     11\n     2    800    171     28\n     3    715    234     50\n     4    640    283     75\n     5    572    322    104\n     6    512    352    135\n     7    458    373    167\n     8    409    388    201\n     9    366    398    235\n    10    327    402    269\n    11    293    402    303\n    12    262    400    337\n    13    234    394    370\n    14    209    386    403\n    15    187    377    435\n    16    167    366    465\n    17    150    354    495\n    18    134    341    523\n    19    120    328    551\n    20    107    314    577\n\n\nGörüyoruz ki \\(^{135} \\mathrm{I}\\) miktarı sürekli azalıyor ve $ ^{135} $ sürekli artıyor. Geçiş izotopu \\(^{135}\\mathrm{Xe}\\) ise önce artıyor, onuncu saatte zirveye ulaşıyor, ve sonra sürekli azalıyor."
  },
  {
    "objectID": "posts/2017/12/30/python-programlamaya-giris-dongu-alistirmalari/index.html",
    "href": "posts/2017/12/30/python-programlamaya-giris-dongu-alistirmalari/index.html",
    "title": "Python Programlamaya Giriş 6 - Döngü Alıştırmaları",
    "section": "",
    "text": "Python Programlamaya Giriş yazı dizimizin bir önceki bölümünde döngü yapılarını kullanarak bazı hesaplama problemlerini nasıl çözeceğimizi görmüştük. Bu bölümde ise döngüleri kullanarak yazacağınız bazı alıştırma problemleri veriyoruz. Çözümlerini bulmak size ait.\nDizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\n\n\nEn uzun Collatz zinciri\n\n\nÜstel fonksiyon Taylor serisi\n\n\nKarekök bulma\n\n\nMachin formülüyle pi’yi bulma\n\n\nLojistik fonksiyon ve kaos\n\n\nSIR salgın modeli\n\n\n\nEn uzun Collatz zinciri\nCollatz dizisinden daha önceki bölümde bahsetmiştik. Diziyi \\(n\\) sayısıyla başlatırsak, sonraki sayıyı şu bulma kuralla buluruz:\n\n\\(n_i\\) çift sayıysa: \\(n_{i+1} = n_i/2\\)\n\\(n_i\\) tek sayıysa: \\(n_{i+1} = 3n_i+1\\)\n\\(n_i=1\\) ise dizi sonlanır.\n\nMeselâ 13 ile başlarsak, on eleman uzunlukta olan 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 dizisini elde ederiz. Bu dizinin uzunluğu 10’dur.\nSorumuz şu: Bir milyonun altındaki bütün başlangıç değerleri içinde hangisi en uzun Collatz dizisini verir? (Başlangıçtan sonraki değerler bir milyonun üzerine çıkabilir.)\n(Kaynak: Euler Project, 14. problem)\n\n\nÜstel fonksiyon için Taylor serisi\nÜstel fonksiyonun \\(x=0\\) çevresinde bir sonsuz seri ile gösterilebileceğini temel analiz derslerinden biliyoruz.\n\\[e^x = \\sum_{n=0}^{\\infty} \\frac {x^n}{n!} = 1 + x + \\frac{1}{2}x^2 + \\frac{1}{6}x^3 + \\cdots\\]\nBu seri bütün \\(x\\) değerleri için yakınsar, yani her \\(x\\) değeri için yeterince terim ekleyerek \\(e^x\\) değerini istediğimiz hassasiyette hesaplayabiliriz.\n\\(x\\) değerini kullanıcıdan sorarak, yukarıdaki seriyle \\(e^x\\) değerini veren bir program yazın. Programın içinde tol isimli bir tolerans değişkeni tanımlayın ve \\(10^{-10}\\) değeri verin. Bir döngü içinde, son terimin mutlak değeri tol’den küçük olana kadar seriye yeni terimler ekleyin.\nHer terimi sıfırdan hesaplamak gereksiz yük bindirecektir. Eklenecek yeni terimi hesaplarken, bir önceki terimi \\(x\\) ile çarpıp, iterasyon değişkeni olan \\(n\\)’ye bölmek daha verimli olur.\nÇeşitli \\(x\\) ve tol değerleri kullanarak \\(e^x\\) değerlerini, kaç terim gerektiğini, ve son terimi ekrana bastırın.\nÖrnek çıktı:\nx değerini girin: 3.0\ne^x ~  20.0855369232\n22 terim kullanıldı\nSon terim = 2.79190741015e-11\nMatematik kütüphanesindeki fonksiyonla karşılaştırmak isterseniz math.exp() fonksiyonunu kullanabilirsiniz.\n\n\nBabil yöntemiyle karekök bulma\nVerilen bir \\(N\\) sayısının karekökünü bulmak için Babil döneminden beri kullanılan tekrarlamalı (iteratif) bir yöntem vardır: Önce, karekök için bir tahminde bulunun ve buna \\(x_0\\) deyin. Bir sonraki tahminimiz \\[x_1 = \\frac{1}{2}\\left(x_0 + N/x_0\\right)\\] olacak. Genel olarak, \\[x_{n+1} = \\frac{1}{2}\\left(x_n + N/x_n\\right)\\] kuralıyla ardışık iterasyonlar yaparsak, \\(x_n\\) değerleri hızlıca \\(N\\)’nin kareköküne yakınsayacaktır.\nBu yöntem, fonksiyon köklerini bulmak için kullanılan en iyi algoritmalardan biri olan Newton yönteminin özel bir durumudur.\nBu yöntemi kullanarak karekök değerini hesaplayan bir program yazın. Program kullanıcıya karekökü alınacak sayıyı ve ilk tahmini sorsun. Bir döngü içinde, hata değeri \\(|x_n^2 - N|\\) programda belirlenen bir toleranstan (sözgelişi \\(10^{-10}\\)) küçük olana kadar iterasyonlar tekrarlansın. Program karekökün tahmini değerini ve sonuca ulaşmak için kaç iterasyon gerektiğini ekrana bassın.\nÖrnek çıktı:\nKarekökü alınacak sayı: 135.646\nİlk tahmin: 10\nKarekök ~  11.6467162754\n4 iterasyon\n\n\nPi sayısı ve Machin formülü\nPi’yi hesaplamak için tarih boyunca çeşitli yöntemler geliştirildi. Önceki bir örnekte kullandığımız Leibniz formülü \\(\\arctan\\) fonksiyonunun Taylor açılımına dayanır:\n\\[\\arctan x = x - \\frac{1}{3}x^3 + \\frac{1}{5}x^5 - \\frac{1}{7} x^7 + \\cdots\\]\nBu formülde \\(x=1\\) koyarak Leibniz formülünü elde ederiz:\n\\[\\frac{\\pi}{4} = 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\ldots\\]\nBu formül, onu ilk defa 14. yüzyılın sonunda keşfeden dâhi Hintli matematikçi Madhava’nın, ve astronom James Gregory’nin de adı eklenerek, Madhava-Gregory-Leibniz serisi olarak da anılır.\nDaha önce gördüğümüz gibi, \\(x=1\\) için bu seri çok yavaş yakınsar. Ancak, \\(x\\)’in birden küçük olduğu değerlerde yakınsama hızlı olur. 1706’da John Machin \\(\\pi\\) için hızlı yakınsayan, böylelikle az sayıda terimle yüksek doğruluk sağlayan bir formül yayınladı.\n\\[\\pi = 16 \\arctan \\frac{1}{5} - 4 \\arctan \\frac{1}{239}\\]\nBuradaki her bir terim, \\(\\arctan\\) fonksiyonunun yukarıda verilen açılımıyla hesaplanabilir.\nBu formülle Machin, \\(\\pi\\)’yi o dönem için bir rekor olan 100 basamağa kadar hesaplayabilmişti. \\(\\pi\\)’nin birkaç \\(\\arctan\\) teriminin toplamı olarak ifade edildiği formüllere Machin benzeri adı verilir. Bu algoritmalar, \\(\\pi\\)’yi trilyon basamağa kadar hesaplarken bile kullanılabilecek kadar verimlidirler.\nMachin formülüyle \\(\\pi\\)’yi hesaplayacak bir program yazın. Programda \\(\\arctan\\) fonksiyonlarının değerlerini yine bir döngü içinde, serinin son terimi belli bir hata payı değerinin altında olacak şekilde hesaplatın.\n\n\nLojistik fonksiyon ve kaos\nMatematiksel kaosun gözlendiği en basit sistemlerden biri, lojistik fonksiyon denen fonksiyonun iterasyonlarında bulunur. Lojistik dizinin her yeni terimi \\(x_{t+1}\\), bir önceki terim \\(x_t\\)’den şu formülle elde edilir.:\n\\[x_{t+1} = r x_t (1-x_t)\\]\nBurada \\(x_t\\) 0 ile 1 arasında kalan dinamik değişken, \\(r\\) ise 0 ile 4 arasında bir parametredir. Parametre bir kere belirlendikten sonra dizi içinde değişmez.\n\n\n\\(x_0 = 0.1\\) değerinden başlayarak, kullanıcıdan alınan bir \\(r\\) değerini kullanarak ardışık \\(x_0\\ldots x_{100}\\) değerlerini ekrana yazan bir program yazın. Programı r parametresine sırayla 2.1, 3.1, 3.4, 3.5 değerleri vererek çalıştırın. Elde edilen \\(x_t\\) değerlerinin uzun vadeli davranışını inceleyin (sabit bir noktaya mı yakınsıyor, periyodik bir döngüye mi oturuyor?) Örnek çıktı:\nr parametresi (0-4): 2.1\n0.1\n0.189\n0.3218859\n0.4583782715\n0.521362026605\n0.524041694021\n...\n0.52380952381\n0.52380952381\n0.5238095238\n\n\n\\(r\\) = 3.5 için dizi, periyotu dört olan bir salınıma oturur. Deneme yanılma ile, dört periyotlu salınım veren en düşük ve en yüksek \\(r\\) değerlerini belirleyin.\n\n\nKaos’un alametifarikası, birbirine çok yakın yerden başlayan iki yörüngenin hızla (üstel olarak) birbirinden uzaklaşmasıdır. Bunu görmek için programı biraz değiştirelim: Programı iki ayrı değerle başlayan dizileri, iki ayrı sütunda basacak şekilde değiştirin. Başlangıç değerleri 0.1 ve 0.10001 olsun. Bu programı \\(r=\\) 3.1, 3.5, 3.57, 3.7 ve 4.0 için çalıştırın.\n\n\nHangi \\(r\\) değerleri için uzun vadede iki sütundaki sayılar eşitleniyor? (Kaos olmayan durum)\n\nHangi değerlerde sütunlardaki sayılar birbirine yakın başlamasına rağmen sonunda çok farklı hale geliyorlar?\n\nSütunlardaki sayıların arasındaki farkın belli bir miktar açılması için gereken zaman \\(r\\) ile nasıl değişiyor?\n\n\n\n\n\nSalgın hastalıklar - SIR modeli\nSIR (susceptible-infected-recovered) modeli, salgın hastalıkların yayılmasını incelemekte kullanılan modellerin en sadelerindendir. Modelde bir topluluk üç kategoriye ayrılır: Şimdilik sağlıklı olan ama hastalığa yakalanması mümkün olanlar (S), hastalığa yakalanmış ve S’lere bulaştırabilecek olanlar (I), ve hastalanıp iyileşmiş, tekrar hastalanmayacak ve hastalığı başkasına bulaştıramayacak olanlar (R). Belli bir \\(t\\) anında bu üç kategoride bulunanların nüfustaki oranlarını sırayla \\(S_t, I_t, R_t\\) olarak gösterelim. O zaman, ayrık zaman adımlarında modelin denklemleri şöyle yazılabilir:\n\\[\\begin{array}{rcl}S_{t+1} &=& S_t - a I_t S_t \\\\ I_{t+1} &=& I_t + a I_t S_t - b I_t \\\\ R_{t+1} &=& R_t + bI_t \\end{array}\\]\nBurada \\(a\\) parametresi, kullanılan zaman birimi içinde (gün, hafta, ay) hastalıkla temas sıklığı veya bulaşma olasılığı, \\(b\\) parametresi ise ortalama iyileşme oranıdır. Buna göre 1/\\(b\\) değeri hastalığın iyileşmesi için bir zaman ölçeği sağlar, bu bilgiyle de \\(b\\) için bir tahmin yapılabilir.\nSIR modelini kullanarak her zaman adımında S, I, ve R kategorisindekilerin oranını listeleyen bir program yazın. Veriler hasta olanların oranı %0.1’in üzerinde olduğu sürece, ama en fazla 100 zaman adımı gösterecek şekilde listelensin. Başlangıçta sağlıklı olanların oranı %99, hastaların oranı %1, iyileşmiş olanlar ise %0 olsun. Parametreler için \\(a = 0.6\\) ve \\(b = 0.2\\) kullanın (epeyce bulaşıcı, ama tipik iyileşme süresinin 5 zaman adımı olduğu bir hastalık).\nSIR modelinde salgının kısa sürdüğü ve salgın süresince toplam nüfusun sabit kaldığı varsayılır. Yukarıdaki denklemlerin sağ taraflarını topladığınızda bazı terimlerin birbirini götürdüğünü ve \\(S_{t+1} + I_{t+1} + R_{t+1} = S_t + I_t + R_t = 1\\) olacağını görebilirsiniz. Her zaman adımında \\(S_t + I_t + R_t\\) toplamını da ekrana bastırın. Bu toplamın sabit kalmaması programınızda bir hata olduğunu göstergesidir.\nÖrnek çıktı:\nt     s     i     r   toplam\n-- ----- ----- ----- --------\n 0 0.990 0.010 0.000 1.000000\n 1 0.984 0.014 0.002 1.000000\n 2 0.976 0.019 0.005 1.000000\n 3 0.964 0.027 0.009 1.000000\n 4 0.949 0.037 0.014 1.000000\n 5 0.928 0.051 0.021 1.000000\n...\n47 0.046 0.002 0.952 1.000000\n48 0.046 0.001 0.952 1.000000\n49 0.046 0.001 0.953 1.000000\nÇeşitli başlangıç şartları, ve parametreler için çeşitli değerler deneyerek sistemin davranışına bakın. Hasta olanların oranı kaçıncı zaman adımında azami sayıya ulaşıyor? Salgın dindiğinde hiç hasta olmayanların oranı ne kadar? Bu sayılar parametrelerle nasıl değişiyor?\nNot. Dinamik değişkenlerin güncellenmesi sırasında sağ tarafta hep eski (bir önceki zamandaki) değerlerin kullanılmasına dikkat etmek gerekiyor. Sözgelişi,\ns = s - a*i*s\ni = i + a*i*s - b*i    # hata\nr = r + b*i            # hata\n...\nyazmak, ilk bakışta gözden kaçabilecek ciddi bir hataya yol açar. İkinci atamadaki s değişkeni aslında \\(S_{t}\\) değerini değil, yenilenen \\(S_{t+1}\\) değerini taşımaktadır. Aynı sorun üçüncü atamadaki i değişkeni için de geçerli. Bunu engellemenin iki yolu var. Birincisi, eski değerleri ayrı adlar altında saklamak ve döngünün sonunda güncelleme yapmak:\ns = s_eski - a * i_eski * s_eski\ni = i_eski + a* i_eski * s_eski - b * i_eski\nr = r_eski + b * i_eski\n...\ns_eski = s\ni_eski = i\nr_eski = r\n...\nİkinci yol ise, Python’un çoklu atama özelliğini kullanarak, geçici değişken kullanmadan bütün değişkenleri tek bir atamada güncellemek:\ns, i, r = s - a*i*s, i + a*i*s - b*i, r + b*i\nBu atamada önce eşit işaretinin sağ tarafının değeri (bir üçüz) bulunur. Sağ tarafta eski değerler kullanılır. Sonra bu üçüzün elemanları s, i, ve r’ye sırayla atanır."
  },
  {
    "objectID": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html",
    "href": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html",
    "title": "Python Programlamaya Giriş 2 - Sayılar, Aritmetik, Temel Veri Yapıları",
    "section": "",
    "text": "Yeni başlayanlar için Python programlamayı anlatan yazı dizimizin ikinci bölümünde sayıları, aritmetik işlemlerini, ve Python’daki temel veri tiplerini (listeler, çokuzlar, dizeler, sözlükler) işliyoruz.\nBu yazıda sadece kısa ve işlevsel bir giriş yapıyoruz. Sonraki bölümlerimizde veri yapılarının kullanımından daha fazla bahsedeceğiz."
  },
  {
    "objectID": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#değişken-atamaları",
    "href": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#değişken-atamaları",
    "title": "Python Programlamaya Giriş 2 - Sayılar, Aritmetik, Temel Veri Yapıları",
    "section": "Değişken atamaları",
    "text": "Değişken atamaları\nPython’da değişkenlerin tiplerini (int, float, vs.) önceden beyan etmek gerekmez. Değişken isimleri, atamanın sağ tarafındaki ifadeye işaret eden bir isimdir sadece.\n\nx = -2      # bir tamsayı\ny = 3/4 * 2 # reel sayı\nz = \"Merhaba\"+\"Dünya\" # dize\nx,y,z\n\n(-2, 1.5, 'MerhabaDünya')\n\n\nÇoklu atamalar yapmak mümkündür:\n\nx, y, z = -2, 1.5, \"Merhaba Dünya\"\nx,y,z\n\n(-2, 1.5, 'Merhaba Dünya')\n\n\nBu usulü kullanarak iki değişkenin değerini, bir ara değişken kullanmadan değiştokuş etmek mümkün olur.\n\nx,y = y,x\nx,y\n\n(1.5, -2)\n\n\nPython 3 ile değişken isimlerinde herhangi Unicode karakterleri kullanabilirsiniz.\n\nkağıt_sayısı = 5\nölçü = 0.3\n\nBir değişkeni del komutuyla bellekten silebiliriz.\n\ndel z\nprint(z)\n\nNameError: name 'z' is not defined"
  },
  {
    "objectID": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#işlem-öncelikleri",
    "href": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#işlem-öncelikleri",
    "title": "Python Programlamaya Giriş 2 - Sayılar, Aritmetik, Temel Veri Yapıları",
    "section": "İşlem öncelikleri",
    "text": "İşlem öncelikleri\nİşlemlerin bazıları diğerlerinden daha önce yapılır. Önceliklerde okulda öğrendiğimiz kurallar genelikle geçerlidir. Aynı ifade içinde önce üs alma, sonra çarpma, bölme ve kalan bulma işlemleri, sonra da toplama ve çıkarma işlemi yapılır. Aynı öncelik sınıfında bulunan işlemler, soldan sağa sırayla yapılır. Öncelik sırasını değiştirmek için parantez kullanılır.\n\n2 + 3*4, (2+3)*4\n\n(14, 20)\n\n\n\n4 + 3**2, (4+3)**2\n\n(13, 49)\n\n\n\n3*4/2*6, 3*4/(2*6)\n\n(36.0, 1.0)\n\n\nÖncelik sırası kavramı aritmetik işlem olsun olmasın, dildeki her türlü operatör için de geçerlidir. Tam bir liste için Python referans sayfalarına bakabilirsiniz.\nAtama (=) işlemi en düşük önceliğe sahiptir. Bir değişkene bir değer ataması yaparken önce eşit işaretinin sağ tarafının değeri hesaplanır. Değişkene değer atama işlemi en son yapılır. Python’da bir atama başka bir ifadenin parçası olamaz.\n\nx = 1\nx = 3*x + 5\nx\n\n8\n\n\n\n(x=3)*x+5\n\nSyntaxError: invalid syntax (&lt;ipython-input-27-5aaaedf6169a&gt;, line 1)"
  },
  {
    "objectID": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#dizeler",
    "href": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#dizeler",
    "title": "Python Programlamaya Giriş 2 - Sayılar, Aritmetik, Temel Veri Yapıları",
    "section": "Dizeler",
    "text": "Dizeler\nBir dize (string), karakterlerin (harf, rakam, ve diğer işaretler) birleşiminden oluşur. Tek tırnak veya çift tırnak içinde olmalıdır.\nDizenin içindeki karakterlere indeksleme işlemi [] ile erişilebilir. İndeks değerleri sıfırdan başlar; birinci karakter için 0, ikinci karakter için 1, vs. Negatif indeksler sondan başlayarak saymak için kullanılabilir: Son karakter için -1, sondan bir önceki için -2, vs. gibi.\n\nisim = \"Albert Einstein\"\nisim[0] # İlk karakter\n\n'A'\n\n\n\nisim[1] # İkinci karakter\n\n'l'\n\n\n\nisim[-1] # Son karakter\n\n'n'\n\n\n\nisim[-2] # Sondan bir önceki karakter\n\n'i'"
  },
  {
    "objectID": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#çokuzlar",
    "href": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#çokuzlar",
    "title": "Python Programlamaya Giriş 2 - Sayılar, Aritmetik, Temel Veri Yapıları",
    "section": "Çokuzlar",
    "text": "Çokuzlar\nBir çokuz (tuple) çeşitli nesneleri yuvarlak parantezler içinde birleştirir. Çokuz elemanlarının aynı tipten olması gerekmez. Dizelerde kullanılan indeksleme kuralları çokuzlarda da geçerlidir.\n\na = (3.14, 2, 'Albert', 3+4j, (7.25,-23))\na[0]  # birinci eleman\n\n3.14\n\n\n\na[-1][0] # Son elemanın birinci elemanı\n\n7.25\n\n\nÇokuzlar atamada kullanılırsa, her eleman birebir eşleştirilerek atama yapılır.\n\n(x, y, z) = (-1.25, 42, \"Merhaba\")\n\n\nx\n\n-1.25\n\n\n\ny\n\n42\n\n\n\nz\n\n'Merhaba'\n\n\nVirgülle ayrılmış bir ifade otomatik olarak çokuza dönüştürülür, yani yukarıdaki örneği\nx, y, z = -1.25, 42, \"Merhaba\"\nşeklinde de yazabilirsiniz. Yukarıda bahsettiğimiz çoklu atama bu şekilde çalışır.\nDizelerle çokuzların ortak özellikleri değiştirilemez (immutable) olmalarıdır. Elemanlarına yeni değerler atayamazsınız.\n\nz = \"Merhaba\"\nz[0] = \"m\"\n\nTypeError: 'str' object does not support item assignment\n\n\n\na = (1,2,3)\na[0] = -1\n\nTypeError: 'tuple' object does not support item assignment"
  },
  {
    "objectID": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#listeler",
    "href": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#listeler",
    "title": "Python Programlamaya Giriş 2 - Sayılar, Aritmetik, Temel Veri Yapıları",
    "section": "Listeler",
    "text": "Listeler\nListe, köşeli parantez içinde, virgülle ayrılmış elemanları birleştiren br yapıdır. Çokuzlar gibi listelerde de elemanlar farklı tiplerde olabilir. Dizeler ve çokuzlar için geçerli olan eleman indeksleme işlemleri listelerde de aynen geçerlidir. Listelerin çokuzlardan farkı değiştirilebilir (mutable) olmalarıdır, yani elemanlarına tekrar atama yapılabilir.\n\nliste = [5, \"merhaba\", (2,3,1), [-1,0,2]]\nliste[0] = 4.1  # birinci elemanı değiştir\nliste[-1][0] = 12 # son elemanın birinci elemanını değiştir\nliste\n\n[4.1, 'merhaba', (2, 3, 1), [12, 0, 2]]\n\n\n\nliste[1] = \"naber\" # İkinci elemana başka bir dize ata.\nliste\n\n[4.1, 'naber', (2, 3, 1), [12, 0, 2]]\n\n\n\ndel liste[2] # Üçüncü elemanı sil\nliste\n\n[4.1, 'naber', [12, 0, 2]]\n\n\nAncak, listenin bir elemanı değiştirilemez bir tipteyse, o elemanın alt elemanlarını silemez veya onlara atama yapamazsınız.\n\nliste[1][0] = \"h\"\n\nTypeError: 'str' object does not support item assignment"
  },
  {
    "objectID": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#sözlükler",
    "href": "posts/2017/12/11/python-programlamaya-giris-sayilar-aritmetik-temel-veri-yapilari/index.html#sözlükler",
    "title": "Python Programlamaya Giriş 2 - Sayılar, Aritmetik, Temel Veri Yapıları",
    "section": "Sözlükler",
    "text": "Sözlükler\nDize, çokuz, ve liste tipleri sıralı tip (sequence type) olarak anılır, çünkü birinci elemandan son elemana kadar iyi tanımlanmış bir düzenleri mevcuttur. Sözlük (dictionary) tipi ise sıralı değildir. Sözlükler, listelerin genelleştirilmiş halidir: Listelerde elemanların referanslarının sıfırdan başlayan tamsayılar olması gerekirken, sözlüklerde ise çok değişik veri tipleri her şey referans olarak kullanılabilir. Bu tür veri tipleri hash table, hash map, veya associative array olarak da bilinirler.\n\nd = {-1.75: \"merhaba\", \"isim\":\"Einstein\"}\nd[-1.75]\n\n'merhaba'\n\n\n\nd[\"isim\"]\n\n'Einstein'\n\n\n\nd[(2,3)] = [1,2,3.14159]\nd\n\n{-1.75: 'merhaba', 'isim': 'Einstein', (2, 3): [1, 2, 3.14159]}\n\n\n\nd[-2.25] = 3 + 5j\nd[1+2j] = 42\nd[\"isim\"] = \"Eisenstein\"\nd\n\n{-1.75: 'merhaba',\n 'isim': 'Eisenstein',\n (2, 3): [1, 2, 3.14159],\n -2.25: (3+5j),\n (1+2j): 42}\n\n\n\ndel d[\"isim\"]\nd\n\n{-1.75: 'merhaba', (2, 3): [1, 2, 3.14159], -2.25: (3+5j), (1+2j): 42}\n\n\nSözlük yaratırken süslü parantezler {} kullanırız. Sözlük elemanlarına ise, çokuzlar ve listelerdeki gibi, köşeli parantez içinde referans değerini yazarak erişiriz. Yeni referans değerlerine sahip sözlük elementleri yaratabilir, istemediğimiz elemanları del komutuyla silebiliriz.\nSözlüklerde referans olarak sadece değiştirilemez tipler kullanılabilir (sayılar, dizeler, çokuzlar). Listeler kullanılamaz.\n\nd[ [1,2,3] ] = 5\n\nTypeError: unhashable type: 'list'"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Hakkımızda",
    "section": "",
    "text": "Veri Bilimi ya da Yapay Öğrenme konusunda -çoğu İngilizce olmakla birlikte- pek çok kaynak mevcut. Ancak veri temizlerken, tahmin modeli çuvalladığında ya da eksik bir sütun yüzünden işler sarpa sarınca yapılacakları derli toplu bir yerde bulmak oldukça güç. Kaldı ki herkesin tecrübeyle biriktirdiği, yastık altında sakladığı bir sürü notu var. İşte bunları konuşurken Veri Defteri diye bir sayfa kurmaya karar verdik. Hem o notları toplayalım, hem de Veri Bilimi ve Yapay Öğrenme konularında duyuruların, parlak fikirlerin, veri kümelerinin yer aldığı bir sayfa yapalım dedik. Veri Defteri her ne kadar üçümüzün başının altından çıktıysa da, zaman içinde tanıdık-tanımadık, hesap-kitap işlerine meraklı arkadaşların da bize destek vereceğini düşündük. Lütfen haberlerinizi, yazdıklarınızı ve önerilerinizi bizden eksik etmeyin.\n\n\n\n\n\n\n\n\n\n\n\nİlker Birbil, doktora çalışmasını 2002 yılında North Carolina State Üniversitesi’nde Endüstri Mühendisliği ana dalı ile Yöneylem Araştırması ve Matematik yan dallarında tamamlamıştır. Ardından 2002 - 2004 yılları arasında Erasmus Yönetim Araştırma Enstitüsü’nde doktora sonrası araştırma bursu ile çalışmalarını sürdüren İlker Birbil, 2004-2017 yılları arasında Sabancı Üniversitesi’nde öğretim üyesi olarak çalışmıştır. Halen Erasmus Üniversitesi Rotterdam’da veri bilimi ve optimizasyon öğretim üyesi olarak görev almaktadır. Matematiksel programlama alanında algoritma tasarımı genel başlığı altında toplanabilecek kuramsal ve uygulamalı pek çok çalışması vardır. Bir süre Radikal gazetesinde, son dönemde de BirGün Pazar’da bilim politikası ve üniversiteler üzerine yazıları yayımlanmıştır. Ayrıca akademik hayat üzerine yazıların yer aldığı Bol Bilim isimli sayfanın kurucularından biridir.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBirol Yüceoğlu, lisans ve yüksek lisans eğitimini Sabancı Üniversitesi Endüstri Mühendisliği bölümünde tamamladı. Doktora eğitimini 2015 yılında Maastricht Üniversitesi’nde Yöneylem Araştırması üzerine yaptı. Halen Migros T.A.Ş. Ar-Ge Merkezi’nde çalışmakta ve Sabancı Üniversitesi Veri Analitiği Tezsiz Yüksek Lisans programında ders vermektedir. Araştırma alanları veri analizi uygulamaları, çizge teorisi ve tamsayı programlamadır.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKaan Öztürk, fizik lisans ve yüksek lisans derecelerini Boğaziçi Üniversitesi’nden, fizik doktora derecesini Rice Üniversitesi’nden aldı. Işık ve Yeditepe üniversitelerinin bilişim bölümlerinde öğretim üyesi olarak görev yaptı. 2015-2016 döneminde TÜBİTAK desteğiyle Rice Üniversitesi’nde ziyaretçi araştırmacı, 2016-2017 döneminde ise Sabancı Üniversitesi’nde doktoraüstü araştırmacı olarak çalıştı. 2017-2019 arasında Boğaziçi Üniversitesi Bilgisayar Mühendisliği bölümünde programlamaya giriş dersleri verdi. 2019’dan beri özel sektörde veri bilimi uzmanı olarak çalışıyor."
  },
  {
    "objectID": "posts/2017/12/16/python-programlamaya-giris-secim-yapma-mantik-islemleri-karsilastirmalar/index.html",
    "href": "posts/2017/12/16/python-programlamaya-giris-secim-yapma-mantik-islemleri-karsilastirmalar/index.html",
    "title": "Python Programlamaya Giriş 3 - Seçim yapma, Mantık İşlemleri, Karşılaştırmalar",
    "section": "",
    "text": "Yeni başlayanlar için Python programlama temellerini işlediğimiz yazı dizimizin bu bölümünde karar verme yapısından bahsedeceğiz.\nEn basit programlarda bile sık sık “şu şart doğruysa şöyle yap, yoksa yapma”, veya “doğruysa şöyle yap, yanlışsa öbür türlü yap” şeklinde düzenlemelere ihtiyaç duyarız. Sözgelişi, “cevap doğruysa puanı bir arttır”, veya “yanlış sayısı dördün katıysa puanı bir azalt” gibi. Birçok dil gibi Python’da da seçim yapısı if-else komutlarıyla kurulur.\n\nif komutu\nKarar yapılarının en basit hali, bir şartın doğruluğunu yoklamak ve doğruysa belli işlemler yapmaktır. Sözgelişi aşağıdaki programa bakalım. Hücreyi Shift-Enter ile çalıştırdığımızda tahminimizi soran bir kutu ortaya çıkacak. Kutuya bir cevap yazıp Enter’e basın.\n\nhedef = \"42\"\ntahmin = input(\"Tahmininiz: \")\nif tahmin == hedef:\n    print(\"Doğru!\")\n\nTahmininiz: 42\nDoğru!\n\n\nSayı hedef değerine (\"42\") eşitse ekrana \"Doğru!\" yazısını basacak, değilse birşey yapmayacak. Şarttan sonra iki nokta üstüste (:) koymayı da unutmayın.\n(Bu hücredeki kodu kendi başına çalışan bir betik haline getirmek için, kodu kopyalayıp bir metin editörüne yapıştırın ve tahmin.py isimli bir dosya olarak kaydedin. Böylece komut satırında çalıştırabilirsiniz:\n$ python3 tahmin.py\nTahmininiz: 42\nDoğru!\nşeklinde bir çıktınız olmalı)\nif’den sonra tahmin’in hedef’e eşit olup olmadığını yoklayan bir mantık ifadesi var. Bunun değeri ya doğru (True) ya da yanlış (False) olacak. Eşitlik şartı için == (iki tane eşit işareti) kullanıldığına dikkat edin.\n\n1 == 1\n\nTrue\n\n\n\n1 == 2\n\nFalse\n\n\n\n1 = 1\n\nSyntaxError: can't assign to literal (&lt;ipython-input-3-4c0a01f26144&gt;, line 1)\n\n\nŞarttan sonraki satırlara, şart doğruysa çalıştırılacak kod parçası (if bloku) gelir. Burada Python’un kendine özgü bir kuralını görüyoruz: Bloktaki her ifade, if başlığına göre belli bir miktar sağa kaydırılmalıdır. Yorumlayıcı hangi komutların if blokuna ait olduğunu bu kaydırma sayesinde ayırt eder.\nMeselâ şu iki ayrı programa bakalım:\nhedef = \"42\"\ntahmin = input(\"Tahmininiz: \")\nif tahmin == hedef:\n    print(\"Doğru!\")\n    print(\"Bravo\")\nve:\nhedef = \"42\"\ntahmin = input(\"Tahmininiz: \")\nif tahmin == hedef:\n    print(\"Doğru!\")\nprint(\"Bravo\")\nİkinci programdaki\nprint \"Bravo\"\nkomutu if blokunun dışında olduğu için, tahmin doğru olsa da olmasa da çalıştırılır. Deneyin.\nif içindeki blokun kaç boşluk sağa kaydırılacağı önemli değildir; bir tek boşluk bile yeterlidir. Çoğu IDE otomatik olarak dört boşluk genişlikte bir sıçrama yapar; Python programcılık camiasında tavsiye edilen de budur. Sonraki satırlar da aynı kaydırma seviyesinde başlar. Bu yüzden, bloku bitirmek için yeni satıra geçtikten sonra geriye silme (Backspace) tuşuna basmalısınız.\n\n\nif-else komutu\nYukarıdaki program bize sadece tahminimiz doğruysa bir cevap veriyor. Tahminimizin yanlış olduğunu da söylemesini istersek if-else yapısını kullanırız.\n\nhedef = \"42\"\nx = input(\"Tahmininiz: \")\nif x == hedef:\n    print(\"Doğru!\")\nelse:\n    print(\"Yanlış\")\n\nTahmininiz: 43\nYanlış\n\n\nelse ifadesinden sonra herhangi bir şart gelmez, çünkü else bloku zaten sadece if şartı yanlışsa çalıştırılır. else kelimesinin, bağlı olduğu if ile aynı kaydırma seviyesinde olduğuna dikkat edin.\nHer else bir if’e bağlı olmalıdır, ama tersi doğru değildir. Her if’e bir else gerekmez.\n\n\nif-elif-else komutu\nif kullanımının en genel hali budur. elif kelimesi else if’in kısaltmasıdır.\n\nx = int(input(\"Kaç tane? \"))\nif x&gt;2000:\n    print(\"Binlerce\")\nelif x&gt;200:\n    print(\"Yüzlerce\")\nelif x&gt;10:\n    print(\"Çok\")\nelif x&gt;0:\n    print(\"Birkaç\")\nelse:\n    print(\"Yok\")\n\nKaç tane? 87\nÇok\n\n\nAynı programı elif kullanmadan ancak şöyle yazabiliriz:\n\nx = int(input(\"Kaç tane? \"))\nif x&gt;2000:\n    print(\"Binlerce\")\nelse:\n    if x&gt;200:\n        print(\"Yüzlerce\")\n    else:\n        if x&gt;10:\n            print(\"Çok\")\n        else:\n            if x&gt;0:\n                print(\"Birkaç\")\n            else:\n                print(\"Yok\")\n\nGörüldüğü gibi elif kullanmak programı sadeleştiriyor.\n\n\nKarşılaştırmalar\nif’den sonra, mantıksal olarak doğru veya yanlış sayılacak ifadeler gelmelidir. Eşitlikten yukarıda bahsettik. Ayrıca &gt; (büyük), &lt; (küçük), &gt;= (büyük veya eşit), &lt;= (küçük veya eşit) ve != (eşit değil) işlemleri kullanılabilir.\n\n2 &gt; 3, 2 &gt;= 3, 2 &lt; 3, 2 &lt;= 3, 2 != 3\n\n(False, False, True, True, True)\n\n\nSayı olmayan veri yapıları da karşılaştırmalarda kullanılabilirler. O durumda, eşitsizliklerin değerlendirilmesinde alfabetik sıra kullanılır.\n\n\"hello\" == \"Hello\", \"hello\" &gt; \"Hello\", \"hello\" &lt; \"jello\"\n\n(False, True, True)\n\n\n\n[1,2,3] &lt; [1,20,3], [1,2,3] &lt; [11,2,3]\n\n(True, True)\n\n\nDaha fazla bilgi için Python dili referansına bakabilirsiniz.\nBir veri yapısı içinde belli bir eleman veya alt grubun bulunup bulunmadığını in kelimesiyle test edebilirsiniz. Şartı ters çevirmek için not in kullanılır.\n\nL = [12,3,4,[5,6]]\n3 in L, [3,4] in L, [5,6] in L, [5,6] not in L\n\n(True, False, True, False)\n\n\n\ns = \"merhaba\"\n\"a\" in s, \"erh\" in s\n\n(True, True)\n\n\nSözlüklerde in kelimesi sadece referanslar içinde yoklama yapar.\n\nd = {\"abc\": 54, (1,2): -45.1}\n\"abc\" in d, 54 in d, (1,2) in d\n\n(True, False, True)\n\n\n\n\nDoğru ve yanlış sabitleri\nTrue ve False, aslında 1 ve 0 sayılarına verilen yeni isimlerdir. Ayrıca,\n[], {}, \"\", None, 0, 0.0, False\nifadelerinin her biri mantıksal yanlış anlamı taşır. Tersine olarak da, sıfırdan farklı her sayı veya boş olmayan herhangi bir liste/çokuz/dize/sözlük if yapılarında mantıksal doğru olarak yorumlanırlar.\n\nL=[]\nif L:\n    print(\"Liste dolu\")\nelse:\n    print(\"Liste boş.\")\n\nListe boş.\n\n\n\ns = \"abc\"\nif s:\n    print(s)\nelse:\n    print(\"Boş\")\n\nabc\n\n\n\n\nMantıksal işlemler\nBirden fazla şartı Boole işlemleri (and, or, not) ile biraraya getirerek, daha karmaşık şartlar oluşturmak mümkün olur.\n\nX and Y : Hem X hem Y doğruysa doğru; X ve Y’den en az biri yanlışsa yanlış.\nX or Y : X ve Y’den en az biri doğruysa doğru; hem X hem Y yanlışsa yanlış.\nnot X : X’in doğruluk değerinin tersi.\n\n\n1 &lt; 2 and 3==3\n\nTrue\n\n\n\n1 &lt; 2 and 3==4\n\nFalse\n\n\n\n1 &lt; 2 or 3==4\n\nTrue\n\n\n\n1 &gt; 2 or 3==4\n\nFalse\n\n\n\nnot 1&gt;2\n\nTrue\n\n\n\nnot 3==3\n\nFalse\n\n\nBoole ifadelerinde ikiden fazla bileşen de kullanılabilir. Önce not işlemi, sonra and işlemi, sonra da or işlemi yapılır. Aynı işlem yapılıyorsa, bileşenler soldan sağa çifter çifter alınır.\n\n1 == 2 or 3 &gt; 4 or 5 &lt; 8\n\nTrue\n\n\n\n1 != 2 and not 3 &gt; 4 and 5 &lt; 8\n\nTrue\n\n\n\n1 != 2 and 3 &lt;= 4 or 5 &gt; 10 and 7 &gt; 8\n\nTrue\n\n\n\n\n“Kısa devre” işlemler\nMantıksal işlemlerin yan etkileri vardır: Mantıksal or (veya) işleminde, işlenen değerlerden sadece birisinin doğru olması işlem sonucunun doğru olması için yeterlidir. Bu yüzden, Python X or Y işlemini yaparken X’in doğru olduğunu görürse Y’ye hiç bakmaz, onu değerlemez, ve işlem sonucu olarak X’in değerini geri verir. Buna kısa devre hesaplama adı verilir. Eğer X doğru değilse, Y ne olursa olsun, Y’yi verir.\nKısa devre özelliği hesaplama verimliliği de sağlar. Bazen bu işlemlerin bileşenleri karmaşık işlemlerle elde ediliyor olabilir. Sözgelişi Y yerine, bir fonksiyon çağrısı koyuyor olabiliriz, ve bu fonksiyon ağır işlemler yapıyor olabilir. Böyle durumlarda kısa devre işlemler hesaplamada verimlilik sağlarlar, Y’yi boş yere hesaplamazlar.\nAşağıdaki örnekte, \"abc\" doğru sayıldığı için, print işlemi hiç yapılmadan \"abc\" geri verilir.\n\n\"abc\" or print(\"mrb\")\n\n'abc'\n\n\nAşağıdaki örnekte, or işleminin değerini anlamak için print komutu işlenir. Bunun yan etkisi olarak \"mrb\" yazılır. Ama print çağrısı None verir, o yüzden or işlemi de None sonucu verir.\n\nFalse or print(\"mrb\")\n\nmrb\n\n\n\n0 or 3\n\n3\n\n\nBenzer bir durum X and Y işlemi için de geçerlidir. Eğer X mantıksal olarak yanlışsa, Yne olursa olsun bütün ifade yanlış olur, böylece X değeri geri verilir. Ama X doğruysa, işlemin doğruluk değeri Y’ye bağlıdır, ve Ydeğeri geri verilir.\n\n2 and 3\n\n3\n\n\n\n3 and print(\"mrb\")\n\nmrb\n\n\n\n0 and 2\n\n0\n\n\n\n[] and False\n\n[]\n\n\nBu özellik çeşitli “hack”ler için kullanılabilir. Sözgelişi\nX = A or B or C or None\nifadesi, X’in, A, B, C arasında boş olmayan ilk nesneye atanmasını, veya None olmasını sağlar. Aynı şeyi if-elif-else kullanarak yapmak daha uzun bir kod gerektirir.\nif A:\n    X = A\nelif B:\n    X = B\nelif C:\n    X = C\nelse:\n    X = None\n\n\nÜçlü if-else ifadesi\nBirçok durumda, bir değişkene, bir şartın doğru veya yanlış olmasına göre farklı değerler atarız. Sözgelişi, x mantık ifadesinin doğru olması halinde a’ya y değeri verelim, aksi takdirde z verelim.\nif x:\n    a = y\nelse:\n    a = z\nÜçlü if-else ifadesiyle aynısını daha kısa olarak şöyle yazabiliriz:\na = y if x else z\nÖrnek olarak, m’ye x’in mutlak değerini atayalım.\n\nx = float(input(\"Bir sayı girin: \"))\nm = x if x&gt;0 else -x\nprint(m)\n\nBir sayı girin: -1.4\n1.4\n\n\nEn baştaki örneği de şöyle yazabiliriz.\n\nhedef = \"42\"\nx = input(\"Tahmininiz: \")\nprint(\"Doğru!\" if x == hedef else \"Yanlış\")\n\nTahmininiz: 43\nYanlış\n\n\nBir if-elif-else blokunu üçlü if-else ifadesi olarak yazabiliriz. Sözgelişi\nif rating &gt; 100:\n    sinif = \"A\"\nelif rating &gt; 50:\n    sinif = \"B\"\nelse:\n    sinif = \"C\"\nyerine\nsinif = \"A\" if rating &gt; 100 else \"B\" if rating &gt; 50 else \"C\"\nyazılabilir. Ama aşırıya kaçırırsanız programın okunması zorlaşır."
  },
  {
    "objectID": "posts/2017/12/20/python-programlamaya-giris-donguler/Python Programlamaya Giriş - Döngüler.html",
    "href": "posts/2017/12/20/python-programlamaya-giris-donguler/Python Programlamaya Giriş - Döngüler.html",
    "title": "Python Programlamaya Giriş 4 - Döngüler",
    "section": "",
    "text": "Python programlamanın temellerini anlattığımız yazı dizimizin bu bölümünde belli bir kod blokunun tekrar tekrar çalıştırılması anlamına gelen döngülerden bahsedeceğiz. Döngüler her türlü programın temel yapı taşlarındandır.\nDöngüler, daha önce bahsettiğimiz karar yapısı if ile benzer bir yapıya sahiptir. Blok kaydırma yapısı ve mantıksal şartlara aşina değilseniz önce karar yapısını anlattığımız bölümü okumanız iyi olur."
  },
  {
    "objectID": "posts/2017/12/20/python-programlamaya-giris-donguler/Python Programlamaya Giriş - Döngüler.html#iç-içe-döngüler",
    "href": "posts/2017/12/20/python-programlamaya-giris-donguler/Python Programlamaya Giriş - Döngüler.html#iç-içe-döngüler",
    "title": "Python Programlamaya Giriş 4 - Döngüler",
    "section": "İç içe döngüler",
    "text": "İç içe döngüler\nBir döngü blokunun içine istediğiniz her türlü kodu koyabilirsiniz. Başka bir döngü koymak da buna dahil. Sözgelişi, iki ayrı parametre üzerinden döngü yapmak istediğinizde bir döngü içinde başka bir döngü kullanırsınız.\nÖrnek olarak, \\(1^p + 2^p + \\cdots + 10^p\\) toplamını, \\(p\\)’nin 1-6 arasındaki değerleri için ekrana yazacak bir program yazalım. Yukarıda böyle bir seri toplamın bir döngü içinde nasıl hesaplandığını gördük. Her bir \\(p\\) için ayrıca bir hesap yapacağız. Demek ki toplamı hesaplama döngüsünü, \\(p\\)’nin 1 ile 6 arasında değiştiği bir döngünün içine koymalıyız.\nİçiçe döngüler yazmanın en kolay yolu, dış döngüdeki parametreleri sabit tutup en içteki döngüyle başlamaktır. İlk aşamada \\(1^p + 2^p + \\cdots + 10^p\\) toplamını sadece \\(p=1\\) için hesaplayalım.\n\np=1\na=1\nb=10\ntoplam=0\nwhile a&lt;=b:\n    toplam += a**p\n    a += 1\nprint(\"p =\",p,\", 1^p + ... + 10^p =\", toplam)\n\np = 1 , 1^p + ... + 10^p = 55\n\n\nŞimdi yapmamız gereken bunu \\(p=2,3,4,5,6\\) için tekrarlamak. Tembel işi yapıp, aynı kodu altı kere yapıştırıp \\(p\\) değerlerini değiştirebiliriz.\n\np=1\na=1\nb=10\ntoplam=0\nwhile a&lt;=b:\n    toplam += a**p\n    a += 1\nprint(\"p =\",p,\", 1^p + ... + 10^p =\", toplam)\n\np=2\na=1\nb=10\ntoplam=0\nwhile a&lt;=b:\n    toplam += a**p\n    a += 1\nprint(\"p =\",p,\", 1^p + ... + 10^p =\", toplam)\n\np=3\na=1\nb=10\ntoplam=0\nwhile a&lt;=b:\n    toplam += a**p\n    a += 1\nprint(\"p =\",p,\", 1^p + ... + 10^p =\", toplam)\n\np=4\na=1\nb=10\ntoplam=0\nwhile a&lt;=b:\n    toplam += a**p\n    a += 1\nprint(\"p =\",p,\", 1^p + ... + 10^p =\", toplam)\n\np=5\na=1\nb=10\ntoplam=0\nwhile a&lt;=b:\n    toplam += a**p\n    a += 1\nprint(\"p =\",p,\", 1^p + ... + 10^p =\", toplam)\n\np=6\na=1\nb=10\ntoplam=0\nwhile a&lt;=b:\n    toplam += a**p\n    a += 1\nprint(\"p =\",p,\", 1^p + ... + 10^p =\", toplam)\n\np = 1 , 1^p + ... + 10^p = 55\np = 2 , 1^p + ... + 10^p = 385\np = 3 , 1^p + ... + 10^p = 3025\np = 4 , 1^p + ... + 10^p = 25333\np = 5 , 1^p + ... + 10^p = 220825\np = 6 , 1^p + ... + 10^p = 1978405\n\n\nİstediğimizi yapıyor, ama güzel bir çözüm yöntemi değil. Birincisi, programımız gereksiz derecede uzuyor ve okuması zorlaşıyor. İkincisi, \\(p\\) için farklı değerlerle hesabı tekrarlamak istediğimizde hepsini elden geçirmemiz, silmemiz veya eklememiz gerekiyor. Aynı hesabı \\(p\\)’yi -100 ile 100 arasında tekrarladığınızı düşünün!\nMuhtemelen bu aşamada en güzel çözümün kodun etrafına bir dış döngü sarmak olduğunu gördünüz bile.\n\np=1\nwhile p&lt;=6:\n    a=1\n    b=10\n    toplam=0\n    while a&lt;=b:\n        toplam += a**p\n        a += 1\n    print(\"p =\",p,\", 1^p + ... + 10^p =\", toplam)\n    p += 1\n\np = 1 , 1^p + ... + 10^p = 55\np = 2 , 1^p + ... + 10^p = 385\np = 3 , 1^p + ... + 10^p = 3025\np = 4 , 1^p + ... + 10^p = 25333\np = 5 , 1^p + ... + 10^p = 220825\np = 6 , 1^p + ... + 10^p = 1978405"
  },
  {
    "objectID": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html",
    "href": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html",
    "title": "Python Programlamaya Giriş 1 - İlk adımlar",
    "section": "",
    "text": "Bu yazıyla, yeni başlayanlara Python programlama dilini öğreten bir yazı dizisine başlıyoruz. İlk yazımızda Python’u kurma, etkileşimli olarak çalıştırma, basit bir Python programı (betiği) hazırlama, ve bir Jupyter defteri kullanma konularını açıklayacağız.\nYirmiüç bölümlük bu dizide Python’da program akış kontrolü, fonksiyonlar, dizeler, listeler, sözlükler, dosya okuma/yazma, hata yakalama, modüller, ve nesneye yönelik programlama konularını işleyeceğiz. Anlatımı çok temel bir seviyede tutacağımız için başka bir programlama dili bilmeniz gerekli değil. Nitekim Python, sözdiziminin sadeliği sebebiyle, programlamayı yeni öğrenenler için en uygun dillerden biri."
  },
  {
    "objectID": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#kurulum",
    "href": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#kurulum",
    "title": "Python Programlamaya Giriş 1 - İlk adımlar",
    "section": "Kurulum",
    "text": "Kurulum\nPython programlarını yazmak için gereken şeyler çok az: Sadece bir metin editörüne (text editor) ve Python yorumlayıcısına ihtiyacınız var. Metin editörü ile programı yazarsınız, ve yorumlayıcıya bu dosyayı okuyup çalıştırmasını söylersiniz. Hepsi bu.\nMetin editörü olarak notepad, emacs, gedit gibi programlar kullanılabilir. Ancak Word, LibreOffice Writer gibi kelime işlemcileri kullanamazsınız. Bunlar yazıları kendilerine özgü bir biçimde saklarlar ve Python yorumlayıcısı bu dosyaları okuyamaz.\nPython yorumlayıcısını Python resmi sayfasından indirip kolayca kurabilirsiniz. Her platformda (Windows, MacOS, Unix, Linux,…) çalışabilen bir Python derleyicisi vardır. Bir makinede yazdığınız bir Python programını, gerekli yorumlayıcının mevcut olduğu başka bir makinede, farklı bir işletim sistemi kullansa bile, çalıştırabilirsiniz.\nPython yorumlayıcısı sisteminizde mevcut bile olabilir. Linux kullanıyorsanız zaten kuruludur çünkü birçok sistem programı Python kullanır. Ubuntu, Fedora vs gibi paket yönetim sistemi olan bir dağıtım kullanıyorsanız, paket yöneticisi aracılığıyla kurmanız daha iyi olabilir.\nBir editör ve yorumlayıcı, program yazmanız ve çalıştırmanız için yeterlidir. Gerisi teferruattır, ve başlangıç için şart değildir. Ama Python bazı geliştirme araçları size hız ve kolaylık sağlar. Söz gelişi IDLE, Spyder, PyCharm gibi bir IDE (bütünleşik geliştirme ortamı) kullanmayı tercih edebilirsiniz. Bunlardan daha sonra bahsedeceğiz.\nPython kurmak için başka bir yol da Anaconda veya Canopy gibi Python dağıtımları. Bunların en büyük avantajı, ileri seviye kullanıcıların ihtiyaç duyduğu modüllerin, sürümleri birbiriyle uyumlu olacak şekilde seçilerek bir araya getirilmiş olmaları. Spyder, Jupyter Notebook gibi yazılımlar da bu dağıtımlarla geliyor. Tabii bu modülleri ayrı ayrı da kurabilirsiniz, mutlaka bu dağıtımlara bağlı olmaya ihtiyacınız yok."
  },
  {
    "objectID": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#python-2.7-mi-3.x-mi",
    "href": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#python-2.7-mi-3.x-mi",
    "title": "Python Programlamaya Giriş 1 - İlk adımlar",
    "section": "Python 2.7 mi 3.x mi?",
    "text": "Python 2.7 mi 3.x mi?\nKurulumda kullanacağınız paketi seçerken ilk karşınıza çıkacak soru Python 2.7 ile Python 3.6 (veya bu yazıyı okuduğunuz tarihe göre, 3.7, 3.8, vs.) arasında seçim yapmaktır.\nKısa cevap: En son sürümü seçin. Python’u yeni öğreniyorsanız Python 2.7’ye bakmayın bile.\nPython 1990’dan 2000’e kadar yavaş yavaş gelişti. 2000’de Python 2.0 çıktı, ve ardından kullanımı yavaş yavaş yaygınlaştı. Bir süre sonra, tasarımındaki bazı eksikliklerin geriye doğru uyumlu kalarak düzeltilemeyeceği farkedildi. 2008 yılında Python 2.6 ile beraber, eskisiyle tamamen uyumlu olmayan Python 3.0 ilan edildi. Bundan sonra bir süre Python’un gelişimi iki daldan devam etti. 2009 yılında Python 2.7 ve Python 3.1 çıktı. Python 3 dalındaki bazı iyileştirmeler, uyumlu oldukları ölçüde, 2.7 dalına da aktarıldı. Ancak Python 2 dalının 2.7’de sonlandırılmasına karar verildi. Python Vakfı 2.7 sürümünü 2020’ye kadar destekleyeceğini, bu arada herkesin Python 3’e geçmesi gerektiğini ilan etti.\nYakın zamana kadar bazı önemli modüller sadece Python 2.7 ile çalıştığı için, birkaç yıl önce Python 2 ile Python 3 arasında karar vermek için biraz düşünmek gerekirdi. Artık öyle bir mesele yok. Basitçe, Python 2.7 geçmişte kaldı. Modern Python sadece 3.x ve üstü sürümlerdir.\nElinizde geçmişten kalma bazı Python 2.7 betikleri varsa, bunları Python’la beraber gelen 2to3 aracıyla Python 3.x sürümlerine uyumlu hale getirebilirsiniz."
  },
  {
    "objectID": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#basit-etkileşimli-kullanım",
    "href": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#basit-etkileşimli-kullanım",
    "title": "Python Programlamaya Giriş 1 - İlk adımlar",
    "section": "Basit etkileşimli kullanım",
    "text": "Basit etkileşimli kullanım\nPython’u işletim sisteminizin komut yorumlayıcısı ile (DOS command prompt veya shell/terminal) çalıştırıp etkileşimli olarak kullanabilirsiniz. Dolar ($) işareti komut yorumlayıcısının işareti. Aşağıdaki ekran görüntüsünde bazı örnekler görülüyor. &gt;&gt;&gt; işareti Python’un bir komut beklediğini gösteriyor. Komutu yazdıktan sonra işlenmesi için Enter tuşuna basın.\n\nPython etkileşimli halde çalışırken, bir ifadeyi yazıp Enter’a basmanız ifadenin değerinin ekrana yazılmasını sağlar. Meselâ “2+2” yazıp Enter’e bastığımızda “4” yazması sadece etkileşimli modda mümkün. Bir betiğin (programın) içinde “2+2” ifadesinin değeri hesaplanır, ama ekrana basılmaz. Betik içindeki bir ifadenin değerinin ekrana basılmasını istiyorsanız için print() fonksiyonunu kullanmalısınız.\nYorumlayıcıyı kapatmak için quit() yazabilir, ya da Ctrl-D (Linux) veya Ctrl-Z (Windows) tuşlarına basabilirsiniz.\nPython’u sadece tek bir işlem için kullanacaksanız, etkileşimli oturum açmak yerine, komut satırında -c parametresi vererek de çalıştırabilirsiniz. Meselâ şöyle:"
  },
  {
    "objectID": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#program-çalıştırma",
    "href": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#program-çalıştırma",
    "title": "Python Programlamaya Giriş 1 - İlk adımlar",
    "section": "Program çalıştırma",
    "text": "Program çalıştırma\nPython programları, bir düz metin dosyasına yazılmış Python ifadelerinden ibarettir. Notepad, emacs, gedit gibi herhangi bir düz metin editörü açın ve aşağıdaki satırları yazın. Dosyayı ortalama.py ismiyle kaydedin.\na = float(input(\"Bir sayı girin: \"))\nb = float(input(\"Bir sayı girin: \"))\nc = float(input(\"Bir sayı girin: \"))\nd = float(input(\"Bir sayı girin: \"))\n\nprint(\"Ortalama:\", (a+b+c+d)/4)\nKomut terminalini açıp dosyayı kaydettiğiniz dizine geçin ve python ortalama.py yazıp Enter’a basın. (Windows’ta dosya ikonuna tıklamak yeterli olacaktır). Program çalışınca ayrı ayrı dört reel sayı yazıp Enter’a basın.\n\na = float(input(\"Bir sayı girin: \")) satırında, input() fonksiyonu ekrana Bir sayı girin: yazısını çıkarır ve siz klavyeyle bir şey yazana kadar bekler. Sizden aldığı cevabı bir “dize”, yani yazı olarak geri verir. Bu dizeyi aritmetik işlemde kullanabilmek için önce sayısal değere çevirmemiz gerekir. input() çağrısının etrafına sarılı `float() fonksiyonu bu işi yapar.\nBunu adım adım şöyle düşünebilirsiniz:\na = float(input(\"Bir sayı girin: \"))\na = float(\"1.2\")\na = 1.2\nAlternatif olarak, kodumuzu şöyle de yazabilirdik:\na = input(\"Bir sayı girin: \")\na = float(a)\nb = input(\"Bir sayı girin: \")\nb = float(b)\nc = input(\"Bir sayı girin: \")\nc = float(c)\nd = input(\"Bir sayı girin: \")\nd = float(d)\n\nprint(\"Ortalama:\", (a+b+c+d)/4)"
  },
  {
    "objectID": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#bütünleşik-geliştirme-ortamları-ide",
    "href": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#bütünleşik-geliştirme-ortamları-ide",
    "title": "Python Programlamaya Giriş 1 - İlk adımlar",
    "section": "Bütünleşik Geliştirme Ortamları (IDE)",
    "text": "Bütünleşik Geliştirme Ortamları (IDE)\nProgramlama için her ne kadar bir metin editörü yetse de, bir IDE’nin sağladığı kolaylıklar yabana atılamaz. Sözgelişi kod parçalarını renklendirerek okunurluğu artırmak, yazılan komutu otomatik tamamlayabilmek, çevrimiçi yardım belgelerine erişebilmek, bir çok dosya içeren yazılım projelerini organize edebilmek, hata ayıklayıcı ile editörü birleştirmek gibi imkânlar sağlarlar.\n\nIDLE\n\nIDLE, Python’la birlikte gelen basit ve minimal bir IDE’dir. Çok fazla bir imkân sağlamasa da, hafifliği ve her yerde bulunabilirliği sebebiyle varlığının farkında olmakta fayda var.\nIDLE’ı çalıştırdığınızda, önce Python yorumlayıcısını etkileşimli kullanabileceğiniz bir pencere çıkar. File menüsünden New file seçerek bir editör penceresi açılabilir, veya Open… seçerek editöre mevcut bir dosya yüklenebilir. Editördeki Python programı, F5 tuşuna basarak yorumlayıcı penceresinde çalıştırılabilir.\n\n\nSpyder\n\nIDLE’yi kullandıkça bir çok amaç için yetersiz kaldığını göreceksiniz. Daha güçlü bir IDE olarak Spyder’ı tavsiye ederim. Spyder’da tek bir pencere içinde editör, komut penceresi, dizin ağacı, değişken listesi, ve çevrimiçi yardım bulunabilir."
  },
  {
    "objectID": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#jupyter-notebook",
    "href": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#jupyter-notebook",
    "title": "Python Programlamaya Giriş 1 - İlk adımlar",
    "section": "Jupyter Notebook",
    "text": "Jupyter Notebook\nEtkileşimli hesaplamada başka bir yaklaşım kodu “defter” denilen biçimde düzenlemektir. Jupyter notebook kullandığınızda komutlar “hücreler” ile organize edilir. Her hücre çalıştırıldığında, hücredeki komutlar defterin bağlı olduğu “çekirdeğe” (yorumlayıcıya) gönderilir, geri gelen cevaplar hücrenin altına yazılır. Bu şekilde bir dizi işlemin çıktısını kaydeden bir rapor hazırlamak mümkün olur. Bir Jupyter defterinde yazı, kod, şekil, formül, HTML elemanları bir arada bulunabilir.\nBu yazı ve birçok başka yazımız Jupyter defteri olarak hazırlandı, nbconvert aracıyla HTML’ye çevrilerek doğrudan blogumuza aktarıldı.\nBir Jupyter defteri HTML ve JavaScript teknolojileri ile hazırlanmıştır. Tarayıcınızda çalışır, ama kullanmak için internet bağlantısına ihtiyacınız olmaz.\nJupyter defterleriyle ilgili daha ayrıntılı bilgiyi diğer yazılarımızda bulabilirsiniz. Temel bir başlangıç için Jupyter Notebook Nedir yazımıza bakabilirsiniz."
  },
  {
    "objectID": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#alıştırmalar",
    "href": "posts/2017/12/08/temel-python-programlama-ilk-adimlar/index.html#alıştırmalar",
    "title": "Python Programlamaya Giriş 1 - İlk adımlar",
    "section": "Alıştırmalar",
    "text": "Alıştırmalar\nPython’a ısınmak için küçük işler yaparak işe başlayabilirsiniz.\n\nPython yorumlayıcısını etkileşimli kullanarak aşağıdaki değerleri hesaplayın. \\[\\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} + \\frac{1}{16}\\] \\[(2.1^3 - 4.7^{-4.3}) / (2.5^{0.5} + 10^{0.25})\\] \\[x=1,2,3 \\ \\mathrm{için}\\ x^3 - 3x^2 + 5x -1\\]\nAritmetik ortalama alma programına ekleme yapın: Program girilen sayıların standart sapmasını, geometrik ortalamasını ve harmonik ortalamasını hesaplayıp ekrana yazsın. Karekök almak için \\(\\sqrt{x} = x^{0.5}\\) denkliğini kullanabilirsiniz."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "",
    "text": "Veri bilimi deyince bugün akla ilk gelen programlama dillerinden biri Python. Python 1996’da doğdu, ama uzun zaman bilimsel uygulamalarda diğer dillerin gölgesinde kaldı. Hakettiği yere son on yıl içinde ulaştı ancak. Son yıllarda programlama dillerinin yaygınlığı sıralamalarında düzenli olarak ilk üçe yerleşiyor.\nBu başarının kökünde Python’un kolay öğrenilen, kolay okunan bir dil olması yatıyor. Üstelik “çıplak” bir dil değil; çok zengin bir standart kütüphane ile birlikte geliyor. Matematik fonksiyonlarından düzenli ifadelere, süreç kontrolünden HTTP’ye, hatta Tkinter grafik arayüzüne kadar. Bu, Python’un “pilleri içindedir” sloganıyla özetlenen yaklaşımından kaynaklanıyor.\nPython nesneye yönelik bir dil. Python’daki her şey, tamsayılar ve karakterler bile bir nesnedir. Ama nesneye yönelik programlama yapmanız gerekmiyor. En basit kullanımda, nesneleri kullandığınızın farkında bile olmazsınız. Prosedürel programlama ile başlayıp, sonra isterseniz kendi sınıflarınızı tanımlayıp nesneye yönelik programlama yapmaya geçebilirsiniz. Python’un çeşitli fonksiyon araçlarıyla fonksiyonel programlama da yapabilirsiniz.\nPython’u mevcut programlarınızı otomatik olarak çalıştırmak için kullanabilirsiniz. Bir programın çıktısını alıp, bir diğerine uygun hale getiren bir program yazarak iş akışınızı otomatikleştirebilirsiniz. Böylelikle sık yaptığınız analizleri tek bir komutla tamamlayabilir, gerektiğinde kolaylıkla tekrar üretebilirsiniz.\nYorumlanan bir dil olan Python, derlenen dillere (C, Fortran, vs.) göre daha yavaş çalışır. Bu hız farkı 20-30 kata varabilir. Ama Python’un zaman açısından başka kozları da vardır; program geliştirme sürecini kolaylaştıran bir sadeliğe sahip olması gibi. Sözgelişi, bir düz metin dosyasını tarayıp, içindeki kelimelerin istatistiklerini çıkarmak, n-gramlar oluşturmak Python’da belki bir saatte yapılabilecek bir iştir. Ama bunu C ile yapmaya çalışmak birkaç gün, veya daha fazlasını alabilir. Ortaya çıkan Python programı işini diyelim 2 dakikada tamamlasın, C programı 10 saniyede. Hangisiyle işi daha çabuk bitirdik?\nTabii bu örnek bir kerelik işlemler için geçerli. Eğer bu işi binlerce kere tekrarlamamız gerekiyorsa C programı için yatırdığımız zaman kendini amorti edebilir. Ama bu durumda bile Python yardımımıza yetişiyor. Python/C uygulama arayüzü sayesinde C programları içinde Python veri yapıları ve fonksiyonlarına erişebilir, Python’un sağladığı yüksek seviyeli işlevlerden faydalanabiliriz. Veya Python programları içinde hesaplama yükü ağır olan kısımları C ile yazıp, bir Python modülü olarak derleyebiliriz. Nitekim Numpy, SciPy, Numba gibi yüksek performanslı paketlerin hızlı çalışması gereken kısımları C ile yazılmıştır.\nPython’un başarısı sadece güzel tasarımından ve kullanım kolaylığından kaynaklanmıyor. Benzer kolaylıkta başka diller de var. Sözgelişi Ruby de sade, kolay öğrenilen ve güçlü bir dildir, ama Python kadar yaygınlaşamadı. Python’un sevilmesinin en büyük sebeplerinden biri, akla gelebilecek neredeyse her uygulama alanında çok kaliteli kütüphaneler ve API’lerin geliştirilmiş olması. Örneğin Web programlama çatısı Django, üç boyutlu veri görselleme için MayaVi, bilimsel hesaplama için SciPy, veri analizi için pandas, sembolik matematik için SymPy, dinamik web sayfalarından veri almak için Scrapy, görüntü işlemek için PIL, oyun geliştirmek için PyGame, grafik arayüz oluşturmak için wxWidgets ve pyQt, ve daha niceleri…\nBugün bir veri bilimci Python’u tek başına kullanmaz. Python çekirdeğinin çevresinde oluşan bir ekosistem içindeki modüller ve yazılımlar, veri bilimcilerin alet çantasının vazgeçilmez araçlarıdır. Hepsi açık kaynaklı olan bu araçların bazılarına göz atalım."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#python-çekirdeği",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#python-çekirdeği",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "Python çekirdeği",
    "text": "Python çekirdeği\n\n\nPython olgunlaştıkça, dilin ilk tasarımını değiştirme ihtiyacı ortaya çıktı. Bir yerden sonra anlaşıldı ki, geriye dönük uyumluluğu kaldırmadan gerekli değişiklikleri yapmak mümkün değil. O yüzden 2.6 versiyonuyla beraber 3.0 versiyonu da geliştirildi ve birlikte yayınlandı. Yeni Python’un bazı değişiklikleri, 2.x dalına da geriye dönük uyumluluğu bozmayacak şekilde aktarıldı ve 2.7 versiyonu oluştu. Bu, 2.x dalının son versiyonu oldu. Bundan sonra dilin gelişimi sadece 3.x versiyonundan yürüdü.\nHangisini kullanmalısınız? Eğer programlamaya yeni başlıyorsanız düşünmeden 3.x dalındaki en yeni versiyonu kullanın. 2.x dalı artık sadece eski kodları çalıştırmak için gerekiyor.Eğer şimdiye kadar 2.x kullandıysanız endişe etmeyin. Sözdizimi açısından iki dil arasındaki farklar çok az. Eski Python kodlarınızı 3.x’e uyumlu hale getirmek için “Porting Python 2 Code to Python 3” sayfasındaki tavsiyeleri okuyabilirsiniz."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#geliştirme-arayüzü-ide",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#geliştirme-arayüzü-ide",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "Geliştirme arayüzü (IDE)",
    "text": "Geliştirme arayüzü (IDE)\n\n\nBir Python programı, Python ifadeleri içeren bir metin dosyasından ibarettir. Python programı yazmak için aslında bir metin editöründen başka bir şeye ihtiyacınız yok (Word olmaz!). Ancak, yorumlanan bir dil olan Python’u etkileşimli kullanmak, mesela kod yazarken bir yandan yorumlayıcıya bazı komutlar vermek, birçok durumda hayatı kolaylaştırır. Bir IDE kullandığınızda, program editörüyle entegre bir yorumlayıcıya ulaşırsınız; komut tamamlama özelliği ile sekme tuşuna bastığınızda bağlama uyumlu olan isimleri listeler; fonksiyon çağrılarının iç belgelerine (docstrings) ulaşıp çevrimiçi yardım alabilirsiniz; programdaki hataları bulmak için bir hata ayıklayıcı kullanabilirsiniz.\nPython ile beraber gelen IDLE arayüzü çok sadedir; bu özelliklerin küçük bir kısmını sağlar. Spyder daha gelişkindir; bilimsel çalışma için geliştirilen IPython yorumlayıcını kullanabilir. Daha profesyonel ve karmaşık projeler için PyCharm veya Eclipse tercih edilebilir.Alternatif olarak, emacs veya atom editörleri için hazırlanmış bazı eklemelerle, bunları bir IDE haline getirebilirsiniz."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#jupyter-notebook",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#jupyter-notebook",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "Jupyter notebook",
    "text": "Jupyter notebook\n\nJupyter notebook bugün veri bilimcilerin en çok kullandığı araçlardan biri. Bir notebook’un amacı ardışık komutları sırayla kaydetmek, komutların çıktısını kaydetmek ve gerektikçe bunları kolayca tekrar üretmektir. Özellikle etkileşimli çalışma için hazırlanırlar.\nJupyter notebook, bir çekirdek ile beraber çalışır. Bu çekirdek sadece Python olmak zorunda değildir; R, Julia, veya başka bir dille de çalışabilr. Jupyter, verilen komutu çekirdeğe yollar ve çekirdeğin gönderdiği cevabı ekrana yazar. Ayrıca, açıklamalar için kullanılabilecek düzyazı kısımları da tanımlanabilir. Bu kısımlara Markdown veya HTML formatında yazılabilir.LaTeX komutlarıyla matematiksel ifadeler  yazılabilir. Böylece yaptığımız işi ayrıntısıyla adım adım anlattığımız bir laboratuar defteri üretmiş oluruz. Bir Jupyter defteri HTML veya PDF olarak dışa aktarılabilir, veya etkileşimli bir sunum haline getirilebilir."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#numpy",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#numpy",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "Numpy",
    "text": "Numpy\n\nPython dilindeki liste yapısı genel amaçlara uygundur, ama tam da bu yüzden yavaştır. Numpy özel bir dizi tipi (array) tanımlar. Bu dizilerde bütün elemanlar aynı tiptedir (sözgelişi int64 veya float64) ve fiziksel bellekte yanyana yer alırlar. Bu düzen sayesinde dizideki herhangi bir elemana ulaşmak çok daha hızlı olur. Numpy ile istediğiniz boyut ve büyüklükte dizi nesneleri tanımlayabilir, ve bunları hızlı şekilde düzenleyebilirsiniz. Numpy’ın özel matematiksel fonksiyonları, fonksiyonu her elemana ayrı ayrı uygulayacak şekilde hazırlanmışlardır. Söz gelişi, numpy.sqrt(a) çağrısı a’nın her elemanının karekökünü alır. Bu fonksiyonlar hızlı çalışmaları için C ile kodlanmışlardır. Numpy genel amaçlı bir kütüphanedir. Yoğun hesaplama gerektiren birçok paket kendi içinde Numpy dizilerini kullanır."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#matplotlib",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#matplotlib",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "Matplotlib",
    "text": "Matplotlib\n\nPython’un yarıresmi grafik ve görselleştirme paketi. Numpy üzerine kurulu. Yüksek kaliteli grafik üretmek çok kolay. matplotlib.pylab arayüzü ile Matlab benzeri komutlar kullanabilirsiniz. Çoğunlukla, ihtiyaç duyduğunuz işleri çok basit komutlarla üretebilirsiniz. Pylab arayüzünün yetersiz kaldığı durumlarda, çok daha geniş özelleştirme imkanı sunan nesne arayüzünü kullanabilirsiniz."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#seaborn",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#seaborn",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "seaborn",
    "text": "seaborn\n\n\nÖzellikle istatistiksel analizde ihtiyaç duyulan grafikleri üretmek için hazırlanmış, estetik kaygısı yüksek bir görselleme paketi. matplotlib yapısını kullanarak çeşitli grafik tiplerini kendisine göre tekrar tanımlıyor, ve matplotlib’de olmayan yeni grafik tipleri de ekliyor."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#scipy",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#scipy",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "SciPy",
    "text": "SciPy\n\n\nPython’da bilimsel hesaplamanın adresi. NumPy dizileri ile çalışır. Optimizasyon, sayısal integral, diferansiyel denklemler, sinyal işleme, Fourier analizi, lineer cebir gibi sayısal işlemler için hazır fonksiyonlar sağlar."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#pandas",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#pandas",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "pandas",
    "text": "pandas\n\nVeri analizi için en güçlü araçlardan biri. Numpy ve matplotlib üzerine kurulu. Veri tablosu bir DataFrame nesnesi olarak saklanır. Veri sütunlarının tipleri farklı olabilir (sayısal, dize, tarih, kategorik, vs.). Sütunlar ve satırlar üzerinden kolayca filtreleme yapılabilir, tablo biçimi değiştirilebilir, CSV, Excel veya başka formlardan veri alınabilir. Veri analizinin olmazsa olmazı."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#nltk",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#nltk",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "nltk",
    "text": "nltk\nBu kütüphane doğal dil işleme işlemlerinde öncü. Verilen bir metinde ki dil yapısını analiz etmek, kelimeleri ayrıştırmak, kökleri eklerden ayırmak, sınıflandırmak gibi işlerde kullanılan bir paket."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#scikit-learn",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#scikit-learn",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "scikit-learn",
    "text": "scikit-learn\n\nEn yaygın yapay öğrenme algoritmalarını barındıran bir paket. Numpy, SciPy ve matplotlib üzerine kurulu. Sınıflandırma, regresyon, öbekleme, model seçme, boyut indirme gibi işlemler için ilk durak. Yardım belgeleri kodu açıklamanın çok ötesine geçiyor; yapay öğrenme algoritmalarını öğreten bir ders kitabı olarak da okunabilir."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#tensorflow",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#tensorflow",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "TensorFlow",
    "text": "TensorFlow\n\nGoogle kaynaklı bir sayısal hesaplama kütüphanesi. Hesaplamalar, veri akış çizgeleri olarak temsil edilir. Çizge noktaları matematiksel işlemleri, çizgiler ise bunlar arasında akan çok boyutlu veri dizilerini (tensörleri) temsil eder. Bu esnek yapı ile hesaplamalar CPU çekirdeklerine veya GPU’lara dağıtılabilir. İleri seviye yapay öğrenme için birebir."
  },
  {
    "objectID": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#keras",
    "href": "posts/2017/10/30/veri_bilimciler_icin_python_ekosistemi/index.html#keras",
    "title": "Veri Bilimciler İçin Python Ekosistemi",
    "section": "Keras",
    "text": "Keras\n\n\n\n\n\nDerin öğrenme için yüksek seviyeli bir sinir ağları kütüphanesi. Hesap yükünü TensorFlow’a aktarıyor, ama istenirse CNTK veya Theano da kullanabilir.\nBütün bu paketleri ihtiyacınıza göre sisteminize ayrı ayrı kurabilirsiniz. Alternatif olarak, Anaconda veya Enthought Canopy gibi bir Python dağıtımı kullanabilirsiniz. Bu dağıtımlar pek çok paketle beraber geliyorlar, ve bu paketlerin birbiriyle çatışmaması için özen gösteriliyor. Kendilerine özgü güncelleme ve kurma komutları var. Üstelik bütün paketler sizin kişisel dizininize kurulduğu için özel izinlere ihtiyaç duymuyorlar. Ofis bilgisayarınıza sorunsuzca kurabilirsiniz örneğin."
  },
  {
    "objectID": "posts/2017/10/30/groupby/index.html",
    "href": "posts/2017/10/30/groupby/index.html",
    "title": "Groupby",
    "section": "",
    "text": "Pandas paketi veri analizi ve işlemesi için hazırlanmış bir Python paketidir. Bu paket çeşitli formatlardaki dosyaları (Excel, Csv, Txt gibi) okumayı, bu formatlarda dosyalar oluşturmayı kolaylaştırır. Aynı zamanda pandas paketi ile oluşturulan veri çerçeveleri (dataframe) sayesinde farklı formatlardaki (sayı, metin, tarih) veriyi birlikte tutmak, bu verileri işlemek ve basit analizler yapmak mümkündür.\nPandas paketinin altındaki bir yöntem olan groupby() ham haldeki veriden (örnek olarak alışveriş verisi) çeşitli istatistikler çıkarmak için oldukça yararlı bir araç. Bu Veri Defteri’nde UCI Machine Learning Repository’de bulunan online satış verisini kullanacağız. Veriye linke tıklayarak erişebilirsiniz. İlk olarak veriyi okutarak ve boyutlarına bakarak başlayalım.\n\n# İlk adımda pandas ve numpy paketlerini yüklüyoruz\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n# Input dosyasının olduğu klasörün yolu\nIDIR = 'D:/Data/Blog/Data/'\n\n# Pandas'ın altındaki read_excel fonksiyonuyla Excel dosyasını okutabiliriz.\n# Pandas aynı zamanda csv, table, sql ve kopyaladığınız tablo halindeki verileri de okuyabilir (clipboard).\n# read_csv, read_table, read_json, read_sql, read_clipboard fonksiyonlarını inceleyebilirsiniz.\n# Şimdi veriyi okutarak verinin boyutlarını inceleyelim.\ndf = pd.read_excel(IDIR + 'Online Retail.xlsx')\n\nprint(\"Veri çerçevesinin boyutu: \" + str(np.shape(df)))\n\nVeride 8 kolon var. Kolonlar hakkındaki ilk bilgiyi head() fonksiyonuyla görebiliriz.\n\nHTML(df.head().to_html())\n\nVerideki kolonların ne anlama geldiğine bakalım.\n\n\n\nKolon\nAnlam\n\n\n\n\nInvoiceNo\nFatura numarası, her alışverişin bir numarası var\n\n\nStockCode\nÜrünün numarası\n\n\nDescription\nÜrünün açıklaması\n\n\nQuantity\nÜründen kaç adet alındığı\n\n\nInvoiceDate\nAlışverişin tarihi ve saati\n\n\nUnitPrice\nÜrünün birim fiyatı\n\n\nCustomerID\nMüşteri numarası\n\n\nCountry\nÜlke\n\n\n\nÖncelikle ülke bazında alışveriş istatistikleri çıkaralım. Bu amaçla ilk yapacağımız şey veri setini ülke bazında gruplamak.\n\n# Veriyi ülke (Country) bazında grupluyoruz\ndf_country = df.groupby('Country')\n\nVeride hangi ülkeler olduğunu görmek için group.keys(), kaç ülke olduğunu görmek içinse ngroups metotlarını kullanabiliriz.\n\nprint(\"Ülkeler\")\nprint(df_country.groups.keys())\nprint(\"Ülke sayısı: \" + str(df_country.ngroups))\n\nVeri setinde 38 ülkeden yapılan alışverişler var. Her bir gruba (ülkede yapılan alışverişlere) erişmek için aşağıdaki gibi bir loop kullanabiliriz. df_country bir GroupBy objesi ve veriyi ülke ve satış verisini içeren bir dictionarye benzer bir şekilde tutuyor.\n\nfor country, sales in df_country:\n    if country == 'Belgium':\n        HTML(sales.head().to_html())\n\nİstediğimiz gruba ulaşmanın bir diğer yolu da get_group() fonksiyonu. ‘Austria’ için olan satış verilerine ulaşmayı deneyelim.\n\nHTML(df_country.get_group('Austria').head().to_html())\n\nŞimdi her ülke için en çok satılan ürünü bulalım. Bunun için yapmamız gerekenler ülke (Country) ve ürün (StockCode) bazında satış miktarlarını (Quantity) toplamak olacak. Ondan sonra da her ülke için en çok satılan ürünü bulacağız. groupby fonksiyonuna vereceğimiz by argümanı hangi kolonlara göre (Country, StockCode) gruplayacağımız bilgisini veriyor. Daha sonra işlem yapacağımız kolonu (Quantity) ve yapacağımız işlemi (sum()) belirtiyoruz.\n\ndf_country_product = df.groupby(by = ['Country', 'StockCode'])['Quantity'].sum()\nprint(df_country_product.head())\n\nDataframe yapısını korumak için reset_index() fonksiyonunu kullanabiliriz.\n\ndf_country_product = df_country_product.reset_index()\nHTML(df_country_product.head().to_html())\n\nÜlke bazında en yüksek miktara sahip ürünleri bulmak için groupbyı maksimum değeri bulacak şekilde kullanabiliriz. Ancak bu ürün bilgisini vermeyeceği için transform yöntemini kullanıyoruz. Bu sayede her ülke için maksimum satış değerine sahip ürünün satış adedine erişiyoruz. Aşağıdaki satırda değeri maksimum satışa sahip ürünlere sahip indexleri belirliyoruz. Bu, aynı satış miktarına sahip birden fazla ürün varsa onları da bulmamızı sağlar.\n\nidx = df_country_product.groupby(['Country'])['Quantity'].transform(max) == df_country_product['Quantity']\n\nHTML(df_country_product[idx].head(10).to_html())\n\nŞimdi de müşteriler için çeşitli istatistikler çıkaralım. Müşterilerle ilgili pazarlama, segmentasyon, müşteri terki tahmini gib çalışmalarda sıklıkla kullanılan RFM (Recency, frequency, monetary / yakınlık, sıklık, mali) değişkenlerini groupby fonksiyonunu kullanarak oluşturacağız. Bu tip istatistikler aynı zamanda gerçekleştireceğiniz çalışmalarda öznitelik türetmek için de kullanılabilir.\nHer müşteri için aşağıdaki değişkenlerin değerlerini elde etmek istiyoruz: * Alışveriş sayısı * Toplam ve ortalama alışveriş miktarı * Satın alınan toplam ve ortalama (farklı) ürün sayısı * En son alışveriş tarihi\nBunun için öncelike toplam alışveriş miktarını ‘Amount’ kolonuna yazdıracağız. Yapmamız gereken miktar (Quantity) ile birim fiyat (UnitPrice) kolonlarını çarpmak.\nBunları yapmadan önce müşteri (CustomerID) kolonunda boş değerler olduğu için öncelikle bu alışverişleri veri setinden çıkaralım.\n\n# CustomerID değeri olmayan müşterileri veri setinden çıkaralım.\nprint(\"Temizlik öncesi alışveriş sayısı: \" + str(len(df)))\ndf = df[df['CustomerID'] &gt; 0]\nprint(\"Temizlik sonrası alışveriş sayısı: \" + str(len(df)))\n\n# Birim fiyat ve miktar değerlerini çarparak toplam tutarı bulalım.\ndf['Amount'] = df['Quantity'] * df['UnitPrice']\nHTML(df.head().to_html())\n\nAlışverişleri önce müşteri (CustomerID) ve alışveriş (InvoiceNo) değerleri için gruplayalım. Bu sayede her alışveriş için sepetteki ürün sayısı ve sepetteki ürünleri toplam tutarını öğrenebiliriz. Her alışveriş için yapacağımız işlemler aşağıdakilerdir: * Farklı ürün sayısını bulmak (StockCode): Kullanacağımız yöntem nunique kaç tane tekil (unique) değer olduğuna bakar. * Sepetteki ürünlerin değerini toplamak (Amount): Kullanacağımız yöntem sum verilen kolonun değerlerini toplar. * Alışveriş tarihini belirlemek (InvoiceDate): Kullanacağımız değer max maksimum değeri verir. Burada max değerini kullanmamız şart değil. Sadece bu değeri bir sonraki tabloya da aktarmak istiyoruz.\nagg fonksiyonu dictionary yapısıyla bu farklı işlemleri tek satırda yapmamıza imkan tanıyor.\n\ndf_customer = df.groupby(['CustomerID', 'InvoiceNo']).agg({'StockCode':'nunique', \n                                                           'Amount':'sum', \n                                                           'InvoiceDate': 'max'}).reset_index()\n\nHTML(df_customer.head().to_html())\n\nArtık istediğimiz değerleri hesaplayabiliriz. Her müşteri ve alışveriş için oluşturduğumuz tabloyu müşteri bazında tekrar gruplayacağız. Yapmak istediğimiz işlemler aşağıdakilerdir: * İşlem sayısını bulmak: ‘InvoiceNo’ kolonundaki değerleri sayacağız. Değerler tekil olduğu için count fonksiyonunu kullanabiliriz. * Toplam ve ortalam işlem miktarını bulmak: ‘Amount’ kolonu için toplam ve ortalama (mean) değerleri bulacağız. * En son alışveriş tarihini bulmak: Her müşteri için ‘InvoiceDate’ kolonundaki maksimum değeri bulacağız.\nMiktar kolonunda yapacağımız iki işlem (toplam ve ortalama) için de dictionary yapısını ya da bir liste kullanabiliriz.\n\ndf_customer = df_customer.groupby('CustomerID').agg({'InvoiceNo':'count', \n                                                     'Amount': ['sum','mean'],\n                                                    'InvoiceDate': 'max'}).reset_index()\n\ndf_customer.columns = ['CustomerID', 'Number_of_Transactions', 'Total_Amount', 'Average_Amount', 'Last_Transaction_Date']\nHTML(df_customer.head().to_html())\n\ngroupby()fonksiyonunu kullanarak veriyi özetledik. Bu noktadan sonra uygulamanıza göre veriden özetlediğiniz bilgileri kullanabilirsiniz.\nJupyter Notebook dosyalarına ulaşmak için Github dizinine bakabilirsiniz."
  },
  {
    "objectID": "posts/2017/11/23/scikit-learn-ile-veri-analitigine-giris/index.html",
    "href": "posts/2017/11/23/scikit-learn-ile-veri-analitigine-giris/index.html",
    "title": "scikit-learn ile Veri Analitiğine Giriş",
    "section": "",
    "text": "Veri bilimine ilgi duyuyorsunuz ancak nereden başlayacağınız konusunda kafanız karışık mı? Python ekosistemi hakkında bilginiz var. Jupyter Notebook ile aranız fena değil. Sırada elinizi kirletmek var. Bunu yapmanın en kolay yollarından biri scikit-learn kütüphanesini kullanmak.\nscikit-learn yapay öğrenme alanında en yaygın olarak kullanılan kütüphanelerden biri. Doğrusal regresyon, lojistik regresyon, karar ağaçları, rastgele orman gibi birçok temel yöntemi içeren bu kütüphane, Anaconda ile beraber geliyor. Anaconda kullanmayanlar web sitesinden kütüphaneyi nasıl yükleyeceklerini öğrenebilirler.\nscikit-learn paketinin bu kadar popüler olmasının birkaç sebebi var. Bunlardan ilki ihtiyaç duyacağınız temel yöntemlerin büyük bir kısmını içermesi. İkinci olarak, scikit-learn sayesinde veri analitiği uygulamalarını baştan sona yürütmenizin mümkün olmasını sayabiliriz. Verideki eksik değerleri doldurmak, öznitelik seçmek, çapraz doğrulama yapmak, sonuçları değerlendirmek için ayrı ayrı modüller sayesinde başka bir pakete ihtiyacınız kalmıyor. scikit-learn paketinin en güzel yanı basit bir API’a sahip olması sayesinde uygulayacağınız farklı yöntemler için farklı sözdizimleri öğrenmenizin önüne geçmesi. Bu sayede veri analitiğine yeni başlayanlar hızla ellerini kirletebiliyorlar. fit/predict ya da fit/transform fonksiyonları sayesinde kümeleme, regresyon, karar ağaçları gibi yöntemleri uygulamak, eksik değerleri doldurmak, veriyi ölçeklendirmek gibi farklı adımlarda benzer fonksiyonlar kullanmak işinizi oldukça kolaylaştırıyor. API basit olmasının yanında çok iyi bir dokümantasyona sahip.\nlightgbm, tensorflow gibi kütüphaneler performans açısından ileride olsa da scikit-learn başlangıç seviyesindekiler için benim tavsiye edeceğim ilk kütüphane. Veri Defteri’nde scikit-learn paketinin API’ını bir örnek üzerinden anlatıp, temel modüllerden bahsedeceğiz. Bu amaçla yine scikit-learn altındaki veri kümelerini kullanacağız.\nÖrneğimiz digits veri kümesi üzerinden bir sınıflandırma problemi olacak. digits veri kümesi elle yazılmış rakamların 8*8 büyüklüğündeki resimlerinin piksel (8*8 = 64) değerlerinden oluşuyor. Amacımız veri kümesindeki 3 ve 8 rakamlarını birbirinden ayırmak. Kaan digits veri kümesinden bir yazısında bahsetmişti. Kullanacağımız modülleri, veri kümesini yükleyelim ve öğrenme ve sınama için ikiye bölelim.\n#Rakamlar veri kümesini yüklüyoruz.\nfrom sklearn.datasets import load_digits\n#numpy paketini yüklüyoruz.\nimport numpy as np\n#Veri kümesini ikiye bölmek için kullanıyoruz.\nfrom sklearn.model_selection import train_test_split\n#Resimleri incelemek için matplotlib kullanıyoruz.\n%matplotlib inline\nimport matplotlib.pyplot as plt\n\n#Veri kümesini etiket değerleriyle birlikte yükleyelim.\nX,y = load_digits(return_X_y=True)\nprint('Verinin boyutları (Gözlem, öznitelik) = ' + str(np.shape(X)))\nprint('Etiketlerin boyutları (Gözlem) = ' + str(np.shape(y)))\n\nVerinin boyutları (Gözlem, öznitelik) = (1797, 64)\nEtiketlerin boyutları (Gözlem) = (1797,)\nVeri kümesi 64 öznitelik (bunlar piksellerin değerlerine denk geliyor) ve 1797 gözlemden oluşuyor. Veri kümesinin ilk rakamını inceleyerek başlayalım. Rakamı çizdirmek için (1,64) olan boyutu (8,8) şeklinde değiştirmemiz gerekiyor. Bu amaçla da numpy altında reshape fonksiyonunu kullanacağız.\nrakam1 = X[0]\nrakam1 = np.reshape(rakam1, (8,8))\n\nplt.figure(figsize= (2,2))\nplt.imshow(rakam1, cmap=\"gray_r\")\nplt.show()\netiket1 = y[0]\nprint('Etiket: ' + str(etiket1))\n\n\n\n\nEtiket: 0\nGördüğümüz gibi ilk rakam 0. Veri kümesindeki 3 ve 8 rakamlarını ayırmak istiyoruz. Bu amaçla filtreleme kullanacağız. Eğer bir rakam beşe bölündüğünde kalan üç ise istediğimiz koşulları sağlıyor.\n#3 ve 8 rakamlarını seçmek için filtreleme kullanacağız.\n#Filtrelemeyi etiket değerlerine (y) bakarak yapacağız. \n#Etiket değeri beşe bölündüğünde kalan üç ise bu gözlemleri veri kümesinde bırakıyoruz.\nX= X[y%5 == 3]\ny= y[y%5 == 3]\n\n#Son olarak etiketleri 0 ve 1 değerlerine çevirelim.\n#Rakam 3 ise etiket 0, 8 ise 1 olacak.\ny = (y==8)*1\nprint('Verinin boyutları (Gözlem, öznitelik) = ' + str(np.shape(X)))\nprint('Etiketlerin boyutları (Gözlem) = ' + str(np.shape(y)))\n\nVerinin boyutları (Gözlem, öznitelik) = (357, 64)\nEtiketlerin boyutları (Gözlem) = (357,)\nÖğrenen modellerin başarısını sınamak için veri kümesini öğrenme (train) ve sınama (test) olarak ikiye bölelim. Bu da scikit-learn altında yapılabilecek bir işlem. Burada dikkat etmemiz gereken, veri kümesini bölerken etiketlerin yüzdelerini korumak. Bu sayede veri kümesinin sadece bir rakamdan oluşması gibi durumların önüne geçmeyi hedefliyoruz. stratify argümanı ile veri kümesini bölerken etiket değerlerini de hesaba katıyoruz.\n#Stratify değeri veri kümesinin etiket yüzdelerini korumak için kullanılıyor.\n#Öğrenme veri kümesini küçük tutarak sonuçların çok iyi olmasını engelliyoruz.\n#random_state değeri sonuçların her seferinde aynı çıkmasını sağlamak için kullanılıyor.\nX_train, X_test, y_train, y_test = train_test_split(X,y, train_size = 0.5, test_size = 0.5, random_state = 0, stratify = y)\n\nprint('Öğrenme verisinin boyutları (Gözlem, öznitelik) = ' + str(np.shape(X_train)))\nprint('Sınama verisinin boyutları (Gözlem, öznitelik) = ' + str(np.shape(X_test)))\n\nÖğrenme verisinin boyutları (Gözlem, öznitelik) = (178, 64)\nSınama verisinin boyutları (Gözlem, öznitelik) = (179, 64)\nVeri kümesini ikiye böldük. Şimdi sınıflandırma için karar ağacı ve rastgele orman yöntemlerini kullanıp karşılaştıracağız. scikit-learn API’ının üç adımlık basit bir kullanımı var. Şimdi bu adımları inceleyelim."
  },
  {
    "objectID": "posts/2017/11/23/scikit-learn-ile-veri-analitigine-giris/index.html#kullanacağımız-sınıfa-ait-bir-örnek-oluşturma",
    "href": "posts/2017/11/23/scikit-learn-ile-veri-analitigine-giris/index.html#kullanacağımız-sınıfa-ait-bir-örnek-oluşturma",
    "title": "scikit-learn ile Veri Analitiğine Giriş",
    "section": "Kullanacağımız sınıfa ait bir örnek oluşturma",
    "text": "Kullanacağımız sınıfa ait bir örnek oluşturma\nÖrnek olarak bir karar ağacı oluşturmak ya da eksik değerleri ortalama değerle doldurmak istiyorsunuz. Bu amaçla gerekli sınıflara (class) ait örnekleri istediğiniz parametrelerle oluşturmanız gerekiyor..\ndt adında bir karar ağacı oluşturmak için DecisionTreeClassifier sınıfını kullanıyoruz:\ndt = DecisionTreeClassifier()\nEksik değerleri ortalama değerle değiştirmek için ise Imputer sınıfını kullanacağız. NaN şeklinde olan eksik değerleri ortalama (mean) değerle değiştirmek istersek bunu kullanacağımız argümanlarla belirtmemiz gerekiyor.\nmean_imputer = Imputer(missing_values = 'NaN', strategy = 'mean')\nAşağıda dt adında bir karar ağacı ve rf adında bir rastgele orman örneği tanımlıyoruz.\n\n#Karar ağaçları\nfrom sklearn.tree import DecisionTreeClassifier\n#Rastgele orman\nfrom sklearn.ensemble import RandomForestClassifier\n\n#Karar ağacı modelini oluşturalım. \n#random_state değeri sayesinde sonuçların rassal olarak değişmemesini sağlıyoruz.\ndt = DecisionTreeClassifier(random_state = 0)\n\n#Rastgele orman modelini oluşturalım.\nrf = RandomForestClassifier(random_state = 0)"
  },
  {
    "objectID": "posts/2017/11/23/scikit-learn-ile-veri-analitigine-giris/index.html#oluşturduğumuz-örneğin-öğrenmesini-sağlama-fit",
    "href": "posts/2017/11/23/scikit-learn-ile-veri-analitigine-giris/index.html#oluşturduğumuz-örneğin-öğrenmesini-sağlama-fit",
    "title": "scikit-learn ile Veri Analitiğine Giriş",
    "section": "Oluşturduğumuz örneğin öğrenmesini sağlama (fit)",
    "text": "Oluşturduğumuz örneğin öğrenmesini sağlama (fit)\nBir önceki aşamada oluşturduğumuz örneğin veri üzerinde öğrenmesi fit fonksiyonuyla yapılıyor. Örneğin bir karar ağacını öznitelik ve etiketleri kullanarak eğitmek için fit fonksiyonunu aşağıdaki gibi kullanabiliriz:\ndt.fit(X_train, y_train)\nBu sayede öğrenme verisi üzerinden bir karar ağacı modeli oluşturulur.\nEksik değerleri doldurmak için de fit fonksiyonunu kullanacağız. Ancak burada fit fonksiyonu sadece yapacağımız işlemi tanımlıyor. Aşağıdaki satırda X_train matrisindeki eksik değer içeren sütunlar için ortalama değer hesaplanıyor.\nmean_imputer.fit(X_train)\nŞimdi yukarıda oluşturduğumuz karar ağacı ve rastgele orman modellerini eğitelim.\n\n#Modellerin öğrenmesini sağlayalım.\ndt.fit(X_train,y_train)\nrf.fit(X_train,y_train)\n\nRandomForestClassifier(bootstrap=True, class_weight=None, criterion='gini',\n            max_depth=None, max_features='auto', max_leaf_nodes=None,\n            min_impurity_decrease=0.0, min_impurity_split=None,\n            min_samples_leaf=1, min_samples_split=2,\n            min_weight_fraction_leaf=0.0, n_estimators=10, n_jobs=1,\n            oob_score=False, random_state=0, verbose=0, warm_start=False)"
  },
  {
    "objectID": "posts/2017/11/23/scikit-learn-ile-veri-analitigine-giris/index.html#sonuçları-elde-etmek-predictpredict_proba-ve-transform",
    "href": "posts/2017/11/23/scikit-learn-ile-veri-analitigine-giris/index.html#sonuçları-elde-etmek-predictpredict_proba-ve-transform",
    "title": "scikit-learn ile Veri Analitiğine Giriş",
    "section": "Sonuçları elde etmek (predict/predict_proba ve transform)",
    "text": "Sonuçları elde etmek (predict/predict_proba ve transform)\nOluşturduğunuz modelleri eğittikten sonra sonuçları elde etmek için kullanabileceğiniz iki farklı fonksiyon tipi var.\n\npredict: Regresyon, sınıflandırma, kümeleme gibi yöntemler kullanarak yapacağınız çalışmalarda tahmin edilen etiket bilgisini predict fonksiyonuyla elde edebilirsiniz. Sınıflandırma problemlerinde gözlemlerin sınıflara ait olma olasılıklarını elde etmek istiyorsanız predict_proba fonksiyonunu kullanmanız gerekiyor.\n\nYukarıda oluşturduğumuz karar ağacı için etiketleri elde etmek için aşağıdaki satıra ihtiyacımız var:\ny_pred = dt.predict(X_test)\nEğer etiketleri değil de olasılıkları öğrenmek istiyorsak predict_proba fonksiyonunu kullanmamız gerekiyor. Sonuçlar her etikete ait olma yüzdesini içeriyor.\ny_pred_proba = dt.predict_proba(X_test)\n\ntransform: Veriyle ilgili yapacağımız dönüştürme işlemlerinde ise transform fonksiyonunu kullanacağız. Dönüştürme işlemleri eksik veriyi doldurma, veriyi ölçeklendirme gibi alanlarda karşımıza çıkıyor. Aynı zamanda bir matrisi çarpanlarına ayırmak gibi işlemler için de transform fonksiyonu kullanılıyor.\n\nEksik değerleri doldurmak için aşağıdaki satırı kullanabiliriz:\nX_test = mean_imputer.transform(X_test)\nŞimdi kullandığımız iki modeli sınama veri kümesinde kullanarak etiketleri ve gözlemlerin etiketlere ait olma olasılıklarını hesaplayalım.\n\n#Sınama verisinin etiketlerini elde edelim.\ny_pred_dt = dt.predict(X_test)\n#Sınama veri kümesinin sınıflara ait olma olasılıklarını alalım.\ny_pred_proba_dt = dt.predict_proba(X_test)\n\n#Aynı adımları rastgele orman yöntemi için tekrarlayalım.\ny_pred_rf = rf.predict(X_test)\ny_pred_proba_rf = rf.predict_proba(X_test)\n\nBurada dikkat etmemiz gereken bir nokta fit işlemlerini öğrenme, predict ve transform işlemlerini ise sınama verisi üzerinden yapmak. Yapacağımız çalışmalardaki amacımız öğrenme veri kümesiyle yakaladığımız örüntüleri sınama verisi üzerinde denemek. Yani, sınama veri kümesinin sadece son aşamada kullanılması gerekiyor. Eksik değerleri doldurmak gibi konularda da öğrenme verisiyle elde ettiğimiz bilgileri (örnek olarak ortalamayı) sınama verisinde kullanıyoruz. Sınama veri kümesi için de fit fonksiyonunu kullanmak sıklıkla yapılan bir hata.\nAşağıdaki satırlarda öğrenme verisindeki sütunlar için ortalama değeri bulup eksik değerleri dolduruyoruz. Daha sonra da sınama verisindeki sütunlar için ortalama değerleri bulup eksik değerleri doldurmak için kullanıyoruz. Oysa ki yapmamız gereken sınama verisinde de öğrenme verisindeki ortalamaları kullanmak.\nmean_imputer.fit(X_train) X_train = mean_imputer.transform(X_train) mean_imputer.fit(X_test) X_test = mean_imputer.transform(X_test)"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "",
    "text": "Jupyter Jupyter olmadan önce (yani birçok farklı dil çekirdeğiyle uyumlu bir arayüz haline gelmeden önce) IPython Notebook olarak biliniyordu. IPython bir Python yorumlayıcısı, ama özellikle etkileşimli sayısal hesaplamalar gözetilerek hazırlanmış bir yorumlayıcı. Başta sadece terminalde çalışıyordu, daha sonra Web teknolojileriyle birleştirilerek tarayıcı içinde kullanılabilen bir defter yapısına kavuştu.\nGeçmiş bir yazıda bahsettiğimiz Jupyter arayüzünün özellikleri doğrudan doğruya IPython’dan alınmış, ve yorumlanabilir herhangi bir dille çalışabilecek şekilde genelleştirilmiştir. Jupyter’in devraldığı IPython özelliklerinden biri de sihirli ifadeler denen bazı kolaylaştırıcı, özelleşmiş komutlardır. Bu komutlar !, % veya %% ile başlarlar. Sihirli ifadeler Python yorumlayıcısına aktarılmadan IPython tarafından işlenir.\nSihirli ifadeler IPython çekirdeğine özgü oldukları için sadece Python ile çalışırlar. Jupyter’in desteklediği diğer diller (R, Julia, vd.) şimdilik bu özelliğe sahip değiller.\nSihirli ifadelerle ilgili tam referans için resmi belgelere bakabilirsiniz. Bu yazıda bazı en yaygın kullanılan komutlara göz atacağız."
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#sistem-komutu-çalıştırmak",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#sistem-komutu-çalıştırmak",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "Sistem komutu çalıştırmak",
    "text": "Sistem komutu çalıştırmak\nİşletim sisteminin komut yorumlayıcısına doğrudan erişmek için ! sihrini kullanırız. Bu komutların cevabı ekrana yazılır. (Dikkat: Aşağıdaki örnekler bir Linux sisteminde çalışır. Windows veya MacOS’da çalışıyorsanız, sisteminizdeki kabuğa uygun komutlar denemelisiniz.)\nTarih ve saat:\n\n!date\n\nCum 17 Kas 2023 15:23:08 +03\n\n\nls ile \\bin dizininde z ile başlayan dosyaları görelim.\n\n!ls /bin/z*\n\n/bin/zcat    /bin/zfgrep      /bin/zipgrep    /bin/zmore     /bin/zstdless\n/bin/zcmp    /bin/zforce      /bin/zipinfo    /bin/znew      /bin/zstdmt\n/bin/zdiff   /bin/zgrep       /bin/zipnote    /bin/zoom\n/bin/zdump   /bin/zip         /bin/zipsplit   /bin/zstd\n/bin/zegrep  /bin/zipcloak    /bin/zjsdecode  /bin/zstdcat\n/bin/zenity  /bin/zipdetails  /bin/zless      /bin/zstdgrep\n\n\nBu komutların çıktılarını, daha sonra kullanmak için bir değişkene atayabiliriz. Bu şekilde, komut satırında kolayca yapılabilecek bir iş için kod yazmak zorunda kalmayız.\n\nbindosyalar = !ls /bin/z*\nbindosyalar\n\n['/bin/zcat',\n '/bin/zcmp',\n '/bin/zdiff',\n '/bin/zdump',\n '/bin/zegrep',\n '/bin/zenity',\n '/bin/zfgrep',\n '/bin/zforce',\n '/bin/zgrep',\n '/bin/zip',\n '/bin/zipcloak',\n '/bin/zipdetails',\n '/bin/zipgrep',\n '/bin/zipinfo',\n '/bin/zipnote',\n '/bin/zipsplit',\n '/bin/zjsdecode',\n '/bin/zless',\n '/bin/zmore',\n '/bin/znew',\n '/bin/zoom',\n '/bin/zstd',\n '/bin/zstdcat',\n '/bin/zstdgrep',\n '/bin/zstdless',\n '/bin/zstdmt']"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#yardım-almak",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#yardım-almak",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "Yardım almak",
    "text": "Yardım almak\nJupyter’in çevrimiçi yardımını hücre sihirleriyle de kullanabilirsiniz. Sihirli kelimeyi yazıp Shift-Tab bastığınızda bir yardım balonu çıkar.\n\nSihirli ifadelerin kullanımının özeti ve her bir komutun kısa açıklaması için %quickref komutunu, tam ve kapsamlı bir referans için %magic komutunu kullanabilirsiniz.\nSatır sihirleri bir tek % işaretiyle başlar, ve tek satırda bulunurlar. Hücrenin geri kalanında Python kodu bulunabilir. Hücre sihirleri ise çift %% işaretiyle başlarlar. Hücrenin tamamı bu sihrin etkisinde kalır."
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#time-timeit-süre-ölçme",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#time-timeit-süre-ölçme",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%time, %timeit: Süre ölçme",
    "text": "%time, %timeit: Süre ölçme\nBir komutun işletilmesinin ne kadar zaman aldığını ölçmek için %time ve %timeit sihirlerini kullanabiliriz. Bunlar standart kütüphanedeki time ve timeit modüllerini kullanır.\n\n%time sum(range(1000))\n\nCPU times: user 27 µs, sys: 4 µs, total: 31 µs\nWall time: 35.5 µs\n\n\n499500\n\n\nAncak, bilgisayar sistemi bazı anlarda başka işlerle meşgul olabildiği için bir tek süre ölçümü yanıltıcı olabilir. %timeit, komutu bir döngü içinde birçok defa çalıştırır, bunların ortalama süresini bulur. Bunu birkaç defa tekrarlar ve elde ettiği sonuçların ortalama ve standart sapma olarak verir.\n\n%timeit sum(range(1000))\n\n15.6 µs ± 482 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n\n\nDöngü sayısı açıkça verilmediyse, otomatik olarak ayarlanır. Döngü sayısı, toplam çalışma süresi 0.2 saniyenin üstünde olacak şekilde 10’un kuvvetleri olarak belirlenir. Döngü sayısı ve tekrar sayısı istendiği gibi değiştirilebilir.\n\n%timeit -n 250 -r 4 sum(range(1000))\n\n20.2 µs ± 795 ns per loop (mean ± std. dev. of 4 runs, 250 loops each)\n\n\nSüresini tutmak istediğimiz işlem birkaç satıra yayılmış olabilir. O zaman bütün hücrenin işleyiş süresini ölçmek için, çift yüzde işaretiyle, %%timeit hücre sihiri kullanırız.\nÖrnek olarak, bir listeyi append ile genişletmek ve liste kurma arasındaki zaman farkına bakalım.\n\n%%timeit -r 10\nL = []\nfor i in range(1000):\n    L.append(i**2)\n\n239 µs ± 2.34 µs per loop (mean ± std. dev. of 10 runs, 1,000 loops each)\n\n\n\n%timeit -r 10 [i**2 for i in range(1000)]\n\n210 µs ± 1.53 µs per loop (mean ± std. dev. of 10 runs, 1,000 loops each)"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#dizin-işlemleri",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#dizin-işlemleri",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "Dizin işlemleri",
    "text": "Dizin işlemleri\nYeni bir dizin yaratalım ve o dizine geçelim.\n\n!mkdir deneme\n%cd deneme\n\n/home/kaan/veridefteri.com/posts/IPython_sihirli_ifadeler/deneme\n\n\nYeni dizinde bir dosya yaratalım.\n\n!touch dosya1\n!ls\n\ndosya1\n\n\nÜst dizine dönelim.\n\n%cd ..\n\n/home/kaan/veridefteri.com/posts/IPython_sihirli_ifadeler\n\n\nYarattığımız dizini silelim.\n\n!rm -r deneme/\n\nNeden bütün işlemleri ! operatörüyle yaparken, dizin değiştirmeyi %cd ile yaptık? Eğer komutu !cd deneme olarak verseydik, kabuk yorumlayıcı bunu işletir ve hemen sonra kapanırdı. Sonraki komutlar yeni bir kabuk yorumlayıcıyla yapılacağı için dizin değiştirme işlemi kalıcı olmazdı. IPython’un %cd komutu dizinlerin çalıştığımız ortamda kalıcı olarak değiştirilmesini sağlar.\nÖrnek olarak, aşağıdaki komutlar sonucunda, /deneme dizinine geçmiş olmuyoruz.\n\n!mkdir deneme\n!cd deneme\n!pwd\n\n/home/kaan/veridefteri.com/posts/IPython_sihirli_ifadeler\n\n\nDoğrusunu yaparak %cd kullanırsak istediğimiz değişiklik geçerli olur.\n\n%cd deneme\n!pwd\n\n/home/kaan/veridefteri.com/posts/IPython_sihirli_ifadeler/deneme\n/home/kaan/veridefteri.com/posts/IPython_sihirli_ifadeler/deneme\n\n\nÜst dizine geri çıkıp /deneme dizinini silelim.\n\n%cd ..\n!rm -r deneme/\n\n/home/kaan/veridefteri.com/posts/IPython_sihirli_ifadeler"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#writefile-bir-metin-dosyası-yaratmak",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#writefile-bir-metin-dosyası-yaratmak",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%%writefile: Bir metin dosyası yaratmak",
    "text": "%%writefile: Bir metin dosyası yaratmak\nDiyelim elle yazacağınız kısa bir metni bir dosyaya kaydetmek istiyorsunuz. Bunun için ayrı bir pencerede bir editör açabilirsiniz, veya Python’un dosya açma komutlarını kullanabilirsiniz. %%writefile hücre sihri ise zahmetsiz kestirme bir yol sağlar.\ndeneme isimli bir dosyaya iki telefon numarası yazalım:\n\n%%writefile deneme\nKaan (111)-1234567\nMeral (124)-9283759\n\nWriting deneme\n\n\n%cat ile dosyanın içeriğini ekrana dökerek istediğimizi yaptığını teyit edebiliriz.\n\n%cat deneme\n\nKaan (111)-1234567\nMeral (124)-9283759\n\n\n%%writefile -a ile mevcut dosyanın altına ekleme yaparız.\n\n%%writefile -a deneme\nZiya (234)-8087955\n\nAppending to deneme\n\n\n\n%cat deneme\n\nKaan (111)-1234567\nMeral (124)-9283759\nZiya (234)-8087955\n\n\n\n%rm deneme"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#run-python-programı-çalıştırmak",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#run-python-programı-çalıştırmak",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%run: Python programı çalıştırmak",
    "text": "%run: Python programı çalıştırmak\nAyrı bir dosyada bulunan Python kodunu çalıştırmak için %run komutu kullanılır.\nBasit bir Python programı hazırlayıp merhaba.py ismiyle kaydedelim.\n\n%%writefile merhaba.py\nisim = \"Kaan Öztürk\"\nprint(\"Merhaba\",isim)\n\nWriting merhaba.py\n\n\nŞimdi bu programı çalıştıralım\n\n%run merhaba.py\n\nMerhaba Kaan Öztürk\n\n\nÇağırılan program mevcut yorumlayıcı tarafından işlendiği için, o program içinde yaratılan değişken isimlerine erişilebilir.\n\nisim\n\n'Kaan Öztürk'"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#bir-dosyanın-içeriğini-yüklemek",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#bir-dosyanın-içeriğini-yüklemek",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "Bir dosyanın içeriğini yüklemek",
    "text": "Bir dosyanın içeriğini yüklemek\n%load komutu, %run gibi, bir Python dosyasındaki komutları okuyup çalıştırmaya yarar. Farkı, kodu önce mevcut hücreye kopyalaması, ama biz tekrar talep etmedikçe çalıştırmamasıdır.\n\n%load merhaba.py\n\nYukarıdaki hücre çalıştırıldığında sihirli kelime yorum haline getirilir, dosyadaki kod aynı hücreye kopyalanır, ama çalıştırılmaz.\n```{python}\n# %load merhaba.py\nisim = input(\"Adınız?\")\nprint(\"Merhaba\",isim)\n```\nHücrede tekrar Shift-Enter’e basıldığında kod çalışır.\n\n# %load merhaba.py\nisim = \"Kaan Öztürk\"\nprint(\"Merhaba\",isim)\n\nMerhaba Kaan Öztürk"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#qtconsole-yan-terminal-açmak",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#qtconsole-yan-terminal-açmak",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%qtconsole: Yan terminal açmak",
    "text": "%qtconsole: Yan terminal açmak\nDefterinizin akışına müdahale etmeden bazı yan işlemler yapmak istediğinizde, ayrı bir pencerede bir IPython penceresi açabilirsiniz. (Bu komut her işletim sisteminde bulunmayabilir.)\n%qtconsole\nHer iki arayüz de aynı çekirdeğe bağlıdır. Birbirlerinin tanımlarını görebilirler. Konsol penceresini kapatmak, onu başlatan defteri etkilemez."
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#pastebin-kod-parçası-paylaşmak",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#pastebin-kod-parçası-paylaşmak",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%pastebin: Kod parçası paylaşmak",
    "text": "%pastebin: Kod parçası paylaşmak\n%pastebin sihri, bir dosyayı, veya mevcut oturumdan seçtiğiniz satırları dpaste.com sitesinde herkese açık olarak yayınlar ve URL’sini döndürür.\nBu defterdeki In[1]-In[11] arası komutları Gist’e yüklemek için:\n\n%pastebin -d \"Deneme yüklemesi\" 1-11\n\n'https://dpaste.com/D73XU7CMS'\n\n\nmerhaba.py dosyasını Gist’e yüklemek için:\n\n%pastebin -d \"Deneme yüklemesi\" merhaba.py\n\n'https://dpaste.com/GDS5QF5WM'"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#who-oturumda-tanımlanmış-değişkenler",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#who-oturumda-tanımlanmış-değişkenler",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%who: Oturumda tanımlanmış değişkenler",
    "text": "%who: Oturumda tanımlanmış değişkenler\nMevcut oturumda tanımlanmış değişken isimlerini gösterir.\n\n%who\n\nisim     \n\n\nDeğişken isimlerini bir liste olarak almak isterseniz %who_ls kullanabilirsiniz.\n\n%who_ls\n\n['isim']"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#reset-değişkenleri-topluca-silmek",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#reset-değişkenleri-topluca-silmek",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%reset: Değişkenleri topluca silmek",
    "text": "%reset: Değişkenleri topluca silmek\nMevcut oturumda kullanıcı tarafından tanımlanmış değişkenleri siler. Modüllerde tanımlanmış isimlere dokunmaz.\n\nx = 1\ns = \"asdfg\"\n\n\n%who\n\nisim     s   x   \n\n\n\n%reset\n\nNothing done.\n\n\n\n%who\n\nisim     \n\n\nParametreler: * %reset -f    : Teyit istemeden sıfırlar. * %reset -s    : Yumuşak sıfırlama: Komut geçmişi silinmez, sadece isim alanı temizlenir. * %reset in    : Komut geçmişini sıfırlar. * %reset out   : Çıktı geçmişini sıfırlar. * %reset dhist : Dizin geçmişini sıfırlar. * %reset array : Sadece NumPy dizi (array) değişkenlerini siler."
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#macro-işlemleri-otomatik-olarak-tekrar-etmek",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#macro-işlemleri-otomatik-olarak-tekrar-etmek",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%macro: İşlemleri otomatik olarak tekrar etmek",
    "text": "%macro: İşlemleri otomatik olarak tekrar etmek\nArka arkaya yazdığınız birkaç komutu daha sonra tekrar tekrar işletmek için bir kenara yazmak istediğinizde %macro sihri işinize yarayacaktır. Bu işlem,de daha önce verdiğimiz komutları giriş sayılarını vererek bir seferde çalıştırabiliriz.\n\nfrom random import randint\n\n\nzar1 = randint(1,6)\n\n\nzar2 = randint(1,6)\n\n\nzar3 = randint(1,6)\n\n\na = 5\n\n\nprint(zar1 + zar2)\n\n8\n\n\n\nprint(zar1, zar2, zar3, zar1+zar2+zar3)\n\n5 3 3 11\n\n\nBu komutları kullanarak bir makro hazırlayalım. Girdi numaralarını hücrelerin yanından okuyabileceğimiz gibi, %hist -n sihiriyle de görebiliriz.\n\n%hist -n\n\n… 40: from random import randint 41: zar1 = randint(1,6) 42: zar2 = randint(1,6) 43: zar3 = randint(1,6) 44: a = 5 45: print(zar1 + zar2) 46: print(zar1, zar2, zar3, zar1+zar2+zar3) 47: %hist -n\n%macro sihirli kelimesinden sonra, makroya vereceğiniz isim ve komut numarası aralıkları gelmelidir. Aralıklar n1-n2 n3-n4 n5 şeklinde verilebilir. Aralıkların başı ve sonu dahil edilir. Araya virgül koyulmaz.\n\n%macro zar_at 40-43 46\n\nMacro `zar_at` created. To execute, type its name (without quotes).\n=== Macro contents: ===\nfrom random import randint\nzar1 = randint(1,6)\nzar2 = randint(1,6)\nzar3 = randint(1,6)\nprint(zar1, zar2, zar3, zar1+zar2+zar3)\n \n\n\n\nzar_at\n\n4 6 4 14"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#save-komutları-kaydet",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#save-komutları-kaydet",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%save: Komutları kaydet",
    "text": "%save: Komutları kaydet\nHazırladığınız bir makroyu veya girdi satırlarının bir kısmını sonraki bir oturumda kullanmak için sabit diske yazmak isterseniz %save sihrini kullanabilirsiniz. Parametre olarak satır numaraları aralıkları veya numara listesi verilebilir.\n\n%save deneme 40-43 46\n\nThe following commands were written to file `deneme.py`:\nfrom random import randint\nzar1 = randint(1,6)\nzar2 = randint(1,6)\nzar3 = randint(1,6)\nprint(zar1, zar2, zar3, zar1+zar2+zar3)\n\n\nSatır numaraları yerine daha önce hazırladığınız bir makronun ismini de verebilirsiniz.\n\n%save deneme zar_at\n\nThe following commands were written to file `deneme.py`:\nfrom random import randint\nzar1 = randint(1,6)\nzar2 = randint(1,6)\nzar3 = randint(1,6)\nprint(zar1, zar2, zar3, zar1+zar2+zar3)"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#store-değişkenleri-sabit-diske-kaydet",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#store-değişkenleri-sabit-diske-kaydet",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%store: Değişkenleri sabit diske kaydet",
    "text": "%store: Değişkenleri sabit diske kaydet\nHesabınız sırasında ürettiğiniz bazı değişkenleri sonraki oturumlarda kullanmak için kaydetmek istediğinizde bu sihri kullanabilirsiniz.\n\nL = [i*2 for i in range(10)]\n\n\n%store L\n\nStored 'L' (list)\n\n\nDeğişkenleri silelim:\n\n%reset -f\n\nArtık L listesini kaybettik.\n\nprint(L)\n\nNameError: name 'L' is not defined\n\n\nL değişkenini kaydedilen yerden geri yükleyelim.\n\n%store -r L\n\n\nprint(L)\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\n\n%store L &gt;kareler.txt\n\nWriting 'L' (list) to file 'kareler.txt'.\n\n\n\n%cat kareler.txt\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n\n\n!rm kareler.txt"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#matplotlib-arayüzünü-ayarlamak",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#matplotlib-arayüzünü-ayarlamak",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "matplotlib arayüzünü ayarlamak",
    "text": "matplotlib arayüzünü ayarlamak\nmatplotlib Python’un gayrıresmi görselleştirme kütüphanesidir. Özel %matplotlib sihriyle, hangi arka yüzü kullanmak istediğinizi belirleyebilirsiniz.\n\n%matplotlib -l\n\nAvailable matplotlib backends: ['tk', 'gtk', 'gtk3', 'gtk4', 'wx', 'qt4', 'qt5', 'qt6', 'qt', 'osx', 'nbagg', 'webagg', 'notebook', 'agg', 'svg', 'pdf', 'ps', 'inline', 'ipympl', 'widget']\n\n\nBu arka yüzlerin hepsi her işletim sisteminde bulunmayabilir.\nBirçok Jupyter defter kullanıcısı, defterin başında %matplotlib inline komutunu vermeyi tercih eder. Bu sayede ürettiğiniz matplotlib grafikleri defterin içine gömülür ve tam bir belge oluşturmanızı sağlar.\n\n%matplotlib inline\n\n\nimport matplotlib.pylab as plt\nx = plt.linspace(-20,20,100)\ny = plt.sin(x)/x\nplt.plot(x,y)\n\nBunun yerine notebook arka yüzü kullanmayı tercih ederseniz, fareyle etkileşebileceğiniz, kaydırıp zumlayabileceğiniz dinamik bir formda gösterilir.\nDikkat: matplotlib arka yüzünü bir oturum içinde sadece bir kere belirleyebilirsiniz. Aşağıdaki komutlar için çekirdeği tekrar başlatmanız gerekecektir. Çekirdeği, menü çubuğunda Kernel -&gt; Kernel Restart seçerek, veya iki kere sıfıra basarak tekrar başlatabilirsiniz.\n\n%matplotlib notebook\n\n\nimport matplotlib.pylab as plt\nx = plt.linspace(-20,20,100)\ny = plt.sin(x)/x\nplt.plot(x,y)\n\nDeftere gömülü olarak bir etkileşimli grafik arayüzü elde ederiz.\n\nGrafiğin ayrı bir pencerede gösterilmesini istiyorsanız gtk, qt, agg, ve türevlerini kullanabilirsiniz. O zaman en sonda matplotlib’in show() komutunu vermelisiniz.\n\n%matplotlib qt5\n\n\nimport matplotlib.pylab as plt\nx = plt.linspace(-20,20,100)\ny = plt.sin(x)/x\nplt.plot(x,y)\nplt.show()\n\nBu komutlardan sonra grafik şöyle bir pencerede gösterilir."
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#script-herhangi-bir-yorumlayıcıyı-çalıştır",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#script-herhangi-bir-yorumlayıcıyı-çalıştır",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%%script: Herhangi bir yorumlayıcıyı çalıştır",
    "text": "%%script: Herhangi bir yorumlayıcıyı çalıştır\nBaşka dillere ait yorumlayıcıları kullanmaya ne dersiniz? Belki bir sürü veri dosyasını hızlıca işlemek için birkaç kabuk komutu vereceksiniz. Belki Awk, Perl, ya da Ruby ile hızlı bir işlem yapmak istiyorsunuz. Sisteminize kurulu herhangi bir yorumlayıcıyı çalıştırıp ona komutlar vermek için %%script hücre sihrini kullanabilirsiniz.\nHücrenin başına %%script’in ardından yorumlayıcı programın adını, ve gerekiyorsa bazı parametreleri yazın. Hücredeki alt satırlar yorumlayıcıya gönderilip işlenecek, gelen cevap ekrana basılacak.\n\n%%script bash\nfor i in 1 2 3; do\necho $i\ndone\n\n1\n2\n3"
  },
  {
    "objectID": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#html-html-yorumlayıcı",
    "href": "posts/2017/11/28/ipython-sihirli-ifadeler/Jupyter sihirli komutlar.html#html-html-yorumlayıcı",
    "title": "Jupyter / IPython sihirli ifadeler",
    "section": "%%html: HTML yorumlayıcı",
    "text": "%%html: HTML yorumlayıcı\nBulunduğu hücredeki HTML kodunu işler ve HTML belgesini ekrana verir.\n\n%%html\n&lt;html&gt;\n&lt;head&gt;\n&lt;style&gt;\ntable {\n    font-family: arial, sans-serif;\n    border-collapse: collapse;\n    widtd: 100%;\n}\n\nth, td {\n    border: 1px solid #dddddd;\n    text-align: left;\n    padding: 8px;\n}\n\ntr:nth-child(even) {\n    background-color: #dddddd;\n}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt; Çevrimiçi alışveriş veri kayıtları &lt;/h1&gt;\n&lt;table class=\"table table-bordered table-hover table-condensed\"&gt;\n&lt;thead&gt;&lt;tr&gt;&lt;th title=\"Field #1\"&gt;InvoiceNo&lt;/th&gt;\n&lt;th title=\"Field #2\"&gt;StockCode&lt;/th&gt;\n&lt;th title=\"Field #3\"&gt;Description&lt;/th&gt;\n&lt;th title=\"Field #4\"&gt;Quantity&lt;/th&gt;\n&lt;th title=\"Field #6\"&gt;UnitPrice&lt;/th&gt;\n&lt;/tr&gt;&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n&lt;td align=\"right\"&gt;536365&lt;/td&gt;\n&lt;td&gt;85123A&lt;/td&gt;\n&lt;td&gt;WHITE HANGING HEART T-LIGHT HOLDER&lt;/td&gt;\n&lt;td align=\"right\"&gt;6&lt;/td&gt;\n&lt;td align=\"right\"&gt;2.55&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td align=\"right\"&gt;536365&lt;/td&gt;\n&lt;td&gt;71053&lt;/td&gt;\n&lt;td&gt;WHITE METAL LANTERN&lt;/td&gt;\n&lt;td align=\"right\"&gt;6&lt;/td&gt;\n&lt;td align=\"right\"&gt;3.39&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td align=\"right\"&gt;536365&lt;/td&gt;\n&lt;td&gt;84406B&lt;/td&gt;\n&lt;td&gt;CREAM CUPID HEARTS COAT HANGER&lt;/td&gt;\n&lt;td align=\"right\"&gt;8&lt;/td&gt;\n&lt;td align=\"right\"&gt;2.75&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n Çevrimiçi alışveriş veri kayıtları \n\n\n\n\nInvoiceNo\nStockCode\nDescription\nQuantity\nUnitPrice\n\n\n\n\n536365\n85123A\nWHITE HANGING HEART T-LIGHT HOLDER\n6\n2.55\n\n\n536365\n71053\nWHITE METAL LANTERN\n6\n3.39\n\n\n536365\n84406B\nCREAM CUPID HEARTS COAT HANGER\n8\n2.75"
  },
  {
    "objectID": "posts/2017/11/20/turkce-metin-islemede-ilk-adimlar/index.html",
    "href": "posts/2017/11/20/turkce-metin-islemede-ilk-adimlar/index.html",
    "title": "Türkçe Metin İşlemede İlk Adımlar",
    "section": "",
    "text": "Veri bilimine merak salan hemen hemen herkes bir noktada metin işlemeye bulaşır. Kitapların incelenmesinden tutun da, sosyal medyada yazılanları derlemeye kadar pek çok çalışma özünde cümleler ve kelimelerle boğuşmayı gerektirir. Pek eğlencelidir; ben de bayılırım. Hatta birkaç ay önce bir paragrafın hangi yazara ait olduğunu bulmakla ilgili bir yazı hazırladım.\nBu yazıda İnsan Hakları Evrensel Beyannamesi’ni örnek metin olarak ele alacağım. Bir yandan basit metin işleme adımlarını yaparken, bir yandan da iki noktayı size göstermek istiyorum:\n\nİnternet’teki açık kaynak kodlu bir Python paketinin yüklenmeden kullanılması.\nYeni bir paketin pip komutu ile kurulması.\n\nÖnce dosyayı okuyup bir değişkene atalım. Bu değişkenin tipi, karakter dizisi (string) sınıfından (class str) olacak.\n\nwith open('./iheb.txt', 'r') as dosya:\n    metin = dosya.read()\n\nprint('\"metin\" değişkeninin tipi:', type(metin), '\\n')\n\nprint('Beyannamenin boşluklar dahil uzunluğu:', len(metin), 'karakter.\\n\\n')\n\n# Bakalım metin neye benziyor?\nprint(metin[0:760])\n\n\"metin\" değişkeninin tipi: &lt;class 'str'&gt; \n\nBeyannamenin boşluklar dahil uzunluğu: 8503 karakter.\n\n\nİnsan Hakları Evrensel Beyannamesi\n\nBirleşmiş Milletler Genel Kurulu;\n\nİnsanlık topluluğunun bütün bireyleriyle kuruluşlarının bu Bildirgeyi her zaman göz önünde tutarak eğitim ve öğretim yoluyla bu hak ve özgürlüklere saygıyı geliştirmeye, giderek artan ulusal ve uluslararası önlemlerle gerek üye devletlerin halkları ve gerekse bu devletlerin yönetimi altındaki ülkeler halkları arasında bu hakların dünyaca etkin olarak tanınmasını ve uygulanmasını sağlamaya çaba göstermeleri amacıyla tüm halklar ve uluslar için ortak ideal ölçüleri belirleyen bu İnsan Hakları Evrensel Bildirgesini ilan eder.\n\nMadde 1- Bütün insanlar özgür, onur ve haklar bakımından eşit doğarlar. Akıl ve vicdana sahiptirler, birbirlerine karşı kardeşlik anlayışıyla davranmalıdırlar.\n\n\nHerhangi bir metni işlemeye başlamadan önce her zaman bir temizlik yapmak gerekiyor. Özellikle kullanmayacaksak, noktalama işaretlerini ve sayıları temizleyebiliriz. Bunun için Python string paketi işimizi görür. Hatırlarsanız metin değişkeni str sınıfındandı. Bu sınıfın sağladığı maketrans fonksiyonunu da istediğimiz dönüştürmeyi yapmakta kullanabiliriz.\n\nfrom string import punctuation, digits\n\ncevirici = str.maketrans('', '', punctuation)\nmetin = metin.translate(cevirici)\ncevirici = str.maketrans('', '', digits)\nmetin = metin.translate(cevirici)\n\nprint(metin[0:753])\n\nİnsan Hakları Evrensel Beyannamesi\n\nBirleşmiş Milletler Genel Kurulu\n\nİnsanlık topluluğunun bütün bireyleriyle kuruluşlarının bu Bildirgeyi her zaman göz önünde tutarak eğitim ve öğretim yoluyla bu hak ve özgürlüklere saygıyı geliştirmeye giderek artan ulusal ve uluslararası önlemlerle gerek üye devletlerin halkları ve gerekse bu devletlerin yönetimi altındaki ülkeler halkları arasında bu hakların dünyaca etkin olarak tanınmasını ve uygulanmasını sağlamaya çaba göstermeleri amacıyla tüm halklar ve uluslar için ortak ideal ölçüleri belirleyen bu İnsan Hakları Evrensel Bildirgesini ilan eder\n\nMadde  Bütün insanlar özgür onur ve haklar bakımından eşit doğarlar Akıl ve vicdana sahiptirler birbirlerine karşı kardeşlik anlayışıyla davranmalıdırlar\n\n\n\n\nİlk bakmak istediğim en sık kullanılan kelimeler. Ancak bu aşamaya geçmeden önce küçük-büyük harf farkını ortadan kaldırmalı. Bunu da str sınıfının sağladığı lower fonksiyonu ile bir satırda hallederiz.\n\nmetin = metin.lower()\nprint(metin[0:70])\n\ni̇nsan hakları evrensel beyannamesi\n\nbirleşmiş milletler genel kurulu\n\n\n\nGüzel. Şimdi kelime sayılarına bakalım. Metin işlemede en sık kullanılan veri saklama biçimine kelime çantası (bag of words) deniyor. Kabaca her kelimeyi ve bu kelimenin metinde kaç kez geçtiğini tutuyoruz. Saymaya başlamadan metni kelimelere ayıralım. Bu iş için de yine str sınıfının sağladığı split fonksiyonunu kullanabiliriz.\n\nkelimeler = metin.split()\nprint('Toplam kelime sayısı:', len(kelimeler))\nprint(kelimeler[0:5])\n\nToplam kelime sayısı: 1073\n['i̇nsan', 'hakları', 'evrensel', 'beyannamesi', 'birleşmiş']\n\n\nArtık elimizde bir kelimeler listesi var. Herhangi bi listenin içindekileri saymak için en hızlı yollardan bir tanesi collection paketinden Counter fonksiyonunu kullanmak.\n\nfrom collections import Counter\n\n# Kelime çantasını hazırlamak bir satır\nkelime_sayi = Counter(kelimeler)\n\nprint(type(kelime_sayi), '\\n')\n\n# En sık kullanılan 10 kelimeye\n# tek bir fonksiyon ile bakabiliyoruz.\nfor kelime in kelime_sayi.most_common(10):\n    print(kelime)\n    \nprint('\\n\\nMetinde \"insan\" kelimesi', kelime_sayi['insan'], 'kez geçiyor.')\n\n&lt;class 'collections.Counter'&gt; \n\n('ve', 77)\n('madde', 30)\n('bir', 28)\n('vardır', 25)\n('herkesin', 24)\n('hakkı', 22)\n('veya', 20)\n('bu', 15)\n('olarak', 11)\n('herkes', 10)\n\n\nMetinde \"insan\" kelimesi 3 kez geçiyor.\n\n\nİlk bakışta hallettik gibi gözükse de ufak bir sorunumuz var. Listede “herkes” ve “herkesin” kelimeleri ayrı olarak verilmiş. Aslında bu iki kelimeyi tek bir kelime olarak saymalıyız. Bunun için de kelimelerin köklerine bakmamız gerekecek. Neyse ki Python paketlerinden snowballstemmer kök çıkarma (stemming) işini Türkçe için de yapıyor. Önce nasıl çalıştığını bir test edelim.\n\nfrom snowballstemmer import stemmer\n\nkokbul1 = stemmer('turkish')\n\nprint(kokbul1.stemWords('vardır var'.split()))\nprint(kokbul1.stemWords('bildirgeyi bildirgede'.split()))\nprint(kokbul1.stemWords('herkes herkesin'.split()))\n\n['var', 'var']\n['bildirge', 'bildirge']\n['herkes', 'herke']\n\n\nFena değil. İlk iki örnekte çalıştı ama asıl bizim istediğimiz gibi “herkesin” ve “herkes” kelimeleri için aynı kökü vermedi. Bunu görünce internette biraz bakındım. Üç yıldır dokunulmamış da olsa şu paketi denemeye karar verdim. Birlikte nasıl çalışacağına bakalım. Bir yandan da yazının başında size göstermek istediğim iki noktadan ilkini halletmiş oluruz.\nTek yapmanız gereken sayfadaki paketi GIT kullanarak bilgisayarınıza kopyalamak (klonlama) ya da sıkıştırılmış dosyayı indirmek. Ben bu yazının da bulunduğu dizine (./) paketi klonladım. Bu şekilde paketi yüklemeden kullanabilirim.\n\nfrom sys import path\n\n# Python'a indirdiğimiz paketi tanıtalım\npath.append('./turkish-stemmer-python')\n\nfrom TurkishStemmer import TurkishStemmer\n\nkokbul2 = TurkishStemmer()\nprint([kokbul2.stem('vardır'), kokbul2.stem('var')])\nprint([kokbul2.stem('bildirgeyi'), kokbul2.stem('bildirgede')])\nprint([kokbul2.stem('herkes'), kokbul2.stem('herkesin')])\n\n['var', 'var']\n['bildirge', 'bildirge']\n['herkes', 'herk']\n\n\nMaalesef bu paket de çok başarılı değil. Olsun. Belki Veri Defteri takipçilerinden birisi Python için Türkçe kök bulma konusuna el atar ve hepimizin kullanacağı bir paket daha ortaya çıkar. Belki de hali hazırda böyle bir paket vardır. Bilemiyorum. Neyse, biz şimdilik ilk denediğimiz paket ile devam edelim.\n\nkelimeler = kokbul1.stemWords(kelimeler)\n\n# Kelime çantası\nkelime_sayi = Counter(kelimeler)\n\n#En sık kullanılan 10 kelime\nfor kelime in kelime_sayi.most_common(10):\n    print(kelime)\n\n('ve', 77)\n('madde', 30)\n('bir', 29)\n('var', 25)\n('herke', 24)\n('hakkı', 24)\n('veya', 20)\n('hak', 19)\n('bu', 15)\n('özgürlük', 13)\n\n\nBir metin işleme yazısının kelime bulutu (wordcloud) eksik ise çıplak kalmış sayılır. Hadi bunu da halledip, yazıyı toplayalım. Eğer Python programlama için Anaconda dağıtımını kurduysanız, kelime bulutu çizmek için bir paket olmadığını göreceksiniz. Hatta beraber bakıp teyit edelim. Anaconda ile gelen conda terminal programı ile yeni bir paket aranabilir. Aşağıdaki satırın başındaki ünlem işareti bu satırın terminalde çalıştırılacağını söylüyor.\n\n!conda search wordcloud\n\nFetching package metadata ...........\n\nPackageNotFoundError: Packages missing in current channels:\n            \n  - wordcloud\n\nWe have searched for the packages in the following channels:\n            \n  - https://repo.continuum.io/pkgs/main/osx-64\n  - https://repo.continuum.io/pkgs/main/noarch\n  - https://repo.continuum.io/pkgs/free/osx-64\n  - https://repo.continuum.io/pkgs/free/noarch\n  - https://repo.continuum.io/pkgs/r/osx-64\n  - https://repo.continuum.io/pkgs/r/noarch\n  - https://repo.continuum.io/pkgs/pro/osx-64\n  - https://repo.continuum.io/pkgs/pro/noarch\n            \n\n\n\nDediğim gibi böyle bir paket yok. Anaconda dağıtımının yanı sıra kullanabileceğimiz bir diğer paket yöneticisi ise pip. Bu programı da terminalden çalıştırıyoruz.\n\n!pip search wordcloud\n\najnwordcloud (0.2.3)               - simple wordcloud generator\nbing-cloud-search (0.6)            - A method of turning search terms into\n                                     wordclouds.\ncommand_history_wordcloud (1.1.1)  - Generates word cloud images for frequency\n                                     of commands usage on your shell\nfacebook_wordcloud (1.1)           - A Python tool for generating a word cloud\n                                     for a Facebook chat conversation.\ngeneratewordcloud (0.3)            - A simple Python (2 or 3) script to\n                                     generate a PNG word-cloud image from a\n                                     bunch of text files. Based on word_cloud.\nmatplotlib_venn_wordcloud (0.2)    - Create a Venn diagram with word clouds\n                                     corresponding to each subset.\npersian_wordcloud (1.3.1)          - Persian Word Cloud Generator\npixiedust-wordcloud (0.2.2)        - Word Cloud Visualization Plugin for\n                                     PixieDust\npywordcloud (0.2)                  - Generate Word Clouds in Python.\nwcloud (0.1.0)                     - Command line tool to generate wordclouds.\nwordcloud (1.3.1)                  - A little word cloud generator\n\n\nHah burada bir sürü kelime bulutu paketi var. Aralarından bana en kolay geleni, listenin en sonundaki paket. Onu kuralım.\n\n!pip install wordcloud\n\nCollecting wordcloud\nRequirement already satisfied: matplotlib in /Users/sibirbil/anaconda3/envs/veridefteri/lib/python3.5/site-packages (from wordcloud)\nRequirement already satisfied: pillow in /Users/sibirbil/anaconda3/envs/veridefteri/lib/python3.5/site-packages (from wordcloud)\nRequirement already satisfied: numpy&gt;=1.6.1 in /Users/sibirbil/anaconda3/envs/veridefteri/lib/python3.5/site-packages (from wordcloud)\nRequirement already satisfied: six&gt;=1.10 in /Users/sibirbil/anaconda3/envs/veridefteri/lib/python3.5/site-packages (from matplotlib-&gt;wordcloud)\nRequirement already satisfied: python-dateutil&gt;=2.0 in /Users/sibirbil/anaconda3/envs/veridefteri/lib/python3.5/site-packages (from matplotlib-&gt;wordcloud)\nRequirement already satisfied: pytz in /Users/sibirbil/anaconda3/envs/veridefteri/lib/python3.5/site-packages (from matplotlib-&gt;wordcloud)\nRequirement already satisfied: cycler&gt;=0.10 in /Users/sibirbil/anaconda3/envs/veridefteri/lib/python3.5/site-packages (from matplotlib-&gt;wordcloud)\nRequirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,&gt;=2.0.1 in /Users/sibirbil/anaconda3/envs/veridefteri/lib/python3.5/site-packages (from matplotlib-&gt;wordcloud)\nRequirement already satisfied: olefile in /Users/sibirbil/anaconda3/envs/veridefteri/lib/python3.5/site-packages (from pillow-&gt;wordcloud)\nInstalling collected packages: wordcloud\nSuccessfully installed wordcloud-1.3.1\n\n\nBu sayade yazının başında anlatmak istediğim ikinci noktayı da çaktırmadan aradan çıkartmış olduk. Şimdi yeni yüklediğimiz kelime bulutu paketini, kendi sayfasında verilen en basit örnekle deneyebiliriz. Diğer örneklere de bir göz atmanızı tavsiye ederim. Çok havalı olanları var.\n\n%matplotlib inline\nfrom wordcloud import WordCloud\nimport matplotlib.pyplot as plt\n\nwordcloud = WordCloud().generate(' '.join(kelimeler))    \n\nplt.imshow(wordcloud, interpolation='bilinear')\nplt.axis(\"off\")\nplt.show()\n\n\n\n\nBaşlıkta yazdığım gibi burada verdiklerim metin işlemenin sadece ilk adımları. Yapılacak daha çok şey var. Bu yazıda bile, örneğin, “ve, ama, falan” gibi işlevsel kelimeler ya da soru ifade eden ekler ile uğraşmadık. Aslına bakarsanız doğal dil işleme başlı başına bir çalışma alanı. Bu konuya zaten merak sarmış olanlar NLTK paketini inceleyebilirler. Oldukça kapsamlıdır. Biz de ilk bulduğumuz fırsatta farklı metin işleme örneklerini Veri Defteri sayfalarına eklemek istiyoruz. Bakalım.\n\nHer zamanki gibi bu yazıyı, kodları ve kullanılan veriyi GitHub sayfamızda bulabilirsiniz."
  },
  {
    "objectID": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html",
    "href": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html",
    "title": "Binder ile Jupyter defterleri paylaşmak",
    "section": "",
    "text": "Diyelim bir programlama eğitimi veriyorsunuz. Herkesin kullanması için bir Jupyter defteri hazırladınız. Katılımcılar bu defter üzerinde değişiklik yapacaklar, alıştırma problemleri çözecekler. Sorun şu ki, her katılımcı Jupyter ve diğer gerekli yazılımları kuramıyor. Bazılarının gerekli teknik bilgisi yok; bazıları kurabilmiş ama çalıştırdıklarında olmadık hata mesajları çıkıyor. Bazıları ise şirket bilgisayarlarında çalışıyor ve yazılım kurma yetkileri yok. Nereye koşacağınızı şaşırıyorsunuz.\nBaşka bir senaryo: Hesaplamalı bir çalışmayı bir bilimsel yayına çevirdiniz ve “tekrarlamalı araştırma” (reproducible research) prensiplerine göre, çalışmanızın kaynak kodlarını paylaşıyorsunuz. Hatta okuyanlara kolaylık sağlaması için açıklamaları, kodları ve grafikleri bir Jupyter defterine koydunuz, böylece her isteyenin sizin sonuçlarınızı tekrar üretebilmesini sağladınız. Sorun şu ki, ilgililer önce sizin hesaplama ortamınızı bilgisayarlarına birebir kurmak zorundadırlar. Yani sadece kullandığınız dilin (Python, R, Julia, Octave) yorumlayıcılarını kurmakla kalmayıp, kullandığınız özel amaçlı paketlerin belirli versiyonlarını da kurmaları gerekebilir. Hele yayınınızın üstünden birkaç yıl geçtiyse, kütüphanelerin yeni versiyonlardaki değişiklikler yüzünden kodunuz eski haliyle çalışmayabilir.\nBu sorunları nasıl çözeriz?"
  },
  {
    "objectID": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#binder-nedir",
    "href": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#binder-nedir",
    "title": "Binder ile Jupyter defterleri paylaşmak",
    "section": "Binder nedir?",
    "text": "Binder nedir?\nBu gibi durumlarda, yazılım mühendisliğinde “container” denilen çözümler kullanılır. Bunlar bulutta (sunucularda) çalışan, kendine yeterli işletim ortamlarıdır. Bir containerdeki programın çalışması için gereken ne varsa (kaynak kodu yorumlayıcı, kütüphaneler vs.) container içinde mevcuttur. Containerleri yönetmek için en çok kullanılan sistem “Docker”dir. Bir Docker engine, belli bir standarda göre hazırlanan containerler ile işletim sistemi arasında bir katmandır ve containerlerin çalışmasını sağlar.\nYukarıda bahsettiğimiz senaryolardaki problemleri bir bulutta kurulu bir Docker container çözebilir. Ama bir eğitmen veya bir araştırmacı iseniz, Docker’ın inceliklerini öğrenmeye ayıracak zamanınız veya böyle bir hizmeti almaya ayıracak bütçeniz olmayabilir. Burada Binder devreye giriyor ve bahsettiğimiz senaryolarda çok işe yarayacak bir Docker hizmetini ücretsiz ve kolay kullanılır bir şekilde sunuyor.\nBinder, ana hatlarıyla şöyle çalışıyor:\n\nGitHub’daki Jupyter defterlerinizi alıyor.\nGerekli kütüphanelerin ne olduğuna bakıyor.\nKodlarınızı çalıştırmak için gereken bütün yazılımları kurarak bir container hazırlıyor.\nSize tarayıcınızda çalıştırabileceğiniz bir arayüz sunuyor.\n\nBu adımlardan sonra herhangi birisi web tarayıcısı ile Binder’a bağlanarak aynı Jupyter defterini kendine göre çalıştırabilir. Her kullanıcı için ayrı bir ortam hazırlanacaktır ve birinin yaptığı değişiklikler diğerlerini etkilemeyecektir. Böylece herkes kendi keyfince denemeler yapabilir ve hesapları tekrarlayabilir.\nBasit bir örnek olarak, 2019 Karmaşık Sistemler ve Veri Bilimi Yaz Okulu’ndaki uygulama dersi için hazırladığım çalışmayı inceleyebilirsiniz. Çalışmanın GitHub reposu ile hazırlanan Binder hizmetine bağlandığınızda canlı ve etkileşimli bir Jupyter defteri açabileceksiniz."
  },
  {
    "objectID": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#bir-binder-hizmeti-oluşturmak",
    "href": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#bir-binder-hizmeti-oluşturmak",
    "title": "Binder ile Jupyter defterleri paylaşmak",
    "section": "Bir Binder hizmeti oluşturmak",
    "text": "Bir Binder hizmeti oluşturmak\nŞimdi böyle bir hizmeti en basit şekilde inşa edelim. Adımlarımız şöyle olacak:\n\nGitHub hesabı açmak\nBir GitHub reposu oluşturmak\nBasit bir Jupyter notebook hazırlamak ve repomuza eklemek\nRepomuza Binder için gerekli bilgileri eklemek\nBinder’de repomuzu oluşturmak ve çalıştırmak\n\nGitHub hesabı açmak için https://github.com/ adresine gidin. Kullanıcı adı, email ve parola kısımlarını doldurup “Sign Up” düğmesine tıklamanız yeterli.\nGitHub’da yeni bir repository (repo), yani ilişkili dosyaları birleştiren bir alan yaratmak için sol üst kısımdaki “New” düğmesine tıklayın, veya https://github.com/new adresine gidin.\n\nRepository ismi başka bir yerde kullanılmamış olmalı. Deneme için rastgele bir isim verebilirsiniz. Reponun herkese açık olması için “Public” seçilmesine dikkat edin, yoksa Binder repoya ulaşamaz. Diğer kısımlar bizim amaçlarımız için önemli değil.\nYarattığınız boş GitHub reposunu kendi bilgisayarınıza klonlamanız ve yarattığınız dosyaları “git” programını kullanarak GitHub ile senkronize etmeniz mümkün. Bu yazıda git kullanmanın ayrıntılarına girmeyeceğiz. Bununla ilgili ayrıntılı bilgiyi GitHub’dan veya başka kaynaklardan bulmanız mümkün.\nHazırladığınız Jupyter defterini “Upload files” düğmesine basarak yüklemeniz mümkün olur. Jupyter kullanmayı hiç bilmeyenler “Jupyter Notebook Nedir?” yazımıza bakabilir.\n\nBunun ardından, aynı repo içinde, kullandığınız Python kütüphanelerinin isimlerini ve sürüm numaralarını içeren requirements.txt isimli bir dosya oluşturmanız gerekli. Binder bu dosyaya bakarak Docker container içine Python’un yanı sıra neleri kurması gerektiğine karar verecek. Bu dosyayı oluşturmak için terminalde şu komutu çalıştırmanız yeterli.\n$ pip freeze &gt; requirements.txt\nArdından bu dosyayı da “Upload files” ile GitHub’a yükleyin.\nSon olarak, bu repoyu kullanan bir Binder hizmeti oluşturalım. MyBinder sayfasına gidin. GitHub reponuzun URL’sini ilgili kutuya yapıştırın. Altta otomatik olarak, bu reponun MyBinder üzerinden paylaşılabileceği bir bağlantı çıkacak.\n\nİşlem tamam!\nMyBinder sunucusuna ilk defa bağlandığınızda ilgili yazılımları ve kütüphaneleri kurarak yeni bir Docker containeri oluşturacak. Bunun için birkaç dakika gerekebilir. Sonraki bağlantılarda böyle bir gecikme olmayacaktır. Bununla beraber, GitHub reposunda değişiklikler olursa (dosya değişirse veya yeni dosya yüklenirse) aynı işlem bir seferliğine tekrarlanacaktır."
  },
  {
    "objectID": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#binder-uygulama-alanları",
    "href": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#binder-uygulama-alanları",
    "title": "Binder ile Jupyter defterleri paylaşmak",
    "section": "Binder uygulama alanları",
    "text": "Binder uygulama alanları\nYazının başındaki senaryolarımızın ortak sorunu, farklı bilgisayarlara sahip kişilerin aynı yazılım ortamını kendi bilgisayarlarına kurmaları ihtiyacıydı. Binder sayesinde bu sorunu ortadan kaldırıyoruz. Jupyter defterinizi çalıştırmak isteyenlerin bir tarayıcı açıp MyBinder bağlantısına gimeleri yeterli. Bilgisayar bile şart değil; cep telefonları ile de çalıştırabilirler. (Bunun temel sebebi Jupyter’in aslında bir web servisi olması.)\nGittiğiniz konferansta tanıştığınız, alanının lideri, seçkin ama geçkin bilim insanı size “Yaptığın çalışma çok ilginç, bendeki verilerle ve farklı parametrelerle denemek istiyorum” dediğinde “önce Python 3.7 kurmalısınız (3.8 olmasın), sonra libhede 1.0.4 kütüphanesi ve pyhödö 2.1.0-dev paketini kurun, ardından benim yazdığım konfigürasyon scriptini çalıştırın, sonra Jupyter kurun….” cevabı verirseniz onu kaybedersiniz. Onun yerine, “size whatsapp’dan bir link yollayayım, tıklayıp istediğiniz gibi çalıştırabilirsiniz” demeniz çok daha kolay olur herkes için."
  },
  {
    "objectID": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#mybinderin-kısıtlamaları",
    "href": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#mybinderin-kısıtlamaları",
    "title": "Binder ile Jupyter defterleri paylaşmak",
    "section": "MyBinder’in kısıtlamaları",
    "text": "MyBinder’in kısıtlamaları\nMyBinder ücretsiz bir hizmet; ama kaynakları iyi paylaştırabilmek için bazı kullanım kısıtlamaları koyuyor. Örneğin, bir defter 10 dakikadan fazla boş kaldıysa otomatik olarak kapatılıyor. Binder her kullanıcıya en az 1GB bellek garantisi veriyor, ama bellek ihtiyacı 2GB’nin üstüne çıkarsa Jupyter çekirdeği tekrar başlatılıyor.\nMyBinder açık bir hizmet olduğu için mahremiyet konusunda tedbirli olmanız tavsiye ediliyor. Repolarınızda hassas bilgiler (parolalar, API erişim şifreleri vs) bulunmamalı."
  },
  {
    "objectID": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#daha-ileri-uygulamalar",
    "href": "posts/2020/02/03/binder-ile-jupyter-defterleri-paylasmak/index.html#daha-ileri-uygulamalar",
    "title": "Binder ile Jupyter defterleri paylaşmak",
    "section": "Daha ileri uygulamalar",
    "text": "Daha ileri uygulamalar\nBu yazıda Python+Jupyter ile temel kullanımı özetledim, ama MyBinder hizmeti çok daha esnek. Örneğin, Python yerine R, Julia veya diğer dillerle de çalışabilirsiniz. Arayüz olarak JupyterLab veya RStudio kullanabilirsiniz.\nGitHub reponuzda kendi yazdığınız kodlar ve paketler bulunabilir, Jupyter defterinde bunları import edebilirsiniz. Docker ile çalışma ortamının kurulmasının ardından, konfigürasyon gibi özel işlemler yapan bir script ekleyebilirsiniz. Daha fazla bilgi için MyBinder belgelerine bakabilirsiniz."
  },
  {
    "objectID": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html",
    "href": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html",
    "title": "Python Programlamaya Giriş 15 - Dize Metodları",
    "section": "",
    "text": "Python programlamaya giriş yazı dizimizin bu bölümünde dizelerin kullanımını daha ayrıntılı inceleyeceğiz ve dize veri tipine ait olan metodların bazılarına örneklerle göz atacağız. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\nDize, bir veya daha fazla karakterden bir araya gelmiş bir sıralı veri tipidir. Dizelerle düz metin halindeki veriler alınıp işlenebilir. Veriler pek çok zaman düz metin dosyaları halinde bulunur. HTML, XML, JSON veya CSV gibi standartlardaki veriler de düz metinden oluşur. Bir metin verisini dize halinde aldığımızda, dize metodlarını kullanarak bu verileri işleyebilir, biçimlerini değiştirebilir, parçalayabilir, birleştirebilir, sıralayabilir, değişiklik yapabiliriz."
  },
  {
    "objectID": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#startswith-endswith",
    "href": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#startswith-endswith",
    "title": "Python Programlamaya Giriş 15 - Dize Metodları",
    "section": "startswith, endswith",
    "text": "startswith, endswith\nBir dizenin başlangıcında veya sonunda belli bir alt dizenin bulunması halinde True verirler.\n\ns = \"Python Programlamaya Giriş\"\ns.startswith(\"Pyth\"), s.startswith(\"python\")\n\n(True, False)\n\n\n\ns.endswith(\"iriş\"), s.endswith(\"xyz\")\n\n(True, False)"
  },
  {
    "objectID": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#büyük-küçük-harf-değişiklikleri",
    "href": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#büyük-küçük-harf-değişiklikleri",
    "title": "Python Programlamaya Giriş 15 - Dize Metodları",
    "section": "Büyük-küçük harf değişiklikleri",
    "text": "Büyük-küçük harf değişiklikleri\nDizeleri tamamen küçük veya büyük harfe çevirmek, cümlenin ilk harfinin büyük olmasını sağlamak, veya bir başlıktaki gibi her kelimenin büyük harfle başlamasını sağlamak için çeşitli dize metodları vardır.\n\ns = \"Pijamalı hasta yağız şoföre çabucak güvendi.\"\n\nprint(\"s.upper():\", s.upper())   # Hepsini büyük harfe çevir.\nprint(\"s.lower():\", s.lower())   # Hepsini küçük harfe çevir.\nprint(\"s.capitalize():\", s.capitalize())   # Sadece cümlelerin ilk harfini büyük yap. \nprint(\"s.swapcase():\", s.swapcase())   # Büyük harfleri küçüğe, küçükleri büyüğe çevir.\nprint(\"s.title():\", s.title())   # Her kelimenin ilk harfini büyük yap.\n\ns.upper(): PIJAMALI HASTA YAĞIZ ŞOFÖRE ÇABUCAK GÜVENDI.\ns.lower(): pijamalı hasta yağız şoföre çabucak güvendi.\ns.capitalize(): Pijamalı hasta yağız şoföre çabucak güvendi.\ns.swapcase(): pIJAMALI HASTA YAĞIZ ŞOFÖRE ÇABUCAK GÜVENDI.\ns.title(): Pijamalı Hasta Yağız Şoföre Çabucak Güvendi.\n\n\nGörüldüğü gibi bu fonksiyonlar Türkçedeki i ve I harflerini doğru şekilde işleyemiyorlar. Küçük i harfi büyük I harfine (ve tersine) dönüştürülüyor. Bu yüzden Python’un dize metodları, yazılımda Türkiye testi olarak bilinen testi geçemiyor.\n\n\"I İ\".lower(), \"ı i\".upper()\n\n('i i̇', 'I I')\n\n\nBu problemin çevresinden dolaşmak için kullanılacak bir yöntemi şuradan öğrenebilirsiniz."
  },
  {
    "objectID": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#alt-dizeleri-saymak-count",
    "href": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#alt-dizeleri-saymak-count",
    "title": "Python Programlamaya Giriş 15 - Dize Metodları",
    "section": "Alt dizeleri saymak: count",
    "text": "Alt dizeleri saymak: count\nBir dize içinde bir alt dizenin kaç kere geçtiğinin sayısını verir.\n\n\"ABCDABCAAABC\".count(\"ABC\")\n\n3\n\n\nSadece örtüşmeyen alt dizeler sayılır. Sözgelişi, \"AAAAA\" dizesinin içinde, örtüşmeleri sayarsak \"AA\" altdizesi 5 kere mevcuttur, ama count 2 sonucunu verir.\n\n\"AAAAA\".count(\"AA\")\n\n2"
  },
  {
    "objectID": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#bir-alt-dizenin-yerini-bulmak-find-rfind-index-rindex",
    "href": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#bir-alt-dizenin-yerini-bulmak-find-rfind-index-rindex",
    "title": "Python Programlamaya Giriş 15 - Dize Metodları",
    "section": "Bir alt dizenin yerini bulmak: find, rfind, index, rindex",
    "text": "Bir alt dizenin yerini bulmak: find, rfind, index, rindex\nfind metodu, bir dizenin içinde bir alt dizenin ilk bulunduğu konumu verir. Aranan alt dize mevcut değilse -1 döndürür.\n\ns = \"ABRAKADABRA\"\ns.find(\"RA\")\n\n2\n\n\n\ns.find(\"XYZ\")\n\n-1\n\n\nKonum saymanın sıfır ile başladığını hatırlayın; o yüzden \"RA\" dizesi üçüncü harfte başlıyor, ama konum indeksi 2.\nDikkat: Amacınız belli bir alt dizenin yerini bulmak değil, sadece mevcut olup olmadığını anlamaksa find yerine in kullanın.\n\n\"RA\" in s, \"XYZ\" in s\n\n(True, False)\n\n\nAramaya sağdan başlamak isterseniz rfind metodunu kullanın.\n\ns.rfind(\"RA\")\n\n9\n\n\nindex ile find aynı işi yapar. Tek farkları, aranan alt dize bulunamayınca index’in bir hata işareti (\"ValueError\") vermesidir. Hata yakalamaya dayalı programlarda tercih edilir.\n\ns.index(\"RA\")\n\n2\n\n\n\ns.index(\"XYZ\")\n\nValueError: substring not found\n\n\nAramaya sağdan başlamak isterseniz rindex komutunu kullanabilirsiniz."
  },
  {
    "objectID": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#dizeleri-birleştirmek-join",
    "href": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#dizeleri-birleştirmek-join",
    "title": "Python Programlamaya Giriş 15 - Dize Metodları",
    "section": "Dizeleri birleştirmek: join",
    "text": "Dizeleri birleştirmek: join\nBir sıralı nesnenin (liste, çokuz, dize, vs.) dize tipi elemanlarını birleştirerek yeni bir dize üretir.\n\n\"\".join([\"A\",\"67\",\"B\",\"0.15\"])    # yanyana yapıştırır\n\n'A67B0.15'\n\n\n\n\" \".join([\"A\",\"67\",\"B\",\"0.15\"])   # araya bir boşluk koyarak yapıştırır\n\n'A 67 B 0.15'\n\n\n\n\"-*-\".join([\"A\",\"67\",\"B\",\"0.15\"]) # araya -*- koyarak yapıştır\n\n'A-*-67-*-B-*-0.15'"
  },
  {
    "objectID": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#boşlukları-atmak-lstrip-rstrip-strip",
    "href": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#boşlukları-atmak-lstrip-rstrip-strip",
    "title": "Python Programlamaya Giriş 15 - Dize Metodları",
    "section": "Boşlukları atmak: lstrip, rstrip, strip",
    "text": "Boşlukları atmak: lstrip, rstrip, strip\nBu metodlar bir dizenin sol ve/veya sağ tarafındaki boş karakterleri (boşluk, kaydırma \\t, satırbaşı \\n) kaldırır. lstrip soldaki, rstrip sağdaki, strip ise her iki yandaki boşlukları temizler. Bu metodlar özellikle bir dosya satır satır okunurken yararlı olur.\n\ns = \"\"\"\n        ferah  ferah   \n\"\"\"\ns\n\n'\\n        ferah  ferah   \\n'\n\n\n\ns.lstrip()\n\n'ferah  ferah   \\n'\n\n\n\ns.rstrip()\n\n'\\n        ferah  ferah'\n\n\n\ns.strip()\n\n'ferah  ferah'"
  },
  {
    "objectID": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#değiştirme-replace",
    "href": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#değiştirme-replace",
    "title": "Python Programlamaya Giriş 15 - Dize Metodları",
    "section": "Değiştirme: replace",
    "text": "Değiştirme: replace\nDizede belli bir alt dizenin ortaya çıktığı her yeri başka bir alt dizeyle değiştirir.\n\ns = \"eskişehir'de eski bir evde eski bir kapı\"\ns.replace(\"eski\", \"yeni\")\n\n\"yenişehir'de yeni bir evde yeni bir kapı\"\n\n\nTercihe bağlı olarak, soldan itibaren sadece belli sayıda değiştirme de yapılabilir:\n\ns.replace(\"eski\", \"yeni\", 2)\n\n\"yenişehir'de yeni bir evde eski bir kapı\""
  },
  {
    "objectID": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#bölme-split-rsplit-splitlines",
    "href": "posts/2018/02/17/python-programlamaya-giris-15-dize-metodlari/index.html#bölme-split-rsplit-splitlines",
    "title": "Python Programlamaya Giriş 15 - Dize Metodları",
    "section": "Bölme: split, rsplit, splitlines",
    "text": "Bölme: split, rsplit, splitlines\nsplit metodu bir dizedeki kelimeleri belli yerlerden (varsayılan olarak boşluk karakterlerinden) böler ve ortaya çıkan bölümlerden oluşan bir dize listesi verir. Fazlalık boşluklar hesaba katılmaz.\n\n\"   kedi köpek   balık    kuş   \".split()\n\n['kedi', 'köpek', 'balık', 'kuş']\n\n\nBoşluk yerine başka bir ayırıcı kullanılabilir. Ayrıcı istenilen sayıda karakterden oluşabilir.\n\n\"1,2,3,4,5,6\".split(\",\")\n\n['1', '2', '3', '4', '5', '6']\n\n\n\n\"a&lt;&gt;b&lt;&gt;c&lt;&gt;d&lt;&gt;e\".split(\"&lt;&gt;\")\n\n['a', 'b', 'c', 'd', 'e']\n\n\nSadece belli sayıda bölme yapmak da mümkündür. Arta kalan kısım tek bir dizede toplanır.\n\n\"   kedi köpek   balık    kuş   \".split(maxsplit=2)\n\n['kedi', 'köpek', 'balık    kuş   ']\n\n\nSoldan değil sağdan başlayarak ayırmamız gerekirse rsplit metodunu kullanırız.\n\n\"   kedi köpek   balık    kuş   \".rsplit(maxsplit=2)\n\n['   kedi köpek', 'balık', 'kuş']\n\n\nBirden fazla satır barındıran bir dizeyi satır sınırlarından bölmek için splitlines metodu kullanılabilir.\n\ns = \"\"\"abcç\ndefgğ\nhıi\njkl\"\"\"\n\ns.splitlines()\n\n['abcç', 'defgğ', 'hıi', 'jkl']\n\n\nsplitlines metodu sadece satırbaşı (\"\\n\") ile değil, \"\\r\", \"\\v\", \"\\f\", ve satır sonu sayılan başka birkaç karakter ile de böler. Ayrıca, split’ten farklı olarak dize sonundaki \"\\n\" karakterini de göz ardı eder. Bir dosyanın içeriğini bütün olarak bir dizeye yüklediyseniz, onu satırlara bölmek için en uygunu splitlines kullanmaktır."
  },
  {
    "objectID": "posts/2018/07/25/python-programlamaya-giris-23-moduller-ve-paketler/index.html",
    "href": "posts/2018/07/25/python-programlamaya-giris-23-moduller-ve-paketler/index.html",
    "title": "Python Programlamaya Giriş 23 - Modüller ve paketler",
    "section": "",
    "text": "Her programlama dilinde olduğu gibi Python’da da tekrar tekrar kullanılabilen fonksiyon ve sınıfların bir kütüphane şeklinde ayrı dosyalarda saklanması ve yeni yazılan programlara entegre edilmesi için bir mekanizma vardır. Standart kütüphaneler, SciPy ve benzeri paketler, veya kendi kişisel fonksiyon kütüphaneniz bu modül sistemiyle inşa edilir.\nDizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut."
  },
  {
    "objectID": "posts/2018/07/25/python-programlamaya-giris-23-moduller-ve-paketler/index.html#dir-fonksiyonu",
    "href": "posts/2018/07/25/python-programlamaya-giris-23-moduller-ve-paketler/index.html#dir-fonksiyonu",
    "title": "Python Programlamaya Giriş 23 - Modüller ve paketler",
    "section": "dir() fonksiyonu",
    "text": "dir() fonksiyonu\nBir modülde tanımlanmış isimlerin (değişken ve fonksiyon) tam listesini görmek isterseniz dir() fonksiyonunu kullanabilirsiniz.\n\ndir(bm)\n\n['__builtins__',\n '__cached__',\n '__doc__',\n '__file__',\n '__loader__',\n '__name__',\n '__package__',\n '__spec__',\n 'f',\n 'g',\n 'x']\n\n\ndir() fonksiyonu sadece modüllerde değil, bir sınıf (class) içindeki isimleri almak için de kullanılabilir. Örneğin, bir liste nesnesindeki metodları listelemek için dir(list) komutu verebiliriz.\n\ndir(list)\n\n['__add__',\n '__class__',\n '__contains__',\n '__delattr__',\n '__delitem__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getitem__',\n '__gt__',\n '__hash__',\n '__iadd__',\n '__imul__',\n '__init__',\n '__init_subclass__',\n '__iter__',\n '__le__',\n '__len__',\n '__lt__',\n '__mul__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__reversed__',\n '__rmul__',\n '__setattr__',\n '__setitem__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n 'append',\n 'clear',\n 'copy',\n 'count',\n 'extend',\n 'index',\n 'insert',\n 'pop',\n 'remove',\n 'reverse',\n 'sort']"
  },
  {
    "objectID": "posts/2018/07/25/python-programlamaya-giris-23-moduller-ve-paketler/index.html#modülleri-tekrar-yüklemek",
    "href": "posts/2018/07/25/python-programlamaya-giris-23-moduller-ve-paketler/index.html#modülleri-tekrar-yüklemek",
    "title": "Python Programlamaya Giriş 23 - Modüller ve paketler",
    "section": "Modülleri tekrar yüklemek",
    "text": "Modülleri tekrar yüklemek\nBir import işlemi bir modül dosyasını baştan sona bir kere işletir, ama ikinci bir import komutu dosyayı baştan çalıştırmaz. Dolayısıyla, etkileşimli çalışırken (sözgelişi Spyder gibi bir IDE ile veya Jupyter defteri ile) modül dosyasında bir değişiklik yaptıysanız, tekrar import yapmak bu değişikliklerin görülmesini sağlamaz.\nSöz gelişi, basitmodul.py dosyasında g() fonksiyonunun tanımını değiştirelim:\n\n%%writefile basitmodul.py\nprint(\"basitmodul çalıştırıldı.\")\nx = 5\ndef f(x):\n    return x**2\ndef g():\n    print(\"Namaste\")\n\nOverwriting basitmodul.py\n\n\nBu yeni modül dosyasını import ile işletmeye çalışalım:\n\nimport basitmodul\nbasitmodul.g()\n\nMerhaba\n\n\nGörüldüğü gibi g()’nin eski tanımını kullanıyor. Zaten başta \"basitmodul çalıştırıldı\" mesajının çıkmaması da modülün işletilmediğine işaret ediyor.\nModülünüzün güncellenmiş olarak yeniden işletilmesini istiyorsanız ya Python yorumlayıcınızı kapatıp açmalısınız (Jupyter’de kernel restart), ya da importlib.reload() fonksiyonunu kullanmalısınız. Bu fonksiyon bir modül nesnesi döndürür.\n\nfrom importlib import reload\nbm = reload(basitmodul)\n\nbasitmodul çalıştırıldı.\n\n\n\nbm.g()\n\nNamaste\n\n\nTabii bir modül aslında dinamik bir nesne olduğu için, böyle bir değişiklik yapmak için her zaman dosyayı değiştirip tekrar yüklemek gerekmez; çalışma sırasında bir komutla da değişiklik yapılabilir.\n\nbm.g = lambda: print(\"Guten Tag\")\n\n\nbm.g()\n\nGuten Tag"
  },
  {
    "objectID": "posts/2018/07/25/python-programlamaya-giris-23-moduller-ve-paketler/index.html#paketlerde-alt-dizinler",
    "href": "posts/2018/07/25/python-programlamaya-giris-23-moduller-ve-paketler/index.html#paketlerde-alt-dizinler",
    "title": "Python Programlamaya Giriş 23 - Modüller ve paketler",
    "section": "Paketlerde alt dizinler",
    "text": "Paketlerde alt dizinler\nBir paketin altında başka dizinler de bulunabilir. Bu durumda her bir dizinin altında kendi __init__.py dosyası bulunmalıdır.\nİç içe dizinler şeklinde düzenlemiş bir pakete örnek olarak SciPy paketini ele alalım. Bu paketin altındaki dizinlerin bir kısmı şöyledir:\nscipy/\n    integrate/\n        __init__.py\n        ...\n    linalg/\n        __init__.py\n        ...\n    stats/\n        __init__.py\n        distributions.py\n        ...\nAlt paketlerdeki fonksiyonları import ederken nokta (.) işlemini kullanabiliriz.\n\nfrom scipy.integrate import quad\nquad(lambda x: x**3, 1, 2)  # x^3 fonksiyonunun 1'den 2'ye kadar integrali\n\n(3.7500000000000004, 4.1633363423443377e-14)\n\n\n\nimport scipy\nscipy.integrate.quad(lambda x: x**3, 1, 2)\n\n(3.7500000000000004, 4.1633363423443377e-14)\n\n\n\nimport scipy.integrate as intg\nintg.quad(lambda x: x**3, 1, 2 )\n\n(3.7500000000000004, 4.1633363423443377e-14)\n\n\n\nfrom scipy.stats.distributions import norm\nnorm.pdf((-2,-1,0, 1, 2))  # Normal dağılımın -2, -1, 0, 1, 2 için değerleri\n\narray([0.05399097, 0.24197072, 0.39894228, 0.24197072, 0.05399097])"
  },
  {
    "objectID": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html",
    "href": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html",
    "title": "Python Programlamaya Giriş 8 - Fonksiyon parametreleri",
    "section": "",
    "text": "Python Programlamaya Giriş yazı dizimize Python fonksiyonlarının temelleriyle devam ediyoruz. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\nBir önceki bölümde Python’da fonksiyonların nasıl yaratıldığından ve nasıl çağrıldığından bahsettik. Bir fonksiyon kapalı bir kutu gibidir: İçinde ne olup bittiğini görmeyiz, parametreler yoluyla bilgi veririz ve cevabı bir değer olarak geri alırız. Bu yazıda parametreleri nasıl kullandığımızı inceleyeceğiz."
  },
  {
    "objectID": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html#parametre-eşleştirme",
    "href": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html#parametre-eşleştirme",
    "title": "Python Programlamaya Giriş 8 - Fonksiyon parametreleri",
    "section": "Parametre eşleştirme",
    "text": "Parametre eşleştirme\nAldığı parametreleri ekrana yazan basit bir fonksiyonu ele alalım:\n\ndef f(a,b,c):\n    print(\"a = {}, b = {}, c = {}\".format(a,b,c))\n\nBu fonksiyonu çağırırken üç tane parametre değeri vermemiz gerekir:\n\nf(1,2,3)\n\na = 1, b = 2, c = 3\n\n\nFonksiyon, parametre olarak 1,2,3 sayılarını aldı ve bunları sırasıyla kendi içinde tanımlanan a, b, c değişkenlerine atadı. Sonuç olarak ekrana basılanlar da bu atamayla belirlendi.\nBuna konumla eşleştirme deniyor: Fonksiyon tanımında isimler hangi sırada verildiyse, fonksiyon çağrısında verilen parametreler de aynı sırayla atanır.\n\nf(3,2,1)\n\na = 3, b = 2, c = 1\n\n\nKonumla eşleştirmede fonksiyona lüzumundan az veya fazla sayıda parametre vermek bir hata mesajına yol açar.\n\nf(1,2)\n\nTypeError: f() missing 1 required positional argument: 'c'\n\n\n\nf(1,2,3,4)\n\nTypeError: f() takes 3 positional arguments but 4 were given\n\n\nParametreleri eşleştirmenin başka bir yolu fonksiyon çağrısında parametre isimlerini kullanmaktır. O zaman tanımlanma sırasına sadık kalmak gerekli olmaz. Bu yönteme isimle eşleştirme denir.\n\nf(c=4, b=1, a=\"asdf\")\n\na = asdf, b = 1, c = 4\n\n\nKonuma göre ve isme göre eşleştirmeler karıştırılabilir de. Bu durumda, öncelikle soldan sağa doğru konumsal eşleştirmeler yapılır, ardından isim eşleştirmeleri yapılır.\n\nf(1, c=3, b=2)\n\na = 1, b = 2, c = 3\n\n\nBir parametre konumla eşleştirilmişse, ardından ayrıca isimle eşleştirmek hata oluşturur.\n\nf(1, 2, b=9)\n\nTypeError: f() got multiple values for argument 'b'\n\n\nÖncelikli olarak konum eşleştirmesi yapıldığı için, isim eşleştirmelerinden sonra isimsiz bir parametre verilemez.\n\nf(1, b=2, 3)\n\nSyntaxError: positional argument follows keyword argument (&lt;ipython-input-9-a17b662ec26d&gt;, line 1)\n\n\nİsim eşleştirmeleri kodu daha okunaklı ve anlaşılır kılar. Bir fonksiyon çağrısının ne yaptığını anlamak kolaylaşır. Ayrıca parametrelerin ne sırada verildiğini hatırlamamıza gerek kalmaz. Parametre isimleri de dikkatli şekilde seçilmişse, fonksiyon çağrısının kendisi bir belgeleme gibi iş görür. Meselâ, aşağıdaki fonksiyon çağrısının ne yaptığı hemen anlaşılabilir:\ngezegen_ekle( isim=\"Mars\", kutle=0.7, yaricap=0.6, uydu=(\"Phobos\",\"Deimos\") )"
  },
  {
    "objectID": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html#varsayılan-değerler",
    "href": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html#varsayılan-değerler",
    "title": "Python Programlamaya Giriş 8 - Fonksiyon parametreleri",
    "section": "Varsayılan değerler",
    "text": "Varsayılan değerler\nFonksiyonu tanımlarken, parametrelerine varsayılan değerler atamak mümkündür. Fonksiyon çağrısında bir parametreye değer verilmezse, varsayılan değer kullanılır.\n\ndef f(a, b=2, c=3):\n    print(\"a = {}, b = {}, c = {}\".format(a,b,c))\n\nBu fonksiyonu çağırırken a için bir değer vermek zorundayız, ama b ve c için varsayılan değerler kullanılabilir. Yani en az bir, en fazla üç parametre değeri verebiliriz. Bu parametreler konuma göre veya isme göre verilebilir.\n\nf(1)    # b ve c varsayılan değerde\nf(a = 4)  # b ve c varsayılan değerde\nf(1,7)  # c varsayılan değerde\nf(1,\"hede\",6)    # hepsine yeni değer\nf(1,c=8)   # b varsayılan değerde\n\na = 1, b = 2, c = 3\na = 4, b = 2, c = 3\na = 1, b = 7, c = 3\na = 1, b = hede, c = 6\na = 1, b = 2, c = 8"
  },
  {
    "objectID": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html#belirsiz-sayıda-parametreler",
    "href": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html#belirsiz-sayıda-parametreler",
    "title": "Python Programlamaya Giriş 8 - Fonksiyon parametreleri",
    "section": "Belirsiz sayıda parametreler",
    "text": "Belirsiz sayıda parametreler\nBir fonksiyonun kaç tane parametre alacağını önceden belirtmek zorunda da değilsiniz. Fonksiyon tanımını aşağıdaki gibi yaparak bütün konumsal parametrelerin bir çokuza toplanmasını sağlayabilirsiniz.\n\ndef f(*par):\n    print(\"Parametreler:\", par)\n\n\nf()      # hiç parametre yok, boş çokuz.\nf(3)     # tek parametre, tekli çokuz.\nf(45, 3-4j, \"merhaba\", [1,2,3])   # dörtlü çokuz\n\nParametreler: ()\nParametreler: (3,)\nParametreler: (45, (3-4j), 'merhaba', [1, 2, 3])\n\n\nFonksiyonun tanımında *par kullanmakla bütün parametrelerin par isimli bir çokuza toplanmasını sağladık. Bu çokuzun elementlerini tek tek alarak bütün parametrelere sırayla ulaşabiliriz. Bu şekilde aynı fonksiyonda istediğimiz kadar çok parametre kulanabiliriz. Bu yönteme parametre paketleme (argument packing) diyoruz.\nFakat isimle eşleştirme yapmak istersek yukarıdaki tanımıyla fonksiyon doğru çalışmaz, çünkü parametrelere tek tek isim vermedik.\n\nf(a=4)\n\nTypeError: f() got an unexpected keyword argument 'a'\n\n\n\nf(**{\"a\":4})\n\nTypeError: f() got an unexpected keyword argument 'a'\n\n\nBöyle bir durumda, parametre paketleme işleminde çift yıldız (**) kullanırız. O zaman, isimlerle verilmiş bir parametre listesinin bir sözlüğe toplanmasını sağlayabiliriz.\n\ndef g(**par):\n    print(\"Parametreler:\",par)\n\n\ng()\ng(a=1, b=4)\n\nParametreler: {}\nParametreler: {'a': 1, 'b': 4}\n\n\nBöylece değişken isimlerine ve değerlerine, yukarıdaki tanımda par adını verdiğimiz bir sözlük aracılığıyla erişebiliriz. (Elbette par ismini kullanmak zorunda değilsiniz). Buradaki dinamik tanıma dikkat edin: a ve b parametreleri fonksiyonun orijinal tanımında yoktu; bu özel fonksiyon çağrısıyla beraber tanımlandılar.\nAma bu g() fonksiyonu da mükemmel değil. Sadece isimlendirilmiş parametrelerle çalışır, isimsiz (konuma dayalı) parametrelerde hata mesajı verir.\n\ng(1,2,3)\n\nTypeError: g() takes 0 positional arguments but 3 were given\n\n\nDaha genel bir fonksiyon arayüzü şöyle yazılabilir.\n\ndef f( *pargs, **kwargs ):\n    print(pargs)    # Konum eşleştirmeli parametreler çokuzu\n    print(kwargs)   # İsim eşleştirmeli parametreler sözlüğü\n\n\nf()\n\n()\n{}\n\n\n\nf(1, 2, a = \"xyz\", b = 3.14)\n\n(1, 2)\n{'a': 'xyz', 'b': 3.14}\n\n\nBöyle tanımlanmış bir fonksiyon hem konum hem de isim eşleştirmeli parametrelerle çalışabilir. Birçok hazır kütüphanede, böyle genel bir arayüzle tanımlanmış fonksiyonlar bulunur."
  },
  {
    "objectID": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html#parametre-çözme",
    "href": "posts/2018/01/10/python-programlamaya-giris-fonksiyon-parametreleri/index.html#parametre-çözme",
    "title": "Python Programlamaya Giriş 8 - Fonksiyon parametreleri",
    "section": "Parametre çözme",
    "text": "Parametre çözme\nYukarıda, bir parametre listesini nasıl bir çokuz haline getirebileceğimizi gördük. Tersini de yapmak mümkün: Fonksiyonu çağırırken bir çokuzdan parametreler çıkartabiliriz.\nVerilen argümanları ters sırada basan basit bir fonksiyon yazalım ve vereceğimizi parametreleri bir çokuza yazarak fonksiyona verelim.\n\ndef f(a,b,c,d):\n    print(d,c,b,a)\n\nf(1,5,9,13)\n\n13 9 5 1\n\n\n\nx = (1,5,9,13)\nf(x)\n\nTypeError: f() missing 3 required positional arguments: 'b', 'c', and 'd'\n\n\nDört parametre isteyen bir fonksiyonumuz var. Vereceğimiz parametreler x isimli bir çokuzda toplanmış. Fonksiyon çağrısını f(x) biçiminde yapmanın hataya yol açacağı bariz, çünkü dört parametre bekleyen bir fonksiyona bir tek parametre veriyoruz.\nEğer fonksiyon çağrısını f(*x) şeklinde yazarsak x’in elemanları tek tek alınıp parametre olarak f’ye verilir ve sorunsuzca çalışır. Bu işleme parametre çözme (argument unpacking) deniyor.\n\nf(*x)\n\n13 9 5 1\n\n\nParametreler başka bir sıralı veri tipinde (liste, dize) saklanıyorsa da aynı işlem geçerli olur.\n\nf(*[1,2,3,4])\nf(*\"xyzt\")\n\n4 3 2 1\nt z y x\n\n\nFonksiyonda parametre isimlerini a, b, c, d olarak tanımlamıştık. Bu isimleri kullanarak isim eşleştirmesi yapmak isteyebiliriz. Burada parametre çözme işlemi uygularken çokuz kullanamayız çünkü çokuzda parametre isimleri mevcut değil, sadece değerler mevcut. Bu durumda parametre çözmeyi ** notasyonu kullanarak, parametre isimlerini ve değerlerini içeren bir sözlükle yapmalıyız.\n\nD = {'b':2, 'd':4, 'a':1, 'c':3}\nf(**D)\n\n4 3 2 1\n\n\nİki yaklaşımı birleştirmek de mümkün:\n\nf( *(1,2), **{'c':\"merhaba\", 'd':[5,6]} )\n\n[5, 6] merhaba 2 1"
  },
  {
    "objectID": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html",
    "href": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html",
    "title": "Python Programlamaya Giriş 10 - Fonksiyon Alıştırmaları",
    "section": "",
    "text": "Python fonksiyonlarının uygulamalarının ardından, şimdi kendiniz uygulayabileceğiniz birkaç fonksiyon alıştırması verelim. Çözümleri bulmak size ait. Buradaki alıştırmaların ötesinde, daha önceki bölümlerde verdiğimiz örnekleri de bir fonksiyona dönüştürmeyi deneyebilirsiniz. Ayrıca internet kaynaklarında pek çok değişik konuda alıştırma örneği bulabilirsiniz.\nDizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut."
  },
  {
    "objectID": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#en-küçük-parametre-değeri",
    "href": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#en-küçük-parametre-değeri",
    "title": "Python Programlamaya Giriş 10 - Fonksiyon Alıştırmaları",
    "section": "En küçük parametre değeri",
    "text": "En küçük parametre değeri\nBelirsiz sayıda sayısal parametre alıp, parametreler arasındaki en küçük değeri geri veren bir fonksiyon yazın. (İpucu: Parametre paketlemesi kullandığımızda bütün parametrelerin fonksiyon içinde bir çokuza toplandığını görmüştük. Bu çokuz üzerinde bir döngüyle en küçük değeri bulabilirsiniz.)\nÖrnekler:\nenkucuk(7)\n7\n\nenkucuk(3,1,4)\n1\n\nenkucuk(1,2,3,-1,4,-2,5)\n-2\nParametre listesi boş ise None dönsün (return None komutunu kullanın).\nenkucuk()\nNone"
  },
  {
    "objectID": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#fibonacci-sayıları",
    "href": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#fibonacci-sayıları",
    "title": "Python Programlamaya Giriş 10 - Fonksiyon Alıştırmaları",
    "section": "Fibonacci sayıları",
    "text": "Fibonacci sayıları\nİlk n Fibonacci sayısını bir liste halinde veren bir fonksiyon yazın. Örnekler:\nfib(0)\n[]\n\nfib(1)\n[1]\n\nfib(2)\n[1, 1]\n\nfib(10)\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]"
  },
  {
    "objectID": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#satranç-atının-hareketi",
    "href": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#satranç-atının-hareketi",
    "title": "Python Programlamaya Giriş 10 - Fonksiyon Alıştırmaları",
    "section": "Satranç atının hareketi",
    "text": "Satranç atının hareketi\nSatranç tahtasında at L biçiminde hareket eder: Şekilde gösterildiği gibi bir yönde iki kare, sonra ona dik olarak bir kare.\n\nAtın tahtadaki pozisyonunu iki parametre olarak alan ve gidebileceği karelerin listesini veren bir fonksiyon yazın. Her kareyi bir ikili çokuzla gösterin, ('a',1), ('g',5) gibi. At tahtanın sınırlarına yakınsa, tahtanın dışına çıkacak hamleleri eleyin.\nÖrnek:\nathareket('d', 7)\n[('c',5),('e',5),('b',6),('f',6),('b',8),('f',8)]\n\nathareket('f',3)\n[('d',2),('d',4),('e',1),('e',5),('g',5),('g',1),('h',4),('h',2)]"
  },
  {
    "objectID": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#karekök-fonksiyonu",
    "href": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#karekök-fonksiyonu",
    "title": "Python Programlamaya Giriş 10 - Fonksiyon Alıştırmaları",
    "section": "Karekök fonksiyonu",
    "text": "Karekök fonksiyonu\nVerilen bir \\(N\\) sayısının karekökünü bulmak için Babil döneminden beri kullanılan tekrarlamalı (iteratif) bir yöntem vardır: Önce, karekök için bir tahminde bulunun ve buna \\(x_0\\) deyin. Bir sonraki tahminimiz \\[x_1 = \\frac{1}{2}\\left(x_0 + N/x_0\\right)\\] olacak. Genel olarak, \\[x_{n+1} = \\frac{1}{2}\\left(x_n + N/x_n\\right)\\] kuralıyla ardışık iterasyonlar yaparsak, \\(x_n\\) değerleri hızlıca \\(N\\)’nin kareköküne yakınsayacaktır.\nBu yöntem, fonksiyon köklerini bulmak için kullanılan en iyi algoritmalardan biri olan Newton yönteminin özel bir durumudur.\nBu algoritmayı kullanarak, bir sayının karekökünü veren bir fonksiyon yazın.\nParametreler: * Karekökü alınacak sayı N. * İlk tahmin x0. * Tolerans tol. Varsayılan değer \\(10^{-10}\\). * Azami iterasyon sayısı maxiter. Varsayılan değer 10.\nSonuç: * N’nin karekökü için en iyi tahmin\nFonksiyon içinde, yukarıdaki formülü tekrar tekrar işleterek daha iyi tahminlere ulaşan bir döngü yazın. Her adıımda, hata değeri \\(|x_n^2 - N|\\) ile tolerans tol karşılaştırılsın. Hata,i toleransın altına düşünce döngü sonlansın. Ayrıca, döngü iterasyonları sayısı maxiter’den fazla olursa yine döngü sonlansın. Bu durumda bir uyarı mesajı ekrana yazılsın ve fonksiyon döngüde elde edilen son sonucu versin.\nÖrnekler:\nkarekok(N=10, x0=1)\n3.162277660168379\n\nkarekok(N=10000, x0=0.1)\n10 iterasyonda sonuca ulaşılamadı. 'hata' veya 'maxiter' değerlerini değiştirin\n103.38412392442035\n\nkarekok(N=10000, x0=0.1, maxiter=15)\n100.0"
  },
  {
    "objectID": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#machin-formülü-ile-pi-sayısı",
    "href": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#machin-formülü-ile-pi-sayısı",
    "title": "Python Programlamaya Giriş 10 - Fonksiyon Alıştırmaları",
    "section": "Machin formülü ile Pi sayısı",
    "text": "Machin formülü ile Pi sayısı\nPi sayısını hesaplamak için birçok yöntem vardır. Bunların hepsi teorik olarak \\(\\pi\\)’ye eşit olsalar da, bazıları belli bir hassasiyete ulaşmak için çok fazla hesap gerektirdikleri için pratikte işe yaramazlar. 1706’da John Machin \\(\\pi\\) sayısı için hızlı yakınsayan, böylelikle az sayıda terimle yüksek doğruluk sağlayan bir formül yayınladı.\n\\[\\pi = 16 \\arctan \\frac{1}{5} - 4 \\arctan \\frac{1}{239}\\]\nBu formüldeki arktanjant fonksiyonunu hesaplamak için bir Taylor serisi kullanılabilir.\n\\[\\arctan x = x - \\frac{1}{3}x^3 + \\frac{1}{5}x^5 - \\frac{1}{7} x^7 + \\cdots\\]\nMachin formülünde arktanjantı alınan sayılar küçük oldukları için, serinin az sayıda elemanıyla yüksek hassasiyeti sağlamak mümkün olacaktır.\nMachin formülü ile \\(\\pi\\) sayısını yaklaşık olarak hesaplayan bir fonksiyon yazın. Fonksiyon sadece tolerans değerini parametre olarak alsın (varsayılan değer \\(10^{-8}\\)). Arktanjant fonksiyonu için matematik kütüphanesi kullanmayın, Taylor serisindeki terimleri gerekli toleransı sağlayana kadar ekleyin. Yeni eklenen terim toleransın altına düştüğünde durun."
  },
  {
    "objectID": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#ikinci-derece-denklemin-kökleri",
    "href": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#ikinci-derece-denklemin-kökleri",
    "title": "Python Programlamaya Giriş 10 - Fonksiyon Alıştırmaları",
    "section": "İkinci derece denklemin kökleri",
    "text": "İkinci derece denklemin kökleri\nBir \\(x\\) değişkeni için genel ikinci derece denklem \\(ax^2 + bx + c = 0\\) olarak ifade edilir. Eğer \\(a\\neq 0\\) ise, denklemin iki kökü\n\\[x_{1,2} = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}\\]\nformülüyle bulunur. Eğer \\(a=0\\) ise çözüm \\(x = -c/b\\) olur.\nDenklemin katsayıları a, b ve c’yi parametre olarak alan ve denklemin köklerini (ikili çokuz olarak) veren bir fonksiyon yazın. Fonksiyon a’nın 0 olduğu özel durumda tekli çokuz vermeli.\nDiskriminantın (\\(b^2 -4ac\\)) negatif olduğu durumlarda kökler reel sayı değil karmaşık sayı olacaktır. Bu durumlarda da fonksiyonun hatasız çalışması için, karmaşık sayıli matematik kütüphanesini import cmath komutuyla yükleyip, karekök almak için cmath.sqrt() fonksiyonunu kullanabilirsiniz.\nÖrnekler:\nkökler(1,0,-4)\n((2+0j), (-2+0j))\n\nkökler(1,0,4)\n(2j, -2j)\n\nkökler(0,1,4)\n-4.0"
  },
  {
    "objectID": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#mükemmel-sayılar",
    "href": "posts/2018/01/14/python-programlamaya-giris-fonksiyon-alistirmalari/index.html#mükemmel-sayılar",
    "title": "Python Programlamaya Giriş 10 - Fonksiyon Alıştırmaları",
    "section": "Mükemmel sayılar",
    "text": "Mükemmel sayılar\nBir sayı bütün çarpanlarının (1 dahil, kendisi hariç) toplamına eşitse, o sayıya mükemmel sayı denir. Sözgelişi, 1+2+3=6 olduğundan, 6 bir mükemmel sayıdır.\nVerilen bir sayı “mükemmel”se True, değilse False veren bir fonksiyon yazın. Örnek:\nmukemmel(6)\nTrue\n\nmukemmel(10)\nFalse\nBu fonksiyonu kullanarak, 10 000’den küçük bütün “mükemmel” sayıları bulun."
  },
  {
    "objectID": "posts/2018/01/30/python-programlamaya-giris-liste-metodlari/index.html",
    "href": "posts/2018/01/30/python-programlamaya-giris-liste-metodlari/index.html",
    "title": "Python Programlamaya Giriş 13 - Liste Metodları",
    "section": "",
    "text": "Yazı dizimizin önceki bir bölümünde Python’un öntanımlı veri tiplerini yüzeysel bir şekilde işlemiştik. Bu yazıda ve takip eden birkaç yazıda liste, dize, sözlük ve küme veri tiplerini daha ayrıntılı işleyeceğiz ve bu tip verilerle yapılabilecek işlemleri sıralayacağız. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut."
  },
  {
    "objectID": "posts/2018/01/30/python-programlamaya-giris-liste-metodlari/index.html#nesneler-ve-metodlar",
    "href": "posts/2018/01/30/python-programlamaya-giris-liste-metodlari/index.html#nesneler-ve-metodlar",
    "title": "Python Programlamaya Giriş 13 - Liste Metodları",
    "section": "Nesneler ve metodlar",
    "text": "Nesneler ve metodlar\nTemel kullanım için bunu bilmek çok gerekmese de, Python nesneye yönelik (object-oriented) bir dildir. Python’da tanımladığınız her şey bir nesnedir. Nesneler özel veri yapılarıdır; içlerinde verilerin yanı sıra, o verilerle yapılabilecek işlemleri tanımlayan fonksiyonlar barındırırlar. Söz gelişi, bir liste nesnesinin içinde elemanların değerleri, elemanların ne tipte olduğu, kaç eleman bulunduğu gibi veriler bulunur. Ayrıca listeye eleman ekleme, eleman çıkarma, sıralama gibi işlemler yapan fonksiyonlar da listeyi tanımlayan kodun içindedir. Veri tipinin (sınıfın) tanımı içinde bulunan fonksiyonlara o nesnenin metodları denir.\nHerhangi bir veri tipi içinde tanımlanmış isimleri (veri veya metod) dir fonksiyonuyla görebilirsiniz.\n\ndir(list)\n\n['__add__',\n '__class__',\n '__contains__',\n '__delattr__',\n '__delitem__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getitem__',\n '__gt__',\n '__hash__',\n '__iadd__',\n '__imul__',\n '__init__',\n '__init_subclass__',\n '__iter__',\n '__le__',\n '__len__',\n '__lt__',\n '__mul__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__reversed__',\n '__rmul__',\n '__setattr__',\n '__setitem__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n 'append',\n 'clear',\n 'copy',\n 'count',\n 'extend',\n 'index',\n 'insert',\n 'pop',\n 'remove',\n 'reverse',\n 'sort']\n\n\nBurada altçizgilerle başlayıp biten isimler list sınıfının (class) özel metodlarıdır. Bunlar kullanıcı tarafından doğrudan çağrılmamalıdır. Bu tür özel metodların bazıları, asıl metodlar için yardımcı işlemler olabilir. Bazıları ise in, +, *, &lt;, == vs. gibi işlemlerin tanımlanmasında kullanılır. Söz gelişi, iki listenin eşit olup olmadığını anlamak için L1 == L2 ifadesini kullandığımızda bu L1.__eq__(L2) biçimine getirilir.\nÖzel metodların nasıl kullanılıp tanımlanacağını ileride nesneye yönelik programlama konusunda göreceğiz. Şimdilik ilgimiz sadece “kamuya açık” (public) metodlarla, yani çevresinde altçizgiyle tanımlanmamış olan metodlarla sınırlı.\nİlgili sınıfların ve metodların belge dizelerine (docstring) ulaşmak için help fonksiyonunu kullanabilirsiniz.\n\nhelp(list)\n\nHelp on class list in module builtins:\n\nclass list(object)\n |  list() -&gt; new empty list\n |  list(iterable) -&gt; new list initialized from iterable's items\n |  \n |  Methods defined here:\n |  \n |  __add__(self, value, /)\n |      Return self+value.\n |  \n |  __contains__(self, key, /)\n |      Return key in self.\n |  \n |  __delitem__(self, key, /)\n |      Delete self[key].\n |  \n |  __eq__(self, value, /)\n |      Return self==value.\n |  \n |  __ge__(self, value, /)\n |      Return self&gt;=value.\n |  \n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |  \n |  __getitem__(...)\n |      x.__getitem__(y) &lt;==&gt; x[y]\n |  \n |  __gt__(self, value, /)\n |      Return self&gt;value.\n |  \n |  __iadd__(self, value, /)\n |      Implement self+=value.\n |  \n |  __imul__(self, value, /)\n |      Implement self*=value.\n |  \n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  __iter__(self, /)\n |      Implement iter(self).\n |  \n |  __le__(self, value, /)\n |      Return self&lt;=value.\n |  \n |  __len__(self, /)\n |      Return len(self).\n |  \n |  __lt__(self, value, /)\n |      Return self&lt;value.\n |  \n |  __mul__(self, value, /)\n |      Return self*value.n\n |  \n |  __ne__(self, value, /)\n |      Return self!=value.\n |  \n |  __new__(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  __repr__(self, /)\n |      Return repr(self).\n |  \n |  __reversed__(...)\n |      L.__reversed__() -- return a reverse iterator over the list\n |  \n |  __rmul__(self, value, /)\n |      Return self*value.\n |  \n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |  \n |  __sizeof__(...)\n |      L.__sizeof__() -- size of L in memory, in bytes\n |  \n |  append(...)\n |      L.append(object) -&gt; None -- append object to end\n |  \n |  clear(...)\n |      L.clear() -&gt; None -- remove all items from L\n |  \n |  copy(...)\n |      L.copy() -&gt; list -- a shallow copy of L\n |  \n |  count(...)\n |      L.count(value) -&gt; integer -- return number of occurrences of value\n |  \n |  extend(...)\n |      L.extend(iterable) -&gt; None -- extend list by appending elements from the iterable\n |  \n |  index(...)\n |      L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |  \n |  insert(...)\n |      L.insert(index, object) -- insert object before index\n |  \n |  pop(...)\n |      L.pop([index]) -&gt; item -- remove and return item at index (default last).\n |      Raises IndexError if list is empty or index is out of range.\n |  \n |  remove(...)\n |      L.remove(value) -&gt; None -- remove first occurrence of value.\n |      Raises ValueError if the value is not present.\n |  \n |  reverse(...)\n |      L.reverse() -- reverse *IN PLACE*\n |  \n |  sort(...)\n |      L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  __hash__ = None\n\n\n\n\nhelp(list.append)\n\nHelp on method_descriptor:\n\nappend(...)\n    L.append(object) -&gt; None -- append object to end\n\n\n\nBu metodları örneklerle görelim."
  },
  {
    "objectID": "posts/2018/01/30/python-programlamaya-giris-liste-metodlari/index.html#liste-metodları",
    "href": "posts/2018/01/30/python-programlamaya-giris-liste-metodlari/index.html#liste-metodları",
    "title": "Python Programlamaya Giriş 13 - Liste Metodları",
    "section": "Liste metodları",
    "text": "Liste metodları\n\nappend\n\nListenin sonuna bir eleman ekler.\n\nL = [1,\"abc\",3]\nL.append(\"xyz\")\nL\n\n[1, 'abc', 3, 'xyz']\n\n\n\nclear\n\nListeyi siler, bütün elemanları kaldırır.\n\nL = [1,2,5,3,5]\nL.clear()\nL\n\n[]\n\n\nAynısını del ve dilimleme ile de yapabiliriz.\n\nL = [1,2,5,3,5]\ndel L[:]\nL\n\n[]\n\n\n\ncopy\n\nListenin bir kopyasını çıkarır.\n\nL = [1,5,1,6,4]\nL2 = L.copy()\nL2\n\n[1, 5, 1, 6, 4]\n\n\nBöyle bir kopya, reverse veya sort gibi nesne içinde (in-place) değişiklik yapan metodlar kullanırken orijinal listenin değiştirilmemesini sağlar.\nAynı kopyalamayı dilimleme işlemi ile de yapabiliriz.\n\nL3 = L[:]\nL3\n\n[1, 5, 1, 6, 4]\n\n\n\ncount\n\nListede belli bir değere sahip kaç eleman olduğunu verir.\n\nL = [1,2,1,2,2,2,3,3,1,1]\nL.count(1)\n\n4\n\n\n\nL = [(1,2), (1,2), (3,2), (2,1)]\nL.count((1,2))\n\n2\n\n\n\nextend\n\nListenin sonuna bir liste ekleyerek genişletir.\n\nL1 = [1, \"abc\", 3]\nL2 = [\"xyz\", 5]\nL1.extend(L2)\nL1\n\n[1, 'abc', 3, 'xyz', 5]\n\n\nBunun append’den farklı olduğuna dikkat edin. Aynı işlemi append ile yaparsak L2 listesi kendi başına L1’in son elemanı olur.\n\nL1 = [1, \"abc\", 3]\nL2 = [\"xyz\", 5]\nL1.append(L2)\nL1\n\n[1, 'abc', 3, ['xyz', 5]]\n\n\nListelerde toplama (+) işlemi ve artırma (+=) işlemi arka planda extend ile yapılır.\n\nL1 = [1, \"abc\", 3]\nL2 = [\"xyz\", 5]\nL1 += L2\nL1\n\n[1, 'abc', 3, 'xyz', 5]\n\n\n\nindex\n\nBelli bir değerin ilk olarak hangi konumda olduğunu verir. Değer bulunamazsa ValueError hatası çıkarır.\n\nL = [12, \"abc\", -4, 11, \"abc\", 0.25, 64]\nL.index(\"abc\")\n\n1\n\n\n\nL.index(\"xyz\")\n\nValueError: 'xyz' is not in list\n\n\nAradığımız değere sahip sonraki elemanları da bulmak istiyorsak, bulunan ilk konumu saklayıp, index’e sonraki konumdan başlayarak aramasını söyleyebiliriz.\n\nL = [12, \"abc\", -4, 11, \"abc\", 0.25, 64]\nyer = L.index(\"abc\")\nL.index(\"abc\",yer+1)\n\n4\n\n\n\n[i for i,el in enumerate(L) if el==\"abc\"]\n\n[1, 4]\n\n\n\ninsert\n\nListede verilen konuma bir eleman sokar, sonraki elemanları kaydırır.\n\nL = [1, 2, \"abc\", -45]\nL.insert(3, \"xyz\")            # Şimdi L[3] \"xyz\" oldu, -45 kaydı.\nL\n\n[1, 2, 'abc', 'xyz', -45]\n\n\n\nL.insert(0, -10)              # en başa sokar.\nL\n\n[-10, 1, 2, 'abc', 'xyz', -45]\n\n\n\nL.insert(len(L), [3,1,4])     # en sona sokar. L.append([3,1,4]) ile aynı\nL\n\n[-10, 1, 2, 'abc', 'xyz', -45, [3, 1, 4]]\n\n\n\npop\n\nBelli bir konumdaki elemanın değerini verir ve listeden siler. Parametre almazsa son elemanı siler.\n\nL = [1,2,\"abc\",4,5,\"xyz\"]\nL.pop()\n\n'xyz'\n\n\n\nL\n\n[1, 2, 'abc', 4, 5]\n\n\n\nL.pop(2)\n\n'abc'\n\n\n\nL\n\n[1, 2, 4, 5]\n\n\n\nremove\n\nVerilen bir değere sahip olan ilk elemanı bulur ve onu listeden siler. Değer listede yoksa ValueError hatası verir.\n\nL = [2,1,5,2,\"abc\",1,\"abc\",1]\nL.remove(\"abc\")\nL\n\n[2, 1, 5, 2, 1, 'abc', 1]\n\n\n\nL.remove(\"abc\")\nL\n\n[2, 1, 5, 2, 1, 1]\n\n\n\nL.remove(\"abc\")\nL\n\nValueError: list.remove(x): x not in list\n\n\n\nreverse\n\nListe elemanlarının sırasını kendi içinde (in-place) ters çevirir. DİKKAT: Yeni bir liste döndürmez, mevcut listeyi değiştirir. Eğer orijinal listeyi bozmak istemiyorsanız bir kopya çıkarmalısınız.\n\nL = [3, 1, 4, 1, 5, 9]\nL.reverse()\nL\n\n[9, 5, 1, 4, 1, 3]\n\n\nGörüldüğü gibi L listesi değişmiş. Bunu istemiyorsanız, bir kopya çıkarıp onu ters çevirmelisiniz.\n\nL = [3, 1, 4, 1, 5, 9]\nL2 = L.copy()\nL2.reverse()\nprint(\"L =\",L)\nprint(\"L2 =\",L2)\n\nL = [3, 1, 4, 1, 5, 9]\nL2 = [9, 5, 1, 4, 1, 3]\n\n\nTabii daha kestirme olarak, sondan başa adımlarla dilimleme de yapabiliriz. Bu da orijinal listeyi değiştirmez\n\nL[::-1]\n\n[9, 5, 1, 4, 1, 3]\n\n\n\nsort\n\nListeyi kendi içinde (in-place) sıralar. Sıralamadan sonra orijinal liste değişir.\n\nL = [-4, -8, 1, 2, 1, 5, 9, 7]\nL.sort()\nL\n\n[-8, -4, 1, 1, 2, 5, 7, 9]\n\n\nSırayı ters çevirmek için reverse=True parametresi verilebilir.\n\nL = [-4, -8, 1, 2, 1, 5, 9, 7]\nL.sort(reverse=True)\nL\n\n[9, 7, 5, 2, 1, 1, -4, -8]\n\n\nkey parametresine bir fonksiyon verildiğinde bu fonksiyon önce her elemana uygulanır, sonuçlara göre sıralama yapılır. Sözgelişi, mutlak değerlere göre sıralama yapmak için:\n\nL = [-4, -8, 1, 2, 1, 5, 9, 7]\nL.sort(key=abs)\nL\n\n[1, 1, 2, -4, 5, 7, -8, 9]\n\n\nsort metodu orijinal listede değişiklik yapar. Bu tür nesne içi (in-place) değişiklikler performansı biraz artırsa da, bazen orijinal listeyi bozmamak isteyebiliriz. O zaman iki seçeneğimiz var: Orijinal listenin bir kopyasını çıkarıp onu sıralarız:\n\nL = [-4, -8, 1, 2, 1, 5, 9, 7]\nL2 = L.copy()\nL2.sort()\nprint(\"L =\",L)\nprint(\"L2 =\",L2)\n\nL = [-4, -8, 1, 2, 1, 5, 9, 7]\nL2 = [-8, -4, 1, 1, 2, 5, 7, 9]\n\n\nVeya, daha önce gördüğümüz öntanımlı sorted fonksiyonunu kullanırız:\n\nsorted(L)\n\n[-8, -4, 1, 1, 2, 5, 7, 9]"
  },
  {
    "objectID": "posts/2018/01/30/python-programlamaya-giris-liste-metodlari/index.html#hataya-dikkat-nesne-içi-değişiklik-yapan-metodlar",
    "href": "posts/2018/01/30/python-programlamaya-giris-liste-metodlari/index.html#hataya-dikkat-nesne-içi-değişiklik-yapan-metodlar",
    "title": "Python Programlamaya Giriş 13 - Liste Metodları",
    "section": "Hataya dikkat: Nesne içi değişiklik yapan metodlar",
    "text": "Hataya dikkat: Nesne içi değişiklik yapan metodlar\nYukarıda gördüğümüz sort ve reverse gibi metodlar, bağlı oldukları listenin verisini doğrudan doğruya değiştirirler. Buna nesne içi (in place) değiştirme denir. Geriye döndürdükleri bir değer yoktur.\n\nL = [1,4,2,5]\nprint(L.sort())\n\nNone\n\n\nYeni başlayan programcıların yaptıkları yaygın bir hata L.sort() çağrısını bir atamanın sağ tarafında kullanmaktır.\n\nL2 = L.sort()\n\nProgramcı burada L2’nin L’nin sıralanmış hali olduğunu ummaktadır (aslında L2 = sorted(L) yazması gerekirdi). Python bu atamayı sessizce yapar, ama aslında L2’yi bir listeye değil None değerine atamıştır.\n\nL2 is None\n\nTrue\n\n\nProgramın içinde daha sonra L2’yi kullanmak isteyen programcı şaşırtıcı hata mesajlarıyla karşılaşabilir.\n\nL2[0]\n\nTypeError: 'NoneType' object is not subscriptable\n\n\nBu sorunlardan kaçınmak için metodun çevrimiçi yardımına bakarak nesne içi değişiklik yapıp yapmadığını yoklamak gerekir."
  },
  {
    "objectID": "posts/2018/01/26/python-programlamaya-giris-sirali-nesnelerle-islemler/index.html",
    "href": "posts/2018/01/26/python-programlamaya-giris-sirali-nesnelerle-islemler/index.html",
    "title": "Python Programlamaya Giriş 12 - Sıralı Nesnelerle İşlemler",
    "section": "",
    "text": "Daha önceki bir bölümde Python’daki liste, çokuz, dize ve sözlük tiplerinin nasıl kullanıldığını kısaca özetlemiştik. Bu ve bunu izleyen üç yazıda liste, sözlük, dize ve küme veri tiplerine dair daha fazla ayrıntı işleyeceğiz. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\nBu yazının konusu sıralı nesne (sequential object) olarak anılan liste, çokuz ve dize tipleriyle ilgili bazı işlemlerdir. Bunlara sıralı nesne denmesinin sebebi, içlerinde barındırdıkları nesnelerin sırasının önemli oluşu. Söz gelişi, \"merhaba\" dizesi ile \"baharem\" dizesi farklıdır, aynı harfleri barındırmalarına rağmen. Buna karşılık bir sözlük sıralı nesne değildir, çünkü {\"ahmet\":123, \"ayşe\":456} ile {\"ayşe\":456, \"ahmet\":123} aynı sözlüğü tanımlarlar.\nBu yazıda göreceklerimiz: * Dilimleme (slicing) * Öntanımlı fonksiyonlar: range, len, del, list, tuple, join, all, any, enumerate, max, min, sorted, sum, zip * Türkçe alfabeye göre sıralama"
  },
  {
    "objectID": "posts/2018/01/26/python-programlamaya-giris-sirali-nesnelerle-islemler/index.html#dilimleme",
    "href": "posts/2018/01/26/python-programlamaya-giris-sirali-nesnelerle-islemler/index.html#dilimleme",
    "title": "Python Programlamaya Giriş 12 - Sıralı Nesnelerle İşlemler",
    "section": "Dilimleme",
    "text": "Dilimleme\nDaha önce, bir L sıralı nesnesinin i indeksli bir elemanına L[i] işlemi ile ulaşabildiğimizi görmüştük. Python’da indeksler sıfırdan başladığı için L[i] listenin i+1’inci elemanını verir.\n\nL = [3,4,5,6,7,8]\nL[0] # birinci eleman\n\n3\n\n\n\nL[1] # ikinci eleman\n\n4\n\n\nBazen sonuncu, sondan ikinci vs. elemanları elde etmek isteriz. Genellikle listenin kaç elemanlı olduğunu tam olarak bilmediğimiz için bunu genel bir ifadeyle yazmamız gerekir. Bunun bir yolu, listenin kaç elemanlı olduğunu veren len fonksiyonunu kullanmaktır.\n\nlen(L)\n\n6\n\n\nListe indeksleri sıfırdan başlayıp len(L)-1 değerine kadar gider. O zaman sonuncu elemanı L[len(L)-1] ile elde edebiliriz.\n\nL = [3,4,5,6,7,8]\nprint( L[len(L)-1] ) # sonuncu eleman\nprint( L[len(L)-2] ) # sondan bir önceki eleman\n\n8\n7\n\n\nPython bu zahmetli yazım yerine doğrudan negatif indeks kullanmaya izin verir. Negatif indeks kullanmak sondan itibaren saymak anlamına gelir. L[-i] ifadesi, sondan i’inci elemanı verir.\n\nprint( L[-1] ) # sonuncu eleman\nprint( L[-2] ) # sondan bir önceki eleman\n\n8\n7\n\n\nDizinin belli bir alt kümesini almak için L[a:b] ifadesini kullanırız. Bu dilimleme işlemi L[a] elemanından L[b-1] elemanına kadar bir alt dizi verir. Dikkat: Bu alt diziye L[b] dahil değildir.\n\nL[1:4] # ikinci elemandan dördüncü elemana kadar alır.\n\n[4, 5, 6]\n\n\nDilimleme işleminde başlangıç indeksini vermezsek, ilk elemandan başlanır.\n\nL[:4]  # birinci elemandan dördüncü elemana kadar alır.\n\n[3, 4, 5, 6]\n\n\nBitiş indeksini vermezsek, son elemana kadar gider.\n\nL[4:]  # beşinci elemandan sonuncuya kadar.\n\n[7, 8]\n\n\nBitiş indeksi olarak negatif bir sayı verirsek, o negatif sayıyla belirtilen indeksin bir öncesine kadar gider.\n\nL[4:-1] # beşinciden, sondan ikinciye kadar dilim\n\n[7]\n\n\nNe başlangıç ne de bitiş indeksi verirsek dizinin aynısı geri verilir. Bu ilk başta faydasız görünse de, listenin bir kopyasını çıkarma amacıyla sık kullanılan bir kalıptır.\n\nL[:]   # baştan sona dilim. Listenin bir kopyasını çıkarmakta kullanılabilir.\n\n[3, 4, 5, 6, 7, 8]\n\n\nDilimleme yaparken elemanları atlamamız da mümkündür.\n\nL[1:6:2]  # Birinciden altıncıya kadar iki atlayarak\n\n[4, 6, 8]\n\n\n\nL[::2]    # baştan sona kadar iki atlayarak\n\n[3, 5, 7]\n\n\nNegatif adım vererek diziyi sondan başa tarayabiliriz.\n\nL[::-2]   # sondan başa iki atlayarak\n\n[8, 6, 4]\n\n\n\nL[::-1]   # listeyi tersten yaz\n\n[8, 7, 6, 5, 4, 3]\n\n\nListe dilimlerine atama yaparak listeyi değiştirmemiz mümkün olur.\n\nL = [3,4,5,6,7,8]\nL[1:4] = [-1,-2,-3]   # birinciden dördüncüye kadar elemanları değiştir\nL\n\n[3, -1, -2, -3, 7, 8]\n\n\n\nL[::2] = [0,0,0]      # baştan sona kadar birer atlayarak elemanları sıfıra ata.\nL\n\n[0, -1, 0, -3, 0, 8]"
  },
  {
    "objectID": "posts/2018/01/26/python-programlamaya-giris-sirali-nesnelerle-islemler/index.html#dize-ve-çokuzlarla-dilimleme",
    "href": "posts/2018/01/26/python-programlamaya-giris-sirali-nesnelerle-islemler/index.html#dize-ve-çokuzlarla-dilimleme",
    "title": "Python Programlamaya Giriş 12 - Sıralı Nesnelerle İşlemler",
    "section": "Dize ve çokuzlarla dilimleme",
    "text": "Dize ve çokuzlarla dilimleme\nYukarıda gösterdiğimiz indeksleme ve dilimleme kuralları, sıralı nesne olan dize (string) ve çokuz (tuple) tiplerinde de aynen geçerlidir.\n\ns = \"abcçdefgğ\"\nt = (3,4,5,6,7,8)\n\n\ns[::-1]\n\n'ğgfedçcba'\n\n\n\nt[2:5]\n\n(5, 6, 7)\n\n\nTek fark, dize ve çokuzlar değiştirilemez (immutable) veri tipleri oldukları için elemanlarında dilimleme ile değişiklik yapılamaz.\n\nt[2:5] = (-1,-2,-3)\n\nTypeError: 'tuple' object does not support item assignment\n\n\nEğer amacımız ortadaki bazı elemanları değiştirilmiş olan bir çokuz elde etmekse, bunu dilimleri birleştirerek sağlayabiliriz.\n\nt = (3,4,5,6,7,8)\nt = t[:2] + (-1,-2,-3) + t[5:]\nt\n\n(3, 4, -1, -2, -3, 8)\n\n\nAynı yöntem tabii dizelerde de geçerli olur.\n\ns = \"abcçdefgğ\"\ns = s[:2] + \"XYZ\" + s[5:]\ns\n\n'abXYZefgğ'"
  },
  {
    "objectID": "posts/2018/01/26/python-programlamaya-giris-sirali-nesnelerle-islemler/index.html#temel-fonksiyonlar",
    "href": "posts/2018/01/26/python-programlamaya-giris-sirali-nesnelerle-islemler/index.html#temel-fonksiyonlar",
    "title": "Python Programlamaya Giriş 12 - Sıralı Nesnelerle İşlemler",
    "section": "Temel fonksiyonlar",
    "text": "Temel fonksiyonlar\nPython’un öntanımlı fonksiyonlarının bir kısmı sıralı nesneler üretmekte veya sıralı nesneler hakkında bilgi edinmekte kullanılırlar. Bunların en yaygınlarının nasıl kullanıldığına bakalım şimdi. Python’daki öntanımlı fonksiyonların tam listesini Python belgelerinde bulabilirsiniz.\n\nrange\nTamsayılardan oluşan bir liste üretmek için range(baş, son, adım) işlemini kullanabilirsiniz. Aslında range bir fonksiyon değil, bir veri tipi döndürür. Onu bir listeye çevirmek için ayrıca list işlemi gerekir.\n\nrange(10)\n\nrange(0, 10)\n\n\n\nlist(range(10))\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(2,10))\n\n[2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(2,10,2))\n\n[2, 4, 6, 8]\n\n\nrange işlemi bir liste değil, dizinin başlangıç, bitiş ve adım bilgilerini barındıran bir nesne geri verir sadece. Bu sayede, range(1000000) gibi çok uzun görünen bir dizi bile bellekte ancak range(10) kadar yer kaplar. Elemanlar ve alt aralıklar gerektiğinde aritmetik olarak hesaplanır.\n\nr = range(0,20,2)\nr\n\nrange(0, 20, 2)\n\n\n\n11 in r\n\nFalse\n\n\n\n10 in r\n\nTrue\n\n\n\nr[:5]\n\nrange(0, 10, 2)\n\n\n\nr[-1]\n\n18\n\n\nBir range nesnesi for döngüsünde doğrudan kullanılabilir.\n\nfor i in range(0,20,2):\n    print(i,end=\" \")\n\n0 2 4 6 8 10 12 14 16 18 \n\n\n\n\nlen\nKapsayıcı bir nesnenin kaç nesne barındırdığını verir. Sıralı olmayan tiplerle de kullanılabilir.\n\nlen([1,2,3])\n\n3\n\n\n\nlen(\"Hello\")\n\n5\n\n\n\nlen({\"a\": 45, \"b\": 5.4})\n\n2\n\n\n\nlen([])\n\n0\n\n\n\nlen(range(0, 20, 2))\n\n10\n\n\n\n\ndel\nGenel olarak, belli bir isme bağlı bir nesneyi bellekten kaldırır. Sıralı nesnelerde, bir dilimi silmek için de kullanılabilir.\n\na = 23\ndel a\na\n\nNameError: name 'a' is not defined\n\n\n\nL = [1,2,3,4,5,6]\ndel L[1]   # ikinci elemanı siler\nL\n\n[1, 3, 4, 5, 6]\n\n\n\ndel L[2:4]    # üçüncüden dördüncüye kadar olan elemanları siler\nL\n\n[1, 3, 6]\n\n\n\ndel L[:]      # bütün elemanları siler, ama L listesini silmez.\nL\n\n[]\n\n\n\ndel L         # L listesini siler\nL\n\nNameError: name 'L' is not defined\n\n\n\n\nlist, tuple, join\nlist fonksiyonu herhangi bir sıralı nesneyi bir liste nesnesine4 çevirmek için kullanılır.\n\ns = \"merhaba\"\nlist(s)  # dizeyi listeye çevirir.\n\n['m', 'e', 'r', 'h', 'a', 'b', 'a']\n\n\n\nt = (1,2,3,4)\nlist(t)  # çokuzu listeye çevirir.\n\n[1, 2, 3, 4]\n\n\ntuple fonksiyonu ise bir sıralı diziyi çokuza çevirir.\n\ns = \"merhaba\"\ntuple(s)\n\n('m', 'e', 'r', 'h', 'a', 'b', 'a')\n\n\n\nL = [1,2,3,4]\ntuple(L)\n\n(1, 2, 3, 4)\n\n\nBir dizenin harflerinden oluşan bir liste veya çokuz oluşturmak kolay olsa da, bunun tersi, yani harf listesini dizeye çevirmek için tek bir komut yok. Bu işlem için kabul edilen kalıp, dizelerin join metodunu kullanmaktır (bir metod, bir nesnenin içinde tanımlanmış bir fonksiyondur).\n\nL = ['m', 'e', 'r', 'h', 'a', 'b', 'a']\n\"\".join(L)\n\n'merhaba'\n\n\nGenel olarak s.join(L) işlemi L listesinin her elemanını aralarına s dizesini koyarak birleştirir. Yukarıdaki örnekte s bir boş dizeydi, o yüzden L’nin elemanları yanyana yazıldı. Eğer istersek, araya başka karakterler de koyabiliriz.\n\nL = ['m', 'e', 'r', 'h', 'a', 'b', 'a']\n\"-*-\".join(L)\n\n'm-*-e-*-r-*-h-*-a-*-b-*-a'\n\n\nDize birleştirmeyi aşağıdaki gibi bir for döngüsüyle de yapabiliriz.\n\ns = \"\"\nfor ls in L:\n    s = s + ls\ns\n\n'merhaba'\n\n\n\n\nall\nBir sıralı nesne içindeki bütün elemanlar mantıksal doğruya denkse True verir, yoksa False verir. Python’da sıfır, boş liste [], boş dize \"\" gibi yapıların da False sayıldığını; sıfır olmayan sayıların ve boş olmayan nesnelerin de True sayıldığını hatırlayın.\n\nall( [1, 2, 3, 4] )\n\nTrue\n\n\n\nall( (0, 1, 2, 3) )\n\nFalse\n\n\n\nall( \"abc\" )\n\nTrue\n\n\n\nall( [1, 2, ()] )\n\nFalse\n\n\n\n\nany\nBir liste içinde en az bir eleman mantıksal doğruya denkse True verir, yoksa False verir. Python’da sıfır, boş liste [], boş dize \"\" gibi yapıların da False sayıldığını; sıfır olmayan sayıların ve boş olmayan nesnelerin de True sayıldığını hatırlayın.\n\nany( [0, '', True] )\n\nTrue\n\n\n\nany( [0, '', False] )\n\nFalse\n\n\n\nany( [0, 'abc', False] )\n\nTrue\n\n\n\n\nenumerate\nBir sıralı nesnenin elemanlarına sıra numarası atamak için kullanılır. Özellikle döngülerde, bir nesne üzerinden iterasyon yaparken yararlı olur.\n\nlist(enumerate(\"abcd\"))\n\n[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]\n\n\n\nfor i,c in enumerate(\"abcçdefgğ\"):\n    print(i,c)\n\n0 a\n1 b\n2 c\n3 ç\n4 d\n5 e\n6 f\n7 g\n8 ğ\n\n\nBazı problemlerde, bir veri listesini tararken o verinin bulunduğu konuma dair bilgiye de ihtiyaç duyarız. Basit bir örnek olarak, bir isim listesinde Z ile başlayan isimlerin listedeki konumunu görmek isteyebiliriz. Bu amaçla yazdığımız bir for döngüsünde enumerate kullanabiliriz.\n\nisimler = [\"Kaan\",\"Meral\",\"Ziya\",\"Fındık\"]\nfor i, isim in enumerate( isimler ):\n    if \"Z\" in isim:\n        print(i,isim)\n\n2 Ziya\n\n\nPython dışındaki dillere alışık olan programcılar bu işlemi bir while döngüsüyle ve bir sayaçla yapmaya çalışırlar, örneğin şöyle bir kodla:\n\nisimler = [\"Kaan\",\"Meral\",\"Ziya\",\"Fındık\"]\ni = 0\nwhile i &lt; len(isimler):\n    if \"Z\" in isimler[i]:\n        print(i,isimler[i])\n    i += 1\n    \n\n2 Ziya\n\n\nAncak enumerate ile for kullanmak sadeliği ve okunaklılığı açısından tercih edilir.\n\n\nmax, min\nmax fonksiyonu bir sıralı nesne veya bir dizi parametre alır, aralarından en büyük değerli olanını geri verir.\n\nmax(4,2,8,3,1,7)\n\n8\n\n\n\nL = [4,2,8,3,1,7]\nmax(L)\n\n8\n\n\nDizelerden oluşan bir sıralı nesne verildiğinde max alfabetik sırada en ileride olanını döndürür.\n\nmax([\"dfg\",\"zxy\",\"abc\"])\n\n'zxy'\n\n\n\nmax(\"merhaba\")\n\n'r'\n\n\nkey parametresi ile her elemana önceden uygulanacak bir fonksiyon belirleyebilirsiniz ve maksimum bu fonksiyonun sonucuna göre tespit edilir. Söz gelişi, mutlak değer olarak en büyük elemanı bulmak için key=abs verebilirsiniz.\n\nL = [-1,-3, 4, -5, 2]\nmax(L, key=abs)\n\n-5\n\n\nmin fonksiyonu verilen bir dizinin içinde, veya parametreler içinde en küçük olanını döndürür. Kullanımı max ile aynıdır.\n\nmin(L, key=abs)\n\n-1\n\n\n\nmin(\"merhaba\")\n\n'a'\n\n\n\n\nsorted\nBir dizi nesnesi alır ve nesne elemanlarının düzgün sıralanmış olduğu bir liste döndürür.\n\nsorted([1, 3, -1, 4, -3, 6, 4])\n\n[-3, -1, 1, 3, 4, 4, 6]\n\n\nreverse parametresiyle sıralama ters çevrilir.\n\n sorted([1, 3, -1, 4, -3, 6, 4], reverse=True)      # ters sıralama\n\n[6, 4, 4, 3, 1, -1, -3]\n\n\nDizeler alfabetik sıraya konur.\n\nsorted(\"merhaba\")\n\n['a', 'a', 'b', 'e', 'h', 'm', 'r']\n\n\n\nsorted((\"Ziya\",\"Meral\",\"Kaan\",\"Fındık\"))\n\n['Fındık', 'Kaan', 'Meral', 'Ziya']\n\n\nkey parametresine verilen bir fonksiyon sıralamadan önce her elemana uygulanır; sonuç sıralaması bu fonksiyona göre belirlenir.\n\nsorted([1, 3, -2, 4, -5, 6, 4], key=abs)    # mutlak değere göre sıralar\n\n[1, -2, 3, 4, 4, -5, 6]\n\n\n\nsorted( [(1,2), (0,2), (3,4), (2,-1)] , key=sum)  # çokuz elemanların toplamına göre sıralar\n\n[(2, -1), (0, 2), (1, 2), (3, 4)]\n\n\n\nsorted( [(1,2), (0,2), (3,4), (2,-1)], key=lambda x:x[1]) # ikinci elemana göre sıralar\n\n[(2, -1), (1, 2), (0, 2), (3, 4)]\n\n\n\n\nTürkçe sıralama\nPython 3 Unicode kullandığı için İngilizce dışı harfleri kullanırken zorluk çıkarmaz. Ama alfabetik sıralama yapmaya çalıştığımızda doğru cevabı alamayabiliriz.\n\nsorted((\"Ahmet\",\"Şebnem\",\"Mehmet\",\"Ziya\",\"İsmail\",\"Ümit\"))\n\n['Ahmet', 'Mehmet', 'Ziya', 'Ümit', 'İsmail', 'Şebnem']\n\n\nTürkçe alfabeye göre sıralama yapmak için yerellik ayarı yapmalıyız. Bunun için locale modülünü yüklemeli, ardından da sorted fonksiyonuna key parametresi olarak locale.strxfrm fonksiyonunu vermeliyiz.\n\nimport locale\nlocale.setlocale(locale.LC_ALL, (\"tr\", 'UTF-8'))\nsorted((\"Ahmet\",\"Şebnem\",\"Mehmet\",\"Ziya\",\"İsmail\",\"Ümit\"), key=locale.strxfrm)\n\n['Ahmet', 'İsmail', 'Mehmet', 'Şebnem', 'Ümit', 'Ziya']\n\n\n\n\nsum\nBir sıralı nesnenin elemanlarının toplamını verir. Elemanlar sayısal değere sahip olmalıdır.\n\nsum([1,2,3])\n\n6\n\n\n\nsum(range(1,101))\n\n5050\n\n\n\n\nzip\nAynı uzunlukta iki veya daha çok listenin aynı konumdaki elemanlarını sırayla alır, bu elemanlardan çokuzlar oluşturur ve bu çokuzların listesini verir.\n\nL1 = [4, 5, 9]\nL2 = ['a', 'b', 'c']\nlist(zip(L1, L2))\n\n[(4, 'a'), (5, 'b'), (9, 'c')]\n\n\nzip ile farklı verileri birleştirerek bir for döngüsünde işlemek mümkün olur. Tıpkı enumerate gibi zip de bizi elemanları bir sayaç değişkeniyle takip etme mecburiyetinden kurtarır.\n\nyaşlar = [19, 25, 32, 27]\nboylar = [170, 180, 175, 169]\nağırlık = [75, 78, 81, 71]\nfor y, b, a in zip(yaşlar, boylar, ağırlık):\n    print(\"Yaş:\", y, \"Boy:\", b, \"Ağırlık:\",a)\n\nYaş: 19 Boy: 170 Ağırlık: 75\nYaş: 25 Boy: 180 Ağırlık: 78\nYaş: 32 Boy: 175 Ağırlık: 81\nYaş: 27 Boy: 169 Ağırlık: 71"
  },
  {
    "objectID": "posts/2018/05/22/lightgbme-giris/index.html",
    "href": "posts/2018/05/22/lightgbme-giris/index.html",
    "title": "LightGBM’e Giriş",
    "section": "",
    "text": "Bu yazımızda Microsoft tarafından hazırlanan ve Kaggle gibi platformlarda oldukça popülerleşen LightGBM kütüphanesini tanıtacağız. LightGBM kullanımı artan gradient boosting yöntemini kullanan bir kütüphane. Gradient Boosting yöntemini kullanan başka kütüphane ve modüller de mevcut. Örneğin scikit-learn üzerinden kullanabileceğiniz bir modül var. R kullanmayı tercih edenler için gbm kütüphanesi bir diğer alternatif. Ayrıca R ve Python üzerinde çalışabilen ve yine oldukça popüler bir kütüphane olan xgboost da gradient boosting yöntemini kullanan paketlere örnek olarak verilebilir. xgboost ve gbm paketlerini kullanmadığımı söylemem lazım. xgboost paketini Python üzerinden kullanmak çok kolay değil; ancak R üzerinden yüklemek Python’a göre daha kolay. scikit-learn paketine kıyasla LightGBMin avantajı ise oldukça hızlı olması. Hız farkı GPU kullanmadığınızda bile rahatlıkla görebileceğiniz düzeyde. LightGBM aynı zamanda scikit-learn komutlarını kullanmanıza imkan tanıyan bir katman (wrapper) ile geliyor.\n\nBoosting\nBoosting, kullanımı her geçen gün artan topluluk öğrenme (ensemble learning) yöntemlerinden biri. Boosting yöntemlerinin temeli, tahminleri rassal tahminden biraz daha başarılı zayıf öğrenen modellerin (weak learner) topluluk olarak tahmin yapması esasına dayanıyor. Örnek olarak bir ikili sınıflandırma problemi için zayıf öğrenen model, 0.5 olasılıktan biraz daha yüksek başarıyla tahmin yapan bir model olabilir. Boosting yöntemlerinde bu modeller sıralı olarak ve belirli ağırlıklar verilerek oluşturulur. AdaBoost yöntemi hatalı tahminlerin ağırlıklarını arttırarak sıradaki modeli oluşturarak hatayı azaltmaya çalışır. Gradient Boosting ise o iterasyonda yapılan hataları bir sonraki modelde öğrenmeye çalışarak tahmin yapar. Bu sayede ilk modellerde verideki örüntüler kabaca öğrenilir ve ileriki iterasyonlarda da yapılan hatalar düzeltilmeye çalışılır. Hatayı öğrenmek aynı zamanda modelin daha karmaşık yapıları öğrenebilmesini de sağlar. Gradient boosting ismi, tahmin etmeye çalıştığımız hatanın, fonksiyonunun gradyanının negatifine denk gelmesinden gelmektedir.\n\n\nLightGBM\nLightGBM paketinin dokümantasyonu parametreleri açıklama ve API’ı tanıtma konusunda başarılı. Aynı zamanda çeşitli uygulama örnekleri de mevcut. Paketi yüklemek için VC runtime uygulamasını yüklemiş olmanız şart. Uygulama Visual C++ yüklü olmayan bilgisayarlarda da LightGBM’in çalışmasını sağlayacak kütüphaneleri içeriyor. Bunu yükledikten sonra pip ya da conda ile yükleme yapabilirsiniz. Yükleme hakkında detaylı bilgi almak için paketin dokümanlarına bakabilirsiniz.\nBu paket benim dikkatimi Kaggle üzerindeki Instacart yarışmasıyla çekmişti. Bu yarışmanın forumlarındaki örneklere bakmanızı da tavsiye ederim. Hem verinin hazırlanması, hem de LightGBMin kullanımı konusunda iyi uygulamalara rastlayabilirsiniz.\nŞimdi LightGBM paketinin kullanımını UCI dizinindeki banka pazarlama veri kümesi üzerinden inceleyelim. Amaç müşterilerin özelliklerine ve ekonomik göstergelere bakarak müşterilerin kampanya tekliflerine dönüş yapıp yapmayacağını tahmin etmek. Elimizdeki problem iki sınıftan oluşan bir sınıflandırma problemi, ancak LightGBM farklı problem sınıfları için de kullanılabiliyor.\nPaketleri yükleyerek ve veri kümesini okuyarak başlayalım.\n\n# Veri çerçevesi oluşturmak için Pandas paketini kullanıyoruz.\nimport pandas as pd\n# Veri kümesini ikiye bölmek ve performans ölçütlerinin hesaplanması için gerekli modüller.\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import roc_auc_score, accuracy_score\n# Grafik çizdirmek için gerekli paket.\nimport matplotlib.pyplot as plt\n# LightGBM paketi.\nimport lightgbm as lgb\nimport numpy as np\n#Uyarı mesajlarını kapatmak için\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n# Veri çerçevelerini daha güzel görselleştirmek için\nfrom IPython.display import display, HTML\n# Veri kümesini okuyalım ve etiketleri ayıralım. Veri çerçevesindeki sütun isimlerini de değiştiriyoruz.\ndf = pd.read_csv('bank-additional-full.csv', delimiter=';')\ny= (df['y'] == 'yes')*1\ndf.drop('y', axis=1, inplace = True)\n\ndf.columns = ['yaş', 'iş', 'medeni_durum', 'eğitim', 'gecikme', 'ev', 'borç', 'iletişim', 'ay', 'haftanın_günü',\n              'süre', 'kampanya', 'önceki_iletişimden_sonra_geçen_gün', 'iletişim_sayısı', 'iletişim_sonucu', \n              'işsizlik', 'tüketici_fiyat_endeksi', 'tüketici_güven_endeksi', 'euribor_faizi', 'çalışan_sayısı'] \nprint(df.head())\n\n   yaş         iş medeni_durum       eğitim  gecikme   ev borç   iletişim  \\\n0   56  housemaid      married     basic.4y       no   no   no  telephone   \n1   57   services      married  high.school  unknown   no   no  telephone   \n2   37   services      married  high.school       no  yes   no  telephone   \n3   40     admin.      married     basic.6y       no   no   no  telephone   \n4   56   services      married  high.school       no   no  yes  telephone   \n\n    ay haftanın_günü  süre  kampanya  önceki_iletişimden_sonra_geçen_gün  \\\n0  may           mon   261         1                                 999   \n1  may           mon   149         1                                 999   \n2  may           mon   226         1                                 999   \n3  may           mon   151         1                                 999   \n4  may           mon   307         1                                 999   \n\n   iletişim_sayısı iletişim_sonucu  işsizlik  tüketici_fiyat_endeksi  \\\n0                0     nonexistent       1.1                  93.994   \n1                0     nonexistent       1.1                  93.994   \n2                0     nonexistent       1.1                  93.994   \n3                0     nonexistent       1.1                  93.994   \n4                0     nonexistent       1.1                  93.994   \n\n   tüketici_güven_endeksi  euribor_faizi  çalışan_sayısı  \n0                   -36.4          4.857          5191.0  \n1                   -36.4          4.857          5191.0  \n2                   -36.4          4.857          5191.0  \n3                   -36.4          4.857          5191.0  \n4                   -36.4          4.857          5191.0  \n\n\nVerideki değişkenlerin anlamlarını aşağıda ve veri kümesini indirebileceğiniz web sayfasında bulabilirsiniz:\n\nyaş: Müşterinin yaşı.\niş: Müşterinin işinin tanımı.\nmedeni_durum: Müşterinin medeni durumu.\neğitim: Müşterinin eğitim durumu.\ngecikme: Borcunu ödemekte gecikme yaşadığı kredi var mı?\nev: Ev kredisi ödüyor mu?\nborç: Başka kredi ödüyor mu?\niletişim: İletişim için seçtiği telefon tipi (sabit hat, GSM).\nay: En son iletişim kurulan ay.\nhaftanın_günü: En son iletişim kurulan gün (haftanın günü olarak).\nsüre: En son iletişim kurulan süre. Bu değişken 0 değerini aldığında etiket de 0 (ya da no) değerini aldığı için sağlıklı bir analiz için bu değişkeni veri kümesinden çıkarıyoruz.\nkampanya: Müşteri için bu kampanya özelinde kaç kere iletişim kurulduğu bilgisi.\nönceki_iletişimden_sonra_geçen_gün: Müşteriyle başka bir kampanya için iletişim kurulan günden bu yana geçen zaman. Değer 999 ise iletişim kurulmadığı anlamına geliyor.\niletişim_sayısı: Müşteriyle bu kampanya öncesi kurulan iletişim sayısı.\niletişim_sonucu: Önceki kampanya iletişiminin sonucu.\n\nişsizlik: İşsizlik endeksindeki değişim.\ntüketici_fiyat_endeksi: Tüketici fiyat endeksi.\ntüketici_güven_endeksi: Tüketici güven endeksi.\neuribor_faizi: Euribor faizi (Euro Interbank Offered Rate).\nçalışan_sayısı: Çalışan nüfus sayısı.\n\nGördüğümüz gibi son beş değişken daha çok sosyal ve ekonomik göstergelerden oluşuyor. Bu göstergeler kampanya teklifinin yapıldığı zamana ait değerleri içeriyor. Veri kümesinde eksik değerler olup olmadığını inceleyelim.\n\nprint(df.isnull().sum())\n\nyaş                                   0\niş                                    0\nmedeni_durum                          0\neğitim                                0\ngecikme                               0\nev                                    0\nborç                                  0\niletişim                              0\nay                                    0\nhaftanın_günü                         0\nsüre                                  0\nkampanya                              0\nönceki_iletişimden_sonra_geçen_gün    0\niletişim_sayısı                       0\niletişim_sonucu                       0\nişsizlik                              0\ntüketici_fiyat_endeksi                0\ntüketici_güven_endeksi                0\neuribor_faizi                         0\nçalışan_sayısı                        0\ndtype: int64\n\n\nVeri kümesinde eksik değer yok. Aslında bilinmeyen (unknown) gibi değerler mevcut. Ayrıca önceki_iletişimden_sonra_geçen_gün değişkeni de 999 değerini aldığında bu değişkenin tanımlı olmadığı duruma denk geliyor. Şimdilik eksik değerlere odaklanmayalım ancak ileride eksik değerlerle tahmin yapmayı da göreceğiz.\nVeri kümesinde eksik değer bulunmasa da, kategorik değişkenler bulunmakta. Örnek olarak iş sütununu inceleyelim.\n\ndf['iş'].unique()\n\narray(['housemaid', 'services', 'admin.', 'blue-collar', 'technician',\n       'retired', 'management', 'unemployed', 'self-employed', 'unknown',\n       'entrepreneur', 'student'], dtype=object)\n\n\nKategorik değişkenleri sayısal hale getirmemiz gerekiyor. Bu amaçla scikit-learn paketindeki LabelEncoder modülünü kullanabiliriz. Bahsettiğim modül değişkenleri 0 ve değer sayısı - 1 (bu örnekte 12 ayrı değer olduğu için 11) arasındaki sayılara çevirecek. Örnek olarak housemaid 0 değerini alırken student 11 değerini alacak. Kategorik değişkenleri 0 ve 1 değerleri alan kukla değişkenlere çevirmek için LabelBinarizer modülünü kullanabilirsiniz. Veri kümesinin boyutunu arttırmamak için ben LabelEncoderı kullandım. LightGBM kategorik değişkenleri belirttiğimiz takdirde, bu değişkenleri o bilgiye göre değerlendirebiliyor. Ayrıca, LightGBM birbirini dışlayan (mutually exclusive) sütunları kendi içinde birleştirdiği için yapacağımız iki değişiklik de aynı kapıya çıkacak.\nVeri kümesindeki kategorik değişkenleri sayısal hale getirelim.\n\nfrom sklearn.preprocessing import LabelEncoder\n\nkategorik_sutunlar = ['iş', 'medeni_durum', 'eğitim', 'gecikme', 'ev', 'borç', 'iletişim', 'ay',\n                      'haftanın_günü', 'iletişim_sonucu']\n\nfor i in kategorik_sutunlar:\n    le = LabelEncoder()\n    df[i] = le.fit_transform(df[i])\nprint(df.head())\n\n   yaş  iş  medeni_durum  eğitim  gecikme  ev  borç  iletişim  ay  \\\n0   56   3             1       0        0   0     0         1   6   \n1   57   7             1       3        1   0     0         1   6   \n2   37   7             1       3        0   2     0         1   6   \n3   40   0             1       1        0   0     0         1   6   \n4   56   7             1       3        0   0     2         1   6   \n\n   haftanın_günü  süre  kampanya  önceki_iletişimden_sonra_geçen_gün  \\\n0              1   261         1                                 999   \n1              1   149         1                                 999   \n2              1   226         1                                 999   \n3              1   151         1                                 999   \n4              1   307         1                                 999   \n\n   iletişim_sayısı  iletişim_sonucu  işsizlik  tüketici_fiyat_endeksi  \\\n0                0                1       1.1                  93.994   \n1                0                1       1.1                  93.994   \n2                0                1       1.1                  93.994   \n3                0                1       1.1                  93.994   \n4                0                1       1.1                  93.994   \n\n   tüketici_güven_endeksi  euribor_faizi  çalışan_sayısı  \n0                   -36.4          4.857          5191.0  \n1                   -36.4          4.857          5191.0  \n2                   -36.4          4.857          5191.0  \n3                   -36.4          4.857          5191.0  \n4                   -36.4          4.857          5191.0  \n\n\nBurada şunu belirtmem gerekiyor. Yaptığımız dönüşüm işlemini geri dönüşsüz olarak yaptık. Yani dönüştürdüğümüz kolonlardaki değerleri kaybettik. Veri kümesinin orijinal versiyonuyla bir eşleştirme yaparak bu değerleri tekrar elde edebiliriz. Eski değerleri koruyarak bu değişimi yapmak scikit-learn ile biraz daha zor bir işlem ve bu yazının konusunun dışında. Ancak derin kopyalama ile veri çerçevesinin orijinalinin bir kopyasını oluşturmak mümkün.\nVeri kümesini analize uygun hale getirdiğimize göre eğitim ve sınama için ikiye bölelim ve süre değişkenini kümeden çıkartalım.\n\ndf.drop('süre', inplace = True, axis=1)\ndf_train, df_test, y_train, y_test = train_test_split(df, y, train_size = 0.7, test_size = 0.3)\n\n\n\nVeri kümesi oluşturma\nLightGBM, numpy sıralı nesneleri ve pandas veri çerçeveleri yanında kendi veri kümesi (Dataset) ile de çalışabiliyor. Veri kümesi oluştururken etiket değerlerini (label) ve verinin kendisini (data) veri kümesine tanıtmamız gerekiyor. free_raw_data=False opsiyonuyla da veri kümesini oluştururken kullandığınız veri çerçevesi ya da sıralı nesnelerin kodun ilerleyen kısımlarında kullanılabilmesini sağlıyor. Veri kümelerini oluştururken kategorik değişkenleri tanımlamak mümkün olsa da biz bunu modelin eğitilmesi sırasında yapacağız.\n\n# Veri kümesi oluşturalım.\nlgb_train = lgb.Dataset(data=df_train, label=y_train,  free_raw_data=False)\n\n\n\nModelin parametrelerini belirleme\nScikit-learn’den farklı olarak kuracağımız modelin parametrelerini bir sözlük olarak tanımlamamız gerekiyor. LightGBM daha çok parametre içerdiği için hepsinden bahsetmek yararlı olmayabilir. Ama en önemli parametreleri aşağıda bulabilirsiniz:\n\ntask: Eğitim için ‘train’ değerini kullanabiliriz. Bunun yanısıra tahmin ve test için ‘predict’ ve modeli yeni veri ile güncellemek için ‘refit’ değerlerini kullanabiliriz.\nboosting_type: Boosting için kullanacağımız yöntemi belirtmek için kullanıyoruz.\n\n‘gbdt’ karar ağaçları temelli gradient boosting,\n‘rf’ rastgele orman,\n‘goss’ Gradient-based One-Side Sampling, enküçüklemek istediğimiz hata fonksiyonuna çok fazla katkısı olmayan gözlemleri kısmen dışarıda bırakan bir yöntem,\n‘dart’ Dropouts meet Multiple Additive Regression Trees, gradient boosting yönteminde aşırı uyumu engelleyen bir yöntem.\n\nobjective: Çözeceğimiz problem tipi ve enküçükleyeceğimiz hata fonksiyonunu belirtiyor. LightGBM sınıflandırma, bağlanım, sıralama gibi problemleri çözebilen bir kütüphane. En sık kullanacağız problem tiplerini aşağıda bulabilirsiniz:\n\n‘binary’: ikili sınıflandırma problemleri için,\n‘regression_l1’ ortalama mutlak hatayı enküçükleyen bağlanım problemleri için,\n‘regression_l2’ ortalama karesel hatayı enküçükleyen bağlanım problemleri için,\n‘multiclass’ çok sınıflı sınıflandırma problemleri için,\n‘lambdarank’ sıralama problemleri için kullanılabilir. Bahsettiklerim dışında birçok amaç fonksiyonunu kullanmanız mümkün.\n\nmetric: Modelin başarısını değerlendirmek için kullanacağımız değerlendirme ölçütü. LightGBM birden fazla ölçütü desteklediği gibi, bu değeri boş bırakmanız halinde belirttiğiniz objective değerine uygun bir ölçüt seçecektir. Yukarıda belirttiğimiz uygulamalar için aşağıdaki ölçütler uygun olabilir:\n\n‘AUC’: eğri altı alan\n‘binary_error’: isabetlilik\n‘binary_logloss’: logaritmik kayıp fonksiyonu (sınıflandırma problemlerinde atanan olasılıklara göre değişen bir hata fonksiyonu)\n‘l1’: ortalama mutlak hata\n‘l2’: ortalama karesel hata\n‘multi_error’: çok sınıflı sınıflandırma problemlerinde isabetlilik\n‘multi_logloss’: çok sınıflı sınıflandırma problemlerindeki olasılıksal hata\n\nnum_leaves: Her iterasyonda oluşturulacak karar ağacının yaprak sayısı. Bu rakamın yüksek olması yöntemin çalışma süresini uzatıp performansını düşürecektir. Boosting iterasyonlarındaki tahminler çok iyi yöntemlere ihtiyaç duymaz.\nlearning_rate: Bu değer yöntemin ilerledikçe oluşturulan karar ağaçlarının önemindeki azalma oranını gösterir. Değerin yüksek olması hatayı tahmin eden karar ağaçlarının önemini arttıracağı için sonucu kötüleştirebilir.\nnum_boosting_round: Yöntemde kullanacağımız iterasyon sayısını belirler. İterasyon sayısının yüksek olması aşırı uyuma yol açabilir; düşük olması ise örüntüleri öğrenmemizi engeller. num_leaves, learning_rate ve num_boosting_round değerlerini birlikte değerlendirmemiz gerekir.\n\nEn temel parametrelerden oluşan bir model kurarak başlayalım. Modelimiz bir ikili sınıflandırma problemi. Eniyilenecek ölçüt olarak eğri altı alan değerini seçelim. Modeli eğitmek için train fonksiyonunu kullanacağız ve kategorik öznitelikleri de belirtiyoruz.\n\n# Eğitim parametrelerini belirleyelim\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'binary',\n    'metric': 'auc',\n    'num_leaves': 31,\n    'learning_rate': 0.05,\n    'verbose': -1\n}\n\n# Kategorik değişkenlerin indeksleri\nkategorik_indeks = [1,2,3,4,5,6,7,8,9,13]\nprint('Kategorik değişkenler: ' + str(df_train.columns[kategorik_indeks].values))\n\nprint('Eğitim...')\n# Modeli eğitelim\ngbm = lgb.train(params,\n                lgb_train,\n                categorical_feature = kategorik_indeks)\nprint('Eğitim bitti...')\n\nKategorik değişkenler: ['iş' 'medeni_durum' 'eğitim' 'gecikme' 'ev' 'borç' 'iletişim' 'ay'\n 'haftanın_günü' 'iletişim_sonucu']\nEğitim...\nEğitim bitti...\n\n\nŞimdi eğittiğimiz modelin başarısına bakalım. Bu amaçla predict fonksiyonunu kullanacağız. Alternatif olarak task değerini değiştirmeyi de tercih edebilirdik.\n\n# Tahmin ve değerlendirme\ny_pred = gbm.predict(df_test)\n\nprint('Eğri altı alan değeri:', roc_auc_score(y_test, y_pred))\nprint('İsabetlilik değeri:', accuracy_score(y_test, ( y_pred&gt;= 0.5)*1))\n\nEğri altı alan değeri: 0.805879217343\nİsabetlilik değeri: 0.901756089666\n\n\nBuraya kadar scikit-learn üzerinde yaptıklarımıza oldukça benzer bir akış izledik. Ancak eğittiğimiz modelin başarısını değerlendirmek için bu amaçla oluşturduğumuz veri kümesini kullanabiliriz. Bu sayede, değerlendirme için kullandığımız veri kümesinde en iyi sonucu verecek iterasyonu (dolayısıyla modeli) kullanabiliriz. Bu özellik, aşırı uyum gibi problemlerin önüne geçebilir.\nBu özelliği kullanmak için iterasyon sayısını arttıralım. Aşağıdaki kodda modelin eğitimini 150 iterasyon boyunca (num_boost_round değeri) sürdürüyoruz. Ancak 25 iterasyon (early_stopping_rounds değeri) boyunca iyileşme sağlayamazsak, modelin eğitilmesini durdurup en iyi sonucu veren iterasyonu kullanacağız. Burada sonuçların bu noktadan sonra tekrar iyileşmeyeceğini varsayıyoruz. Aşırı uyum gibi nedenlerle, bu varsayımın geçerli bir varsayım olduğunu düşünebiliriz.\n\n# Değerlendirme veri kümesini oluşturuyoruz.\nlgb_eval = lgb.Dataset(data=df_test, label=y_test, reference=lgb_train,  free_raw_data=False)\n\n# Eğitim parametrelerini belirleyelim\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'binary',\n    'metric': 'auc',\n    'num_leaves': 31,\n    'learning_rate': 0.05,\n    'verbose': -1\n}\n\nprint('Eğitim...')\n# Modeli eğitelim\n# Bu sefer değerlendirme veri kümesini de tanıtıyoruz.\nevals_result={}\ngbm = lgb.train(params,\n                lgb_train,\n                valid_sets = lgb_eval,\n                categorical_feature = kategorik_indeks,\n                num_boost_round= 150,\n                early_stopping_rounds= 25,\n                evals_result=evals_result)\nprint('Eğitim bitti...')\n\n# Tahmin ve değerlendirme\ny_pred = gbm.predict(df_test, num_iteration=gbm.best_iteration)\n\nprint('En iyi sonucu veren iterasyon: ', gbm.best_iteration)\nprint('Eğri altı alan değeri:', roc_auc_score(y_test, y_pred))\nprint('İsabetlilik değeri:', accuracy_score(y_test, ( y_pred&gt;= 0.5)*1))\n\nEğitim...\n[1] valid_0's auc: 0.78742\nTraining until validation scores don't improve for 25 rounds.\n[2] valid_0's auc: 0.789475\n[3] valid_0's auc: 0.789526\n[4] valid_0's auc: 0.789663\n[5] valid_0's auc: 0.789849\n[6] valid_0's auc: 0.789768\n[7] valid_0's auc: 0.789819\n[8] valid_0's auc: 0.789839\n[9] valid_0's auc: 0.789914\n[10]    valid_0's auc: 0.797747\n[11]    valid_0's auc: 0.797924\n[12]    valid_0's auc: 0.797741\n[13]    valid_0's auc: 0.797905\n[14]    valid_0's auc: 0.797997\n[15]    valid_0's auc: 0.79871\n[16]    valid_0's auc: 0.798828\n[17]    valid_0's auc: 0.799208\n[18]    valid_0's auc: 0.800333\n[19]    valid_0's auc: 0.800382\n[20]    valid_0's auc: 0.800398\n[21]    valid_0's auc: 0.800523\n[22]    valid_0's auc: 0.800968\n[23]    valid_0's auc: 0.80091\n[24]    valid_0's auc: 0.800688\n[25]    valid_0's auc: 0.800484\n[26]    valid_0's auc: 0.80053\n[27]    valid_0's auc: 0.80241\n[28]    valid_0's auc: 0.803091\n[29]    valid_0's auc: 0.803029\n[30]    valid_0's auc: 0.802915\n[31]    valid_0's auc: 0.803011\n[32]    valid_0's auc: 0.802773\n[33]    valid_0's auc: 0.802956\n[34]    valid_0's auc: 0.803421\n[35]    valid_0's auc: 0.803552\n[36]    valid_0's auc: 0.803796\n[37]    valid_0's auc: 0.804098\n[38]    valid_0's auc: 0.804464\n[39]    valid_0's auc: 0.805213\n[40]    valid_0's auc: 0.805624\n[41]    valid_0's auc: 0.805729\n[42]    valid_0's auc: 0.806006\n[43]    valid_0's auc: 0.806238\n[44]    valid_0's auc: 0.806333\n[45]    valid_0's auc: 0.806415\n[46]    valid_0's auc: 0.806387\n[47]    valid_0's auc: 0.806478\n[48]    valid_0's auc: 0.806487\n[49]    valid_0's auc: 0.80655\n[50]    valid_0's auc: 0.806739\n[51]    valid_0's auc: 0.806779\n[52]    valid_0's auc: 0.80684\n[53]    valid_0's auc: 0.806934\n[54]    valid_0's auc: 0.807166\n[55]    valid_0's auc: 0.807061\n[56]    valid_0's auc: 0.806932\n[57]    valid_0's auc: 0.806948\n[58]    valid_0's auc: 0.807069\n[59]    valid_0's auc: 0.807448\n[60]    valid_0's auc: 0.80764\n[61]    valid_0's auc: 0.807637\n[62]    valid_0's auc: 0.807189\n[63]    valid_0's auc: 0.807577\n[64]    valid_0's auc: 0.807447\n[65]    valid_0's auc: 0.807197\n[66]    valid_0's auc: 0.807345\n[67]    valid_0's auc: 0.807731\n[68]    valid_0's auc: 0.80744\n[69]    valid_0's auc: 0.807468\n[70]    valid_0's auc: 0.80767\n[71]    valid_0's auc: 0.80748\n[72]    valid_0's auc: 0.807401\n[73]    valid_0's auc: 0.807318\n[74]    valid_0's auc: 0.807318\n[75]    valid_0's auc: 0.807065\n[76]    valid_0's auc: 0.807099\n[77]    valid_0's auc: 0.807325\n[78]    valid_0's auc: 0.807164\n[79]    valid_0's auc: 0.807235\n[80]    valid_0's auc: 0.807182\n[81]    valid_0's auc: 0.807137\n[82]    valid_0's auc: 0.806981\n[83]    valid_0's auc: 0.806606\n[84]    valid_0's auc: 0.806676\n[85]    valid_0's auc: 0.806778\n[86]    valid_0's auc: 0.806717\n[87]    valid_0's auc: 0.806822\n[88]    valid_0's auc: 0.806925\n[89]    valid_0's auc: 0.806777\n[90]    valid_0's auc: 0.806597\n[91]    valid_0's auc: 0.806535\n[92]    valid_0's auc: 0.806461\nEarly stopping, best iteration is:\n[67]    valid_0's auc: 0.807731\nEğitim bitti...\nEn iyi sonucu veren iterasyon:  67\nEğri altı alan değeri: 0.807731053993\nİsabetlilik değeri: 0.900056648054\n\n\n67 numaralı iterasyonda en iyi sonucu elde ettik. 25 iterasyon boyunca daha iyi bir sonuç elde edemediğimiz için 92 numaralı iterasyondan sonra modeli eğitmeyi durdurduk.\nModelle ilgili çeşitli başarı ölçütlerini ve tahmin amacıyla kullandığımız özniteliklerin önemlerini çizdirmek için de fonksiyonlar içeriyor. plot_metric ile modelde kullandığınız başarı ölçütlerinin grafiğini çizdirmeniz mümkün.\n\nprint('Eğri altı alan...')\nax = lgb.plot_metric(evals_result, metric='auc')\nax.set_title('Eğri Altı Alanın İterasyona Göre Değişimi')\nax.set_xlabel('İterasyon')\nax.set_ylabel('Eğri Altı Alan Değeri')\nax.legend_.remove()\nplt.show()\n\nEğri altı alan...\n\n\n\n\n\nŞekle göre ilk 20 iterasyonda başarının ciddi şekilde arttığı görülüyor. 40 numaralı iterasyondan sonra sonuçlardaki iyileşme daha az. 67 numaralı iterasyondan sonra ise sonuçlar kötüleşmeye başlamış (aşırı uyum).\nscikit-learn üzerinde olduğu gibi LightGBM de özniteliklerin önemini görmemizi sağlayan bir fonksiyon içeriyor. plot_importance ile modelin, istediğiniz sayıda en önemli özniteliğini ağırlıklarıyla birlikte şekle dökebilirsiniz.\nAşağıda 10 öznitelik için (ve en iyi sonucu aldığımız iterasyondaki) önem grafiğini görebiliriz.\n\nax = lgb.plot_importance(gbm, max_num_features=10)\nax.set_title('')\nax.set_xlabel('Özniteliklerin Önemi')\nax.set_ylabel('Öznitelikler')\nplt.show()\n\n\n\n\neuribor_faizi,yaş ve kampanya önemi yüksek, yani kampanyaya cevabı belirleyen, özniteliklerden.\n\n\nEksik veri ile çalışma\nLightGBM, scikit-learn paketinin aksine eksik değerlerle çalışmaya da izin veriyor. Örnek olarak önceki_iletişimden_sonra_geçen_gün değeri 999 olan müşterilerin bu değerini NaN yapalım.\n\n# Veri kümelerinde eksik değerler oluşturuyoruz.\ndf_train['önceki_iletişimden_sonra_geçen_gün'].replace(999, np.nan, inplace = True)\ndf_test['önceki_iletişimden_sonra_geçen_gün'].replace(999, np.nan, inplace = True)\n\nprint(df_train.isnull().sum())\n\nyaş                                       0\niş                                        0\nmedeni_durum                              0\neğitim                                    0\ngecikme                                   0\nev                                        0\nborç                                      0\niletişim                                  0\nay                                        0\nhaftanın_günü                             0\nkampanya                                  0\nönceki_iletişimden_sonra_geçen_gün    27753\niletişim_sayısı                           0\niletişim_sonucu                           0\nişsizlik                                  0\ntüketici_fiyat_endeksi                    0\ntüketici_güven_endeksi                    0\neuribor_faizi                             0\nçalışan_sayısı                            0\ndtype: int64\n\n\nGördüğümüz gibi artık veri setinde eksik değerler de var. Modeli eğitip sonuçları alalım.\n\n# Veri kümesi oluşturalım.\nlgb_train = lgb.Dataset(data=df_train, label=y_train,  free_raw_data=False)\n# Değerlendirme veri kümesini oluşturuyoruz.\nlgb_eval = lgb.Dataset(data=df_test, label=y_test, reference=lgb_train,  free_raw_data=False)\n\n# Eğitim parametrelerini belirleyelim\nparams = {\n    'task': 'train',\n    'boosting_type': 'gbdt',\n    'objective': 'binary',\n    'metric': 'auc',\n    'num_leaves': 31,\n    'learning_rate': 0.05,\n    'verbose': -1\n}\n\nprint('Eğitim...')\n# Modeli eğitelim\nevals_result={}\ngbm = lgb.train(params,\n                lgb_train,\n                valid_sets = lgb_eval,\n                categorical_feature = kategorik_indeks,\n                num_boost_round= 150,\n                early_stopping_rounds= 25,\n                evals_result=evals_result)\nprint('Eğitim bitti...')\n\n# Tahmin ve değerlendirme\ny_pred = gbm.predict(df_test, num_iteration=gbm.best_iteration)\n\nprint('En iyi sonucu veren iterasyon: ', gbm.best_iteration)\nprint('Eğri altı alan değeri:', roc_auc_score(y_test, y_pred))\nprint('İsabetlilik değeri:', accuracy_score(y_test, ( y_pred&gt;= 0.5)*1))\n\nEğitim...\n[1] valid_0's auc: 0.78742\nTraining until validation scores don't improve for 25 rounds.\n[2] valid_0's auc: 0.789475\n[3] valid_0's auc: 0.789526\n[4] valid_0's auc: 0.789663\n[5] valid_0's auc: 0.789849\n[6] valid_0's auc: 0.789768\n[7] valid_0's auc: 0.789819\n[8] valid_0's auc: 0.789839\n[9] valid_0's auc: 0.789914\n[10]    valid_0's auc: 0.797747\n[11]    valid_0's auc: 0.797924\n[12]    valid_0's auc: 0.797677\n[13]    valid_0's auc: 0.798105\n[14]    valid_0's auc: 0.798295\n[15]    valid_0's auc: 0.798434\n[16]    valid_0's auc: 0.799106\n[17]    valid_0's auc: 0.79919\n[18]    valid_0's auc: 0.799513\n[19]    valid_0's auc: 0.800609\n[20]    valid_0's auc: 0.800532\n[21]    valid_0's auc: 0.800621\n[22]    valid_0's auc: 0.801409\n[23]    valid_0's auc: 0.801717\n[24]    valid_0's auc: 0.801748\n[25]    valid_0's auc: 0.801865\n[26]    valid_0's auc: 0.803003\n[27]    valid_0's auc: 0.803296\n[28]    valid_0's auc: 0.803565\n[29]    valid_0's auc: 0.803508\n[30]    valid_0's auc: 0.803256\n[31]    valid_0's auc: 0.803135\n[32]    valid_0's auc: 0.803365\n[33]    valid_0's auc: 0.80334\n[34]    valid_0's auc: 0.803729\n[35]    valid_0's auc: 0.803753\n[36]    valid_0's auc: 0.804338\n[37]    valid_0's auc: 0.804594\n[38]    valid_0's auc: 0.805324\n[39]    valid_0's auc: 0.805672\n[40]    valid_0's auc: 0.806077\n[41]    valid_0's auc: 0.806452\n[42]    valid_0's auc: 0.806624\n[43]    valid_0's auc: 0.806568\n[44]    valid_0's auc: 0.806763\n[45]    valid_0's auc: 0.806802\n[46]    valid_0's auc: 0.806816\n[47]    valid_0's auc: 0.806992\n[48]    valid_0's auc: 0.806969\n[49]    valid_0's auc: 0.806885\n[50]    valid_0's auc: 0.806845\n[51]    valid_0's auc: 0.807258\n[52]    valid_0's auc: 0.807419\n[53]    valid_0's auc: 0.807595\n[54]    valid_0's auc: 0.807708\n[55]    valid_0's auc: 0.807837\n[56]    valid_0's auc: 0.807571\n[57]    valid_0's auc: 0.807663\n[58]    valid_0's auc: 0.808115\n[59]    valid_0's auc: 0.807808\n[60]    valid_0's auc: 0.807867\n[61]    valid_0's auc: 0.808091\n[62]    valid_0's auc: 0.808112\n[63]    valid_0's auc: 0.808062\n[64]    valid_0's auc: 0.807787\n[65]    valid_0's auc: 0.807958\n[66]    valid_0's auc: 0.807626\n[67]    valid_0's auc: 0.807364\n[68]    valid_0's auc: 0.807993\n[69]    valid_0's auc: 0.807935\n[70]    valid_0's auc: 0.807958\n[71]    valid_0's auc: 0.807693\n[72]    valid_0's auc: 0.807753\n[73]    valid_0's auc: 0.807701\n[74]    valid_0's auc: 0.80765\n[75]    valid_0's auc: 0.807728\n[76]    valid_0's auc: 0.807678\n[77]    valid_0's auc: 0.807654\n[78]    valid_0's auc: 0.8077\n[79]    valid_0's auc: 0.807778\n[80]    valid_0's auc: 0.807718\n[81]    valid_0's auc: 0.80772\n[82]    valid_0's auc: 0.807316\n[83]    valid_0's auc: 0.807212\nEarly stopping, best iteration is:\n[58]    valid_0's auc: 0.808115\nEğitim bitti...\nEn iyi sonucu veren iterasyon:  58\nEğri altı alan değeri: 0.808115206918\nİsabetlilik değeri: 0.9005422028\n\n\nGördüğümüz gibi eksik değerlerle yapılan tahminler biraz daha iyi sonuçlar verdi. Ancak her zaman bu şekilde olacağının bir garantisi yok. Hangi modeli kullanacağımızı belirlemek için birden fazla alternatifi çarpraz doğrulama ve istatistik yöntemleriyle test etmemiz gerekecektir.\nLightGBM veri analitiği konusunda kullanabileceğiniz bir çok aracı içeren bir paket. Ancak scikit-learn gibi uçtan uca bir çözüm sunmuyor. Veri işleme ve model sonuçlarını değerlendirme gibi alanlarda scikit-learn altındaki modülleri kullanmak durumunda kaldık. Bu noktada, LightGBM paketinin bir yapay öğrenme kütüphanesi olmadığını ve gradient boosting yöntemine dayanan bir kütüphane olduğunu hatırlatalım.\nBu yazının Jupyter Notebook dosyasına Github dizinimizden erişebilirsiniz."
  },
  {
    "objectID": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html",
    "href": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html",
    "title": "Python Programlamaya Giriş 21 - Dinamik kod üretme",
    "section": "",
    "text": "Python dinamik tabir edilen dillerden biridir. Programda kullandığıız değişkenlerin tiplerini baştan bildirmeniz gerekmez. Program çalıştıkça işlenen komutlar, yeni nesneleri anında üretir. Bu dinamiklik sayesinde, dize olarak verilmiş Python komutlarını da işleyebilir, hatta program yazan programlar yazabiliriz.\nBu işlemi yapmak için iki Python fonksiyonu vardır: eval() ve exec()\nDizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut."
  },
  {
    "objectID": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html#eval",
    "href": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html#eval",
    "title": "Python Programlamaya Giriş 21 - Dinamik kod üretme",
    "section": "eval",
    "text": "eval\nBu fonksiyon, Python komutları içeren bir dizeyi yorumlayıcıya gönderir ve sonucu geri verir.\n\neval(\"2**3 + 4*5\")\n\n28\n\n\nÇalıştırma anında isim alanında bulunan değişkenler de kod dizesi içinde kullanılabilir.\n\nx = 5\neval(\"2*x+4\")\n\n14\n\n\nKomut dizesi içindeki değişkeni başka bir değerle kullanmak isterseniz, değişkenleri bir sözlük ile verebilirsiniz.\n\neval(\"2*x+4\",{\"x\":10})\n\n24\n\n\n\nÖrnek: Basit hesap makinesi.\nKullanıcıdan tek tek matematiksel ifadeler alıp sonucu yazan bir programcık yazalım. Kullanıcı “dur” yazdığında program sona ersin.\n\nişlemler = \"\"\"1 + 2 + 3 + 4 + 5\n2**2 + 3 * 5\n1/10 + 1/5\n\"\"\"\nfor işlem in işlemler.splitlines():\n    print(işlem, \" = \", eval(işlem))\n\n1 + 2 + 3 + 4 + 5  =  15\n2**2 + 3 * 5  =  19\n1/10 + 1/5  =  0.30000000000000004\n\n\n\n\nÖrnek: Yardım belgeleri özetleri\nNesnelerin yardım belgelerini daha önce kullanmıştık. Bir metodla ilgili bilgi almak için help() komutunu kullandığımızda o metodun (bir fonksiyon nesnesidir) __doc__ isimli özelliği ekrana basılır. Buna doğrudan da erişebiliriz.\n\nlist.append.__doc__\n\n'L.append(object) -&gt; None -- append object to end'\n\n\nDiyelim bir nesne sınıfı altında tanımlanmış bütün metodların kısa tarifini (belge dizesini) ekrana dökmek istiyoruz. Ama bir sınıf altında, daha özel amaçlı, doğrudan kullanılmayan metodlar da bulunur. Bunların başlarında ve sonlarında bir çift altçizgi (“dunder”) bulunur.\nÇift altçizgili metodları hariç tutarak, metodların kısa açıklamalarını listelemek için eval’i bir döngü içinde kullanabiliriz.\n\nfor metod in dir(list):\n    if \"__\" not in metod:\n        print(eval(\"list.\"+metod+\".__doc__\"))\n\nL.append(object) -&gt; None -- append object to end\nL.clear() -&gt; None -- remove all items from L\nL.copy() -&gt; list -- a shallow copy of L\nL.count(value) -&gt; integer -- return number of occurrences of value\nL.extend(iterable) -&gt; None -- extend list by appending elements from the iterable\nL.index(value, [start, [stop]]) -&gt; integer -- return first index of value.\nRaises ValueError if the value is not present.\nL.insert(index, object) -- insert object before index\nL.pop([index]) -&gt; item -- remove and return item at index (default last).\nRaises IndexError if list is empty or index is out of range.\nL.remove(value) -&gt; None -- remove first occurrence of value.\nRaises ValueError if the value is not present.\nL.reverse() -- reverse *IN PLACE*\nL.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*"
  },
  {
    "objectID": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html#exec",
    "href": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html#exec",
    "title": "Python Programlamaya Giriş 21 - Dinamik kod üretme",
    "section": "exec",
    "text": "exec\nDeğer döndüren ifadeleri eval() ile işletebiliriz, ama bir ifade (expression) olmayan, yani değer döndürmeyen komutları (söz gelişi, modül yükleme, fonksiyon tanımları, döngüler, atamalar vb.) çalıştırmak için exec() fonksiyonuna ihtiyacımız var.\nÖrnek olarak, bir değişken ataması yapalım:\n\nexec(\"\"\"\nimport math\nx=math.pi\"\"\")\nx\n\n3.141592653589793\n\n\nBir formülde değişkene 0-9 arası değerler vererek bir tablo oluşturan bir kod yazalım.\n\ndeğişken = \"x\"\nformül = \"1/(1+x) + x\"\nkod = \"\"\"\nfor {0} in range(10):\n    print({0}, {1})\"\"\".format(değişken, formül)\nprint(kod)\n\n\nfor x in range(10):\n    print(x, 1/(1+x) + x)\n\n\n\nexec(kod)\n\n0 1.0\n1 1.5\n2 2.3333333333333335\n3 3.25\n4 4.2\n5 5.166666666666667\n6 6.142857142857143\n7 7.125\n8 8.11111111111111\n9 9.1\n\n\nFarkedeceğiniz gibi, değişken’in değeri \"x\" olduğu için formülde de x karakterini kullanmamız gerekiyor."
  },
  {
    "objectID": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html#global-ve-yerel-değişkenler",
    "href": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html#global-ve-yerel-değişkenler",
    "title": "Python Programlamaya Giriş 21 - Dinamik kod üretme",
    "section": "Global ve yerel değişkenler",
    "text": "Global ve yerel değişkenler\neval/exec fonksiyonları, işletilecek kodu barındıran dizenin yanı sıra iki parametre daha alırlar: globals ve locals. Bu parametreler özellikle belirtilmezse, eval/exec kodunda yorumlayıcının o andaki durumunda tanımlanmış olan bütün isimler kullanılabilir.\nYerel değişkenler bir fonksiyon içinden tanımlı olan, o fonksiyonun dışında tanınmayan isimlerdir. Global değişkenler ise bütün fonksiyonların erişebileceği değişkenlerdir. Yerel isimlere locals(), global isimlere ise globals() komutlarıyla ulaşılabilir. Bu komutlar değişken isimleriyle değerlerini eşleştiren birer sözlük döndürür.\n\ndef f(x):\n    a = 10\n    print(locals())\n\nf(3)\n\n{'a': 10, 'x': 3}\n\n\neval/exec ile bir kod parçası çalıştırırken bu global ve yerel değişkenleri sınırlandırabiliriz. Bu fonksiyonların genel kullanımı şöyledir:\neval(source, globals=None, locals=None)\nexec(source, globals=None, locals=None)\nBurada globals ve locals parametreleri için global ve yerel değişkenleri tutan birer sözlük koyabiliriz.\n\nexec(\"print(locals())\", None, {\"abc\": 17, \"xyz\": \"Mehmet\"})\n\n{'abc': 17, 'xyz': 'Mehmet'}\n\n\n\nexec(\"print(globals())\", None, {\"abc\": 17, \"xyz\": \"Mehmet\"})\n\n{'__name__': '__main__', '__doc__': 'Automatically created module for IPython interactive environment', '__package__': None, '__loader__': None, '__spec__': None, '__builtin__': &lt;module 'builtins' (built-in)&gt;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '_ih': ['', 'eval(\"2**3 + 4*5\")', 'x = 5\\neval(\"2*x+4\")', 'eval(\"2*x+4\",{\"x\":10})', 'while(True):\\n    işlem = input(\"Bir işlem yazın: \")\\n    if işlem.strip().lower()==\"dur\": break\\n    print(eval(işlem))', 'list.append.__doc__', 'dir(list)', 'for metod in dir(list):\\n    if \"__\" not in metod:\\n        print(eval(\"list.\"+metod+\".__doc__\"))', 'exec(\"x=3.1415\")\\nx', 'değişken = \"x\" # Formülde kullanılacak değişken.\\nformül = input(\"Bir matematiksel formül yazın: \")\\nkod = \"\"\"\\nfor {0} in range(10):\\n    print({0}, {1})\"\"\".format(değişken, formül)\\nprint(kod)', 'exec(kod)', 'globals()', 'def f(x):\\n    a = 10\\n    print(locals())\\n\\nf(3)', 'exec(\"print(locals())\", None, {\"abc\": 17, \"xyz\": \"Mehmet\"})', 'exec(\"print(globals())\", None, {\"abc\": 17, \"xyz\": \"Mehmet\"})'], '_oh': {1: 28, 2: 14, 3: 24, 5: 'L.append(object) -&gt; None -- append object to end', 6: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'], 8: 3.1415, 11: {...}}, '_dh': ['/home/kaan/git/VeriDefteri/Python_Programlama'], 'In': ['', 'eval(\"2**3 + 4*5\")', 'x = 5\\neval(\"2*x+4\")', 'eval(\"2*x+4\",{\"x\":10})', 'while(True):\\n    işlem = input(\"Bir işlem yazın: \")\\n    if işlem.strip().lower()==\"dur\": break\\n    print(eval(işlem))', 'list.append.__doc__', 'dir(list)', 'for metod in dir(list):\\n    if \"__\" not in metod:\\n        print(eval(\"list.\"+metod+\".__doc__\"))', 'exec(\"x=3.1415\")\\nx', 'değişken = \"x\" # Formülde kullanılacak değişken.\\nformül = input(\"Bir matematiksel formül yazın: \")\\nkod = \"\"\"\\nfor {0} in range(10):\\n    print({0}, {1})\"\"\".format(değişken, formül)\\nprint(kod)', 'exec(kod)', 'globals()', 'def f(x):\\n    a = 10\\n    print(locals())\\n\\nf(3)', 'exec(\"print(locals())\", None, {\"abc\": 17, \"xyz\": \"Mehmet\"})', 'exec(\"print(globals())\", None, {\"abc\": 17, \"xyz\": \"Mehmet\"})'], 'Out': {1: 28, 2: 14, 3: 24, 5: 'L.append(object) -&gt; None -- append object to end', 6: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'], 8: 3.1415, 11: {...}}, 'get_ipython': &lt;bound method InteractiveShell.get_ipython of &lt;ipykernel.zmqshell.ZMQInteractiveShell object at 0x7f9d822f7b70&gt;&gt;, 'exit': &lt;IPython.core.autocall.ZMQExitAutocall object at 0x7f9d80260630&gt;, 'quit': &lt;IPython.core.autocall.ZMQExitAutocall object at 0x7f9d80260630&gt;, '_': {...}, '__': 3.1415, '___': ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'], '_i': 'exec(\"print(locals())\", None, {\"abc\": 17, \"xyz\": \"Mehmet\"})', '_ii': 'def f(x):\\n    a = 10\\n    print(locals())\\n\\nf(3)', '_iii': 'globals()', '_i1': 'eval(\"2**3 + 4*5\")', '_1': 28, '_i2': 'x = 5\\neval(\"2*x+4\")', 'x': 9, '_2': 14, '_i3': 'eval(\"2*x+4\",{\"x\":10})', '_3': 24, '_i4': 'while(True):\\n    işlem = input(\"Bir işlem yazın: \")\\n    if işlem.strip().lower()==\"dur\": break\\n    print(eval(işlem))', 'işlem': 'dur', '_i5': 'list.append.__doc__', '_5': 'L.append(object) -&gt; None -- append object to end', '_i6': 'dir(list)', '_6': ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'], '_i7': 'for metod in dir(list):\\n    if \"__\" not in metod:\\n        print(eval(\"list.\"+metod+\".__doc__\"))', 'metod': 'sort', '_i8': 'exec(\"x=3.1415\")\\nx', '_8': 3.1415, '_i9': 'değişken = \"x\" # Formülde kullanılacak değişken.\\nformül = input(\"Bir matematiksel formül yazın: \")\\nkod = \"\"\"\\nfor {0} in range(10):\\n    print({0}, {1})\"\"\".format(değişken, formül)\\nprint(kod)', 'değişken': 'x', 'formül': '2*x**3-10', 'kod': '\\nfor x in range(10):\\n    print(x, 2*x**3-10)', '_i10': 'exec(kod)', '_i11': 'globals()', '_11': {...}, '_i12': 'def f(x):\\n    a = 10\\n    print(locals())\\n\\nf(3)', 'f': &lt;function f at 0x7f9d80165d08&gt;, '_i13': 'exec(\"print(locals())\", None, {\"abc\": 17, \"xyz\": \"Mehmet\"})', '_i14': 'exec(\"print(globals())\", None, {\"abc\": 17, \"xyz\": \"Mehmet\"})'}\n\n\nglobals yerine boş bir sözlük koyarsak, sadece Python’da tanımlanmış (built-in) isimlere erişilebilir sadece\n\nexec(\"print(globals())\", {}, {\"abc\": 17, \"xyz\": \"Mehmet\"})\n\n{'__builtins__': {'__name__': 'builtins', '__doc__': \"Built-in functions, exceptions, and other objects.\\n\\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.\", '__package__': '', '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': ModuleSpec(name='builtins', loader=&lt;class '_frozen_importlib.BuiltinImporter'&gt;), '__build_class__': &lt;built-in function __build_class__&gt;, '__import__': &lt;built-in function __import__&gt;, 'abs': &lt;built-in function abs&gt;, 'all': &lt;built-in function all&gt;, 'any': &lt;built-in function any&gt;, 'ascii': &lt;built-in function ascii&gt;, 'bin': &lt;built-in function bin&gt;, 'callable': &lt;built-in function callable&gt;, 'chr': &lt;built-in function chr&gt;, 'compile': &lt;built-in function compile&gt;, 'delattr': &lt;built-in function delattr&gt;, 'dir': &lt;built-in function dir&gt;, 'divmod': &lt;built-in function divmod&gt;, 'eval': &lt;built-in function eval&gt;, 'exec': &lt;built-in function exec&gt;, 'format': &lt;built-in function format&gt;, 'getattr': &lt;built-in function getattr&gt;, 'globals': &lt;built-in function globals&gt;, 'hasattr': &lt;built-in function hasattr&gt;, 'hash': &lt;built-in function hash&gt;, 'hex': &lt;built-in function hex&gt;, 'id': &lt;built-in function id&gt;, 'input': &lt;bound method Kernel.raw_input of &lt;ipykernel.ipkernel.IPythonKernel object at 0x7f9d822f7f28&gt;&gt;, 'isinstance': &lt;built-in function isinstance&gt;, 'issubclass': &lt;built-in function issubclass&gt;, 'iter': &lt;built-in function iter&gt;, 'len': &lt;built-in function len&gt;, 'locals': &lt;built-in function locals&gt;, 'max': &lt;built-in function max&gt;, 'min': &lt;built-in function min&gt;, 'next': &lt;built-in function next&gt;, 'oct': &lt;built-in function oct&gt;, 'ord': &lt;built-in function ord&gt;, 'pow': &lt;built-in function pow&gt;, 'print': &lt;built-in function print&gt;, 'repr': &lt;built-in function repr&gt;, 'round': &lt;built-in function round&gt;, 'setattr': &lt;built-in function setattr&gt;, 'sorted': &lt;built-in function sorted&gt;, 'sum': &lt;built-in function sum&gt;, 'vars': &lt;built-in function vars&gt;, 'None': None, 'Ellipsis': Ellipsis, 'NotImplemented': NotImplemented, 'False': False, 'True': True, 'bool': &lt;class 'bool'&gt;, 'memoryview': &lt;class 'memoryview'&gt;, 'bytearray': &lt;class 'bytearray'&gt;, 'bytes': &lt;class 'bytes'&gt;, 'classmethod': &lt;class 'classmethod'&gt;, 'complex': &lt;class 'complex'&gt;, 'dict': &lt;class 'dict'&gt;, 'enumerate': &lt;class 'enumerate'&gt;, 'filter': &lt;class 'filter'&gt;, 'float': &lt;class 'float'&gt;, 'frozenset': &lt;class 'frozenset'&gt;, 'property': &lt;class 'property'&gt;, 'int': &lt;class 'int'&gt;, 'list': &lt;class 'list'&gt;, 'map': &lt;class 'map'&gt;, 'object': &lt;class 'object'&gt;, 'range': &lt;class 'range'&gt;, 'reversed': &lt;class 'reversed'&gt;, 'set': &lt;class 'set'&gt;, 'slice': &lt;class 'slice'&gt;, 'staticmethod': &lt;class 'staticmethod'&gt;, 'str': &lt;class 'str'&gt;, 'super': &lt;class 'super'&gt;, 'tuple': &lt;class 'tuple'&gt;, 'type': &lt;class 'type'&gt;, 'zip': &lt;class 'zip'&gt;, '__debug__': True, 'BaseException': &lt;class 'BaseException'&gt;, 'Exception': &lt;class 'Exception'&gt;, 'TypeError': &lt;class 'TypeError'&gt;, 'StopAsyncIteration': &lt;class 'StopAsyncIteration'&gt;, 'StopIteration': &lt;class 'StopIteration'&gt;, 'GeneratorExit': &lt;class 'GeneratorExit'&gt;, 'SystemExit': &lt;class 'SystemExit'&gt;, 'KeyboardInterrupt': &lt;class 'KeyboardInterrupt'&gt;, 'ImportError': &lt;class 'ImportError'&gt;, 'ModuleNotFoundError': &lt;class 'ModuleNotFoundError'&gt;, 'OSError': &lt;class 'OSError'&gt;, 'EnvironmentError': &lt;class 'OSError'&gt;, 'IOError': &lt;class 'OSError'&gt;, 'EOFError': &lt;class 'EOFError'&gt;, 'RuntimeError': &lt;class 'RuntimeError'&gt;, 'RecursionError': &lt;class 'RecursionError'&gt;, 'NotImplementedError': &lt;class 'NotImplementedError'&gt;, 'NameError': &lt;class 'NameError'&gt;, 'UnboundLocalError': &lt;class 'UnboundLocalError'&gt;, 'AttributeError': &lt;class 'AttributeError'&gt;, 'SyntaxError': &lt;class 'SyntaxError'&gt;, 'IndentationError': &lt;class 'IndentationError'&gt;, 'TabError': &lt;class 'TabError'&gt;, 'LookupError': &lt;class 'LookupError'&gt;, 'IndexError': &lt;class 'IndexError'&gt;, 'KeyError': &lt;class 'KeyError'&gt;, 'ValueError': &lt;class 'ValueError'&gt;, 'UnicodeError': &lt;class 'UnicodeError'&gt;, 'UnicodeEncodeError': &lt;class 'UnicodeEncodeError'&gt;, 'UnicodeDecodeError': &lt;class 'UnicodeDecodeError'&gt;, 'UnicodeTranslateError': &lt;class 'UnicodeTranslateError'&gt;, 'AssertionError': &lt;class 'AssertionError'&gt;, 'ArithmeticError': &lt;class 'ArithmeticError'&gt;, 'FloatingPointError': &lt;class 'FloatingPointError'&gt;, 'OverflowError': &lt;class 'OverflowError'&gt;, 'ZeroDivisionError': &lt;class 'ZeroDivisionError'&gt;, 'SystemError': &lt;class 'SystemError'&gt;, 'ReferenceError': &lt;class 'ReferenceError'&gt;, 'BufferError': &lt;class 'BufferError'&gt;, 'MemoryError': &lt;class 'MemoryError'&gt;, 'Warning': &lt;class 'Warning'&gt;, 'UserWarning': &lt;class 'UserWarning'&gt;, 'DeprecationWarning': &lt;class 'DeprecationWarning'&gt;, 'PendingDeprecationWarning': &lt;class 'PendingDeprecationWarning'&gt;, 'SyntaxWarning': &lt;class 'SyntaxWarning'&gt;, 'RuntimeWarning': &lt;class 'RuntimeWarning'&gt;, 'FutureWarning': &lt;class 'FutureWarning'&gt;, 'ImportWarning': &lt;class 'ImportWarning'&gt;, 'UnicodeWarning': &lt;class 'UnicodeWarning'&gt;, 'BytesWarning': &lt;class 'BytesWarning'&gt;, 'ResourceWarning': &lt;class 'ResourceWarning'&gt;, 'ConnectionError': &lt;class 'ConnectionError'&gt;, 'BlockingIOError': &lt;class 'BlockingIOError'&gt;, 'BrokenPipeError': &lt;class 'BrokenPipeError'&gt;, 'ChildProcessError': &lt;class 'ChildProcessError'&gt;, 'ConnectionAbortedError': &lt;class 'ConnectionAbortedError'&gt;, 'ConnectionRefusedError': &lt;class 'ConnectionRefusedError'&gt;, 'ConnectionResetError': &lt;class 'ConnectionResetError'&gt;, 'FileExistsError': &lt;class 'FileExistsError'&gt;, 'FileNotFoundError': &lt;class 'FileNotFoundError'&gt;, 'IsADirectoryError': &lt;class 'IsADirectoryError'&gt;, 'NotADirectoryError': &lt;class 'NotADirectoryError'&gt;, 'InterruptedError': &lt;class 'InterruptedError'&gt;, 'PermissionError': &lt;class 'PermissionError'&gt;, 'ProcessLookupError': &lt;class 'ProcessLookupError'&gt;, 'TimeoutError': &lt;class 'TimeoutError'&gt;, 'open': &lt;built-in function open&gt;, 'copyright': Copyright (c) 2001-2017 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved., 'credits':     Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands\n    for supporting Python development.  See www.python.org for more information., 'license': Type license() to see the full license text, 'help': Type help() for interactive help, or help(object) for help about object., '__IPYTHON__': True, 'display': &lt;function display at 0x7f9d893481e0&gt;, 'get_ipython': &lt;bound method InteractiveShell.get_ipython of &lt;ipykernel.zmqshell.ZMQInteractiveShell object at 0x7f9d822f7b70&gt;&gt;}}\n\n\nBunlara bile erişimi kapatmamız mümkündür, aşağıdaki bölümde göreceğimiz gibi."
  },
  {
    "objectID": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html#güvenlik",
    "href": "posts/2018/06/08/python-programlamaya-giris-21-dinamik-kod-uretme/Dinamik kod üretme.html#güvenlik",
    "title": "Python Programlamaya Giriş 21 - Dinamik kod üretme",
    "section": "Güvenlik",
    "text": "Güvenlik\nDışarıdan alınan bir kodu çalıştırmak her zaman risklidir. exec() ve eval() fonksiyonlarının bilgisayarınıza bir kapı açtığını unutmayın.\nTehlikeyi örneklemek için, yukarıdaki örneği tekrar ele alalım. Siz bir formül beklerken, kötü niyetli bir kullanıcı işletim sisteminizi yönetecek bir komutu bu formülle beraber verebilir. Meselâ, formül sorulduğunda\n'x); import os; os.system(\"touch hello.world\");(0,\ndizesinin verildiğini varsayalım.\n\ndeğişken = \"x\" # Formülde kullanılacak değişken.\nformül = 'x); import os; os.system(\"touch hello.world\");(0,'\nkod = \"\"\"\nfor {0} in range(10):\n    print({0}, {1})\"\"\".format(değişken, formül)\n\nBu girdi sonucunda çalıştırılacak kod şöyle olur:\n\nprint(kod)\n\n\nfor x in range(10):\n    print(x, x); import os; os.system(\"touch hello.world\");(0,)\n\n\nBurada kötü niyetli kullanıcı beklenen formülü verdikten sonra parantezi kapatmış ve işletim sistemine yönelik komutlar eklemiş. (Sondaki (0, kısmı, kalıpta bulunan sağ parantezin sentaks hatası vermemesi için, onu etkisiz eleman haline dönüştürüyor.)\nBu kodu exec(kod) ile çalıştırdığınızda ekrana sayılar tablosu çıkmasının yanı sıra, bu programı çalıştırdığınız dizinin altında hello.world isimli boş bir dosya yaratıldığını göreceksiniz (Linux kullanıyorsanız). Yani program işletim sisteminize erişebildi. Kötü niyetli bir saldırgan aynı yöntemle diskinizi silebilir, şifrelerinizi çalabilir, virüs yerleştirebilir.\nBu risklere karşı alınabilecek kısmi tedbirler vardır. En yaygın olanı, exec’in çalıştığı sanal ortamdaki değişkenleri, globals ve locals parametreleri kullanarak düzenlemektir. Sözgelişi aşağıda, globals parametresi olarak {\"__builtins__\":None} vermekle Python’un öntanımlı fonksiyonlarını kapatırız. Böylelikle import ile bir modül yüklenmesini ve işletim sistemine ulaşılmasını engelleriz. Bu işlem range ve print fonksiyonlarını da kapatır, o yüzden locals parametresine bunların tanımlarını içeren bir sözlük veririz.\n\nexec(kod, {\"__builtins__\":None}, {\"range\":range, \"print\":print})\n\n0 0\n\n\nImportError: __import__ not found\n\n\nBu yeni düzende import fonksiyonu tanınmadığı için exec() çağrısı bir hata verdi ve sızma engellendi. Aynı kodu beklenen şekilde bir girdiyle çalıştırdığınızda ise sorun yaşamazsınız.\nMatematik kütüphanesindeki fonksiyonları kullanan işlemler yapmak istiyorsanız, gereken fonksiyonlardan oluşan bir “beyaz liste” oluşturabilirsiniz.\n\ndeğişken = \"x\" # Formülde kullanılacak değişken.\nformül = \"x * sqrt(x+1)/log(x+2)\"\nkod = \"\"\"\nfor {0} in range(10):\n    print({0}, {1})\"\"\".format(değişken, formül)\n\n\nimport math\nexec(kod, {\"__builtins__\":None}, {\"range\":range, \"print\":print, \"sqrt\":math.sqrt, \"log\":math.log})\n\n0 0.0\n1 1.2872726592996706\n2 2.4988211106473432\n3 3.728009607357671\n4 4.991893199734352\n5 6.293943592339911\n6 7.6340245917967176\n7 9.010908615097694\n8 10.423067565678043\n9 11.868949934707404\n\n\nKendi kullanacağınız programlar veya bir masaüstü uygulaması için fazla endişe etmek gerekmeyebilir. Yanlış veya kötü niyetli bir kullanım sadece kullanıcıya zarar verecektir. Ama bir web uygulaması yazıyorsanız güvenliğe çok daha fazla dikkat etmelisiniz. Bu, daha derin bir uzmanlık gerektirir.\n\nÖzetle, dinamik olarak üretilen bir kodu işletmek için exec/eval kullanabilirsiniz. Bunun yararlı olduğu çeşitli durumlar vardır. Söz gelişi, Python sentaksıyla yazılmış bir dizeyi doğrudan alıp işletmek gibi.\nexec/eval ilk bakışta çok hoş görünseler de çok sık kullanılmamalıdırlar, bazı sakıncaları vardır.\n\nKodu okumayı zorlaştırır. Programcı kaynak koduna ek olarak, çalıştırılmak üzere alınacak kodun ne olduğunu da bilmelidir.\nKodu test etmeyi, hataları bulmayı zorlaştırır.\nGüvenlik açığı oluşturur.\n\nexec/eval fonksiyonlarının işe yaradığı durumlar vardır, ama probleminizi önce başka yaklaşımlarla çözmeye çalışın."
  },
  {
    "objectID": "posts/2018/03/22/weather-underground-api/index.html",
    "href": "posts/2018/03/22/weather-underground-api/index.html",
    "title": "Weather Underground API",
    "section": "",
    "text": "Weather Underground API\nÖnceki yazılarımızda Star Wars ve FourSquare için uygulama ara yüzlerini (API, Application Programming Interface) kullanmayı görmüştük. API’ları kullanarak çeşitli kaynaktan verilere erişmek, bu verilerle uygulama geliştirmek mümkün. Özellikle hava durumu, sosyal medya ya da demografik veriler gibi kaynaklar, modellerinizde sadece iç kaynaklı verilerle açıklayamayacağınız değişiklikleri anlamanızı sağlayabileceği için yararlı.\nBu yazıda da hava durumu ile ilgili hizmetler sunan Weather Underground sitesinin API’ını kullanmayı öğreneceğiz. Hava durumunun satışlar ve ruh hali üzerine etkilerini araştıran bir çok makale var. Weather Underground, güncel hava durumunun yanında 3 ve 10 günlük tahminler ve (kısıtlı da olsa) geçmiş hava durumu verisine de sahip.\nWeather Underground API’ını kullanmak için web sayfasından bir kullanıcı oluşturmak yeterli. Ancak ücretsiz olan Developer tipi hesap için günlük limit 500 sorgu, dakikalık limit ise 10 sorgu. Sorgu limitini arttırmak için ödeme yaparak farklı statüdeki kullanıcı hesapları alabilirsiniz.\nAPI bir çok programlama diliyle kullanılabiliyor. API dokümantasyonu çok açıklayıcı değil ancak Twitter ve Foursquare gibi API’ların aksine güçlü bir destek hizmetleri var ve sorularınız için kullanıcı forumlarını kullanabilirsiniz.\nPlanlar ve kullanıcı limitlerini aşağıda görebilirsiniz.\n\nfrom IPython.display import Image\nImage('WU_API.png')\n\n\n\n\nKullanıcınızı oluşturduktan sonra Weather Underground size bir kullanıcı anahtarı (key) sağlıyor. Bu anahtarı sorgu adreslerine eklemeniz gerekecek.\nİlk olarak, gerekli kütüphaneleri yükleyelim. Bu kütüphaneler API sorgusunun cevabını almak ve veriyi JSON formatına çevirmek için gerekli.\n\nimport urllib.request as request\nimport json\n\n\n\nHava Durumu\nKullanıcı oluşturduktan sonra API anahtarını ve lokasyonu kullanarak ilk sorgumuzu yapalım. Veri formatı JSON, verideki anahtarları öğrenmek için dokümantasyonu kullanabilirsiniz.\nİlk sorguyu içeren aşağıdaki adreste\n\n‘xxxx’ benim gizlediğim anahtarımı,\nconditions yaptığımız sorgu tipini (farklı sorgu tipleri de göreceğiz),\nTurkey/İstanbul da sorgulamak istediğimiz yeri belirtiyor.\n\nKısaca sorgu, İstanbul’un güncel hava durumunu sorguluyor. Sorgunun sonuna json şeklinde uzantı da eklememiz gerekiyor.\n\n# xxxx yerine kendi anahtarınızı girmeniz gerekiyor.\nf = request.urlopen('http://api.wunderground.com/api/xxxx/conditions/q/Turkey/Istanbul.json')\n\n# Aldığımız yanıtı JSON formatına çevirip, formatlıyoruz.\njson_string = f.read()\nparsed_json = json.loads(json_string)\nprint(json.dumps(parsed_json, indent = 4))\nf.close()\n\n{\n    \"response\": {\n        \"version\": \"0.1\",\n        \"termsofService\": \"http://www.wunderground.com/weather/api/d/terms.html\",\n        \"features\": {\n            \"conditions\": 1\n        }\n    },\n    \"current_observation\": {\n        \"image\": {\n            \"url\": \"http://icons.wxug.com/graphics/wu2/logo_130x80.png\",\n            \"title\": \"Weather Underground\",\n            \"link\": \"http://www.wunderground.com\"\n        },\n        \"display_location\": {\n            \"full\": \"Istanbul, Turkey\",\n            \"city\": \"Istanbul\",\n            \"state\": \"34\",\n            \"state_name\": \"Turkey\",\n            \"country\": \"TU\",\n            \"country_iso3166\": \"TR\",\n            \"zip\": \"00000\",\n            \"magic\": \"124\",\n            \"wmo\": \"17060\",\n            \"latitude\": \"41.00999832\",\n            \"longitude\": \"28.95000076\",\n            \"elevation\": \"28.0\"\n        },\n        \"observation_location\": {\n            \"full\": \"Cihann\\u00fcma, Be\\u015fikta\\u015f, \",\n            \"city\": \"Cihann\\u00fcma, Be\\u015fikta\\u015f\",\n            \"state\": \"\",\n            \"country\": \"TR\",\n            \"country_iso3166\": \"TR\",\n            \"latitude\": \"41.047535\",\n            \"longitude\": \"29.006390\",\n            \"elevation\": \"240 ft\"\n        },\n        \"estimated\": {},\n        \"station_id\": \"IBEIKTA6\",\n        \"observation_time\": \"Last Updated on March 20, 8:42 AM +03\",\n        \"observation_time_rfc822\": \"Tue, 20 Mar 2018 08:42:52 +0300\",\n        \"observation_epoch\": \"1521524572\",\n        \"local_time_rfc822\": \"Tue, 20 Mar 2018 08:43:43 +0300\",\n        \"local_epoch\": \"1521524623\",\n        \"local_tz_short\": \"+03\",\n        \"local_tz_long\": \"Europe/Istanbul\",\n        \"local_tz_offset\": \"+0300\",\n        \"weather\": \"Mostly Cloudy\",\n        \"temperature_string\": \"53.4 F (11.9 C)\",\n        \"temp_f\": 53.4,\n        \"temp_c\": 11.9,\n        \"relative_humidity\": \"81%\",\n        \"wind_string\": \"Calm\",\n        \"wind_dir\": \"WNW\",\n        \"wind_degrees\": 293,\n        \"wind_mph\": 0.0,\n        \"wind_gust_mph\": 0,\n        \"wind_kph\": 0,\n        \"wind_gust_kph\": 0,\n        \"pressure_mb\": \"1002\",\n        \"pressure_in\": \"29.59\",\n        \"pressure_trend\": \"-\",\n        \"dewpoint_string\": \"48 F (9 C)\",\n        \"dewpoint_f\": 48,\n        \"dewpoint_c\": 9,\n        \"heat_index_string\": \"NA\",\n        \"heat_index_f\": \"NA\",\n        \"heat_index_c\": \"NA\",\n        \"windchill_string\": \"NA\",\n        \"windchill_f\": \"NA\",\n        \"windchill_c\": \"NA\",\n        \"feelslike_string\": \"53.4 F (11.9 C)\",\n        \"feelslike_f\": \"53.4\",\n        \"feelslike_c\": \"11.9\",\n        \"visibility_mi\": \"6.0\",\n        \"visibility_km\": \"10.0\",\n        \"solarradiation\": \"--\",\n        \"UV\": \"-1\",\n        \"precip_1hr_string\": \"0.00 in ( 0 mm)\",\n        \"precip_1hr_in\": \"0.00\",\n        \"precip_1hr_metric\": \" 0\",\n        \"precip_today_string\": \"0.00 in (0 mm)\",\n        \"precip_today_in\": \"0.00\",\n        \"precip_today_metric\": \"0\",\n        \"icon\": \"mostlycloudy\",\n        \"icon_url\": \"http://icons.wxug.com/i/c/k/mostlycloudy.gif\",\n        \"forecast_url\": \"http://www.wunderground.com/global/stations/17060.html\",\n        \"history_url\": \"http://www.wunderground.com/weatherstation/WXDailyHistory.asp?ID=IBEIKTA6\",\n        \"ob_url\": \"http://www.wunderground.com/cgi-bin/findweather/getForecast?query=41.047535,29.006390\",\n        \"nowcast\": \"\"\n    }\n}\n\n\nDöndürülen veride aşağıdaki kalemler var:\n\nresponse: Döndürülen cevabın durumunu burada bulabilirsiniz. Alacağınız hataları buradan kontrol edebilirsiniz.\ncurrent_observation şu anki hava durumu altında aşağıdaki bilgiler var:\n\ndisplay_location ve observation_location hava durumu sorgusunun yapıldığı ve ölçümün alındığı yerin bilgilerini içeriyor.\nSıcaklık, nem, rüzgar, basınç, buğulanma sıcaklığı, görüş, radyasyon, UV, yağış gibi hava durumu bilgileri de veriliyor.\n\n\n\n\nTahmin / 10 Günlük Tahmin\nHava durumu tahminlerine forecast sorgusuyla erişebiliriz. forecast yarım günlük tahminler şeklinde önümüzdeki üç günü tahmin ediyor. Daha uzun süreli tahmin için ise forecast10day sorgusunu kullanabilirsiniz. Hava durumu tahmini aynı zamanda simpleforecast anahtarının altında da bulunmakta. Buradaki veriler tablo formatına daha yakın.\n\nf = request.urlopen('http://api.wunderground.com/api/xxxx/forecast/q/Turkey/Istanbul.json')\n\njson_string = f.read()\nparsed_json = json.loads(json_string)\nprint('Metin halindeki hava durumu tahmini')\nprint(json.dumps(parsed_json['forecast']['txt_forecast']['forecastday'][3], indent = 4))\n\nMetin halindeki hava durumu tahmini\n{\n    \"period\": 3,\n    \"icon\": \"nt_chancerain\",\n    \"icon_url\": \"http://icons.wxug.com/i/c/k/nt_chancerain.gif\",\n    \"title\": \"Wednesday Night\",\n    \"fcttext\": \"Partly cloudy skies early followed by increasing clouds with showers developing later at night. Low 47F. SW winds shifting to N at 10 to 15 mph. Chance of rain 40%.\",\n    \"fcttext_metric\": \"Partly cloudy skies early followed by increasing clouds with showers developing later at night. Low 8C. SW winds shifting to N at 15 to 25 km/h. Chance of rain 40%.\",\n    \"pop\": \"40\"\n}\n\n\nŞimdi bir de simpleforecast altındaki tahmine bakalım. Göreceğiniz gibi tahmin sıcaklık, yağış, rüzgar gibi konularda çeşitli veriler içeriyor.\n\nprint('Rakamlarla hava durumu tahmini')\nprint(json.dumps(parsed_json['forecast']['simpleforecast']['forecastday'][0], indent = 4))\n\nf.close()\n\nRakamlarla hava durumu tahmini\n{\n    \"date\": {\n        \"epoch\": \"1521561600\",\n        \"pretty\": \"7:00 PM +03 on March 20, 2018\",\n        \"day\": 20,\n        \"month\": 3,\n        \"year\": 2018,\n        \"yday\": 78,\n        \"hour\": 19,\n        \"min\": \"00\",\n        \"sec\": 0,\n        \"isdst\": \"0\",\n        \"monthname\": \"March\",\n        \"monthname_short\": \"Mar\",\n        \"weekday_short\": \"Tue\",\n        \"weekday\": \"Tuesday\",\n        \"ampm\": \"PM\",\n        \"tz_short\": \"+03\",\n        \"tz_long\": \"Europe/Istanbul\"\n    },\n    \"period\": 1,\n    \"high\": {\n        \"fahrenheit\": \"59\",\n        \"celsius\": \"15\"\n    },\n    \"low\": {\n        \"fahrenheit\": \"50\",\n        \"celsius\": \"10\"\n    },\n    \"conditions\": \"Chance of Rain\",\n    \"icon\": \"chancerain\",\n    \"icon_url\": \"http://icons.wxug.com/i/c/k/chancerain.gif\",\n    \"skyicon\": \"\",\n    \"pop\": 30,\n    \"qpf_allday\": {\n        \"in\": 0.0,\n        \"mm\": 0\n    },\n    \"qpf_day\": {\n        \"in\": 0.0,\n        \"mm\": 0\n    },\n    \"qpf_night\": {\n        \"in\": 0.0,\n        \"mm\": 0\n    },\n    \"snow_allday\": {\n        \"in\": 0.0,\n        \"cm\": 0.0\n    },\n    \"snow_day\": {\n        \"in\": 0.0,\n        \"cm\": 0.0\n    },\n    \"snow_night\": {\n        \"in\": 0.0,\n        \"cm\": 0.0\n    },\n    \"maxwind\": {\n        \"mph\": 30,\n        \"kph\": 48,\n        \"dir\": \"WSW\",\n        \"degrees\": 245\n    },\n    \"avewind\": {\n        \"mph\": 21,\n        \"kph\": 34,\n        \"dir\": \"WSW\",\n        \"degrees\": 245\n    },\n    \"avehumidity\": 63,\n    \"maxhumidity\": 0,\n    \"minhumidity\": 0\n}\n\n\n\n\nGeçmiş Hava Durumu Verisi\nGeçmiş dataya history sorgusu ile erişmek mümkün. Örnek olarak Ataşehir’e yakın bir istasyonun verisini çekebiliriz. Bunun için iki parametreye ihtiyacımız var:\n\nÖlçümün yapıldığı yer bilgisi olarak kullanacağımız pws’nin (private weather station, kişisel ölçüm istasyonu) kodu (pws:IISTANBU81),\nTarih bilgisi. Tarih bilgisini url’ye eklememiz gerekecek. 31 Aralık 2017 tarihindeki hava durumuna erişmek için sorgumuzda history_20171231 değerini kullanacağız.\n\nAşağıdaki sorgu o gün içindeki gözlemleri döndürüyor. Saat saat hava durumunu elde etsek de, yağış gibi veriler geçmiş veri kümelerinde bulunmuyor. Veri kümesi saat saat yapılan bütün gözlemleri içerdiğinden sadece ilk gözleme bakalım.\n\nf = request.urlopen('http://api.wunderground.com/api/xxxx/history_20171231/q/pws:IISTANBU81.json')\n\njson_string = f.read()\nparsed_json = json.loads(json_string)\nprint(json.dumps(parsed_json['history']['observations'][0], indent = 4))\nf.close()\n\n{\n    \"date\": {\n        \"pretty\": \"12:07 AM +03 on December 31, 2017\",\n        \"year\": \"2017\",\n        \"mon\": \"12\",\n        \"mday\": \"31\",\n        \"hour\": \"00\",\n        \"min\": \"07\",\n        \"tzname\": \"Europe/Istanbul\"\n    },\n    \"utcdate\": {\n        \"pretty\": \"9:07 PM GMT on December 30, 2017\",\n        \"year\": \"2017\",\n        \"mon\": \"12\",\n        \"mday\": \"30\",\n        \"hour\": \"21\",\n        \"min\": \"07\",\n        \"tzname\": \"UTC\"\n    },\n    \"tempm\": \"9.3\",\n    \"tempi\": \"48.7\",\n    \"dewptm\": \"5.5\",\n    \"dewpti\": \"41.9\",\n    \"hum\": \"77\",\n    \"wspdm\": \"-1608.8\",\n    \"wspdi\": \"-999.9\",\n    \"wgustm\": \"-1607.4\",\n    \"wgusti\": \"-999.0\",\n    \"wdird\": \"-9999\",\n    \"wdire\": \"North\",\n    \"pressurem\": \"1025.6\",\n    \"pressurei\": \"30.29\",\n    \"windchillm\": \"-999\",\n    \"windchilli\": \"-999\",\n    \"heatindexm\": \"-9999\",\n    \"heatindexi\": \"-9999\",\n    \"precip_ratem\": \"-2539.7\",\n    \"precip_ratei\": \"-99.99\",\n    \"precip_totalm\": \"-2539.7\",\n    \"precip_totali\": \"-99.99\",\n    \"solarradiation\": \"\",\n    \"UV\": \"\",\n    \"softwaretype\": \"Netatmo\"\n}\n\n\nGözlem yerel saatle 00:07’de yapılmış. Yağış ve rüzgarla ilgili kimi kalemler veri de yer alsa da (precip_ratem gibi) gözlem değerleri anlamlı durmuyor.\nBelki ücretli planlarla detaylı geçmiş veriye ulaşmak mümkündür.\n\n\nDiğer Sorgular\nWeather Underground API’ını kullanarak hourly ve hourly10day sorgularıyla saatlik tahminlere, geolookup ile istediğiniz yere yakın istasyonlara, currenthurricane sorgusuyla fırtına bilgilerine, tide sorgusuyla gelgit bilgilerine ve webcams sorgusuyla istasyonların kamera görüntülerine ulaşmanız mümkün.\nSaatlik hava durumu tahminiyle (hourly) bir sonraki saate bakalım.\n\nf = request.urlopen('http://api.wunderground.com/api/xxxx/hourly/q/pws:IISTANBU81.json')\n\njson_string = f.read()\nparsed_json = json.loads(json_string)\nprint('Tahmin zamanı')\nprint(json.dumps(parsed_json['hourly_forecast'][0]['FCTTIME']['pretty'], indent = 4))\n\nzaman = parsed_json['hourly_forecast'][0]['FCTTIME']['pretty']\nprint('{} için sıcaklık'.format(zaman))\nprint(json.dumps(parsed_json['hourly_forecast'][0]['temp'], indent = 4))\nprint('{} için rüzgar hızı'.format(zaman))\nprint(json.dumps(parsed_json['hourly_forecast'][0]['wspd'], indent = 4))\nprint('{} için rüzgar yönü'.format(zaman))\nprint(json.dumps(parsed_json['hourly_forecast'][0]['wdir'], indent = 4))\nf.close()\n\nTahmin zamanı\n\"9:00 AM +03 on March 20, 2018\"\n9:00 AM +03 on March 20, 2018 için sıcaklık\n{\n    \"english\": \"56\",\n    \"metric\": \"13\"\n}\n9:00 AM +03 on March 20, 2018 için rüzgar hızı\n{\n    \"english\": \"18\",\n    \"metric\": \"29\"\n}\n9:00 AM +03 on March 20, 2018 için rüzgar yönü\n{\n    \"dir\": \"SW\",\n    \"degrees\": \"229\"\n}\n\n\nKadıköy’e yakın kişisel hava durumu istasyonlarını (personal weather station, pws) görelim. Kadıköy’ün koordinatı olarak 40.992756, 29.024704 değerlerini alabiliriz.\n\nf = request.urlopen('http://api.wunderground.com/api/xxxx/geolookup/q/40.992756,29.024704.json')\n\njson_string = f.read()\nparsed_json = json.loads(json_string)\nprint(json.dumps(parsed_json['location']['nearby_weather_stations']['pws'], indent = 4))\nf.close()\n\n{\n    \"station\": [\n        {\n            \"neighborhood\": \"\\u00d6zel Saint-Joseph Frans\\u0131z Lisesi\",\n            \"city\": \"Kad\\u0131k\\u00f6y\",\n            \"state\": \"\",\n            \"country\": \"TR\",\n            \"id\": \"IKADKY6\",\n            \"lat\": 40.982716,\n            \"lon\": 29.028534,\n            \"distance_km\": 1,\n            \"distance_mi\": 0\n        },\n        {\n            \"neighborhood\": \"Yigit - Kalamis Residence Weather Station\",\n            \"city\": \"Kad\\u0131k\\u00f6y\",\n            \"state\": \"\",\n            \"country\": \"TR\",\n            \"id\": \"IKADKY4\",\n            \"lat\": 40.985214,\n            \"lon\": 29.036858,\n            \"distance_km\": 1,\n            \"distance_mi\": 0\n        },\n        {\n            \"neighborhood\": \"Suadiye\",\n            \"city\": \"\\u0130stanbul\",\n            \"state\": \"\\u0130STANBUL\",\n            \"country\": \"TR\",\n            \"id\": \"ISTANBUL189\",\n            \"lat\": 40.962555,\n            \"lon\": 29.076281,\n            \"distance_km\": 5,\n            \"distance_mi\": 3\n        },\n        {\n            \"neighborhood\": \"Cihann\\u00fcma\",\n            \"city\": \"Be\\u015fikta\\u015f\",\n            \"state\": \"\",\n            \"country\": \"TR\",\n            \"id\": \"IBEIKTA6\",\n            \"lat\": 41.047535,\n            \"lon\": 29.00639,\n            \"distance_km\": 6,\n            \"distance_mi\": 3\n        }\n    ]\n}\n\n\n1 ile 6 km mesafede dört istasyon olduğunu görüyoruz. İstasyonların id değerlerini başka sorgular için kullanmanız mümkün.\nBu yazının Jupyter Notebook dosyasına GitHub dizinimiz üzerinden ulaşabilirsiniz."
  },
  {
    "objectID": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html",
    "href": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html",
    "title": "Python Programlamaya Giriş 19 - Liste kurma, sözlük kurma, üreteç ifadeler",
    "section": "",
    "text": "Python’da yeni bir liste oluşturmak için, boş bir listeden başlayabiliriz ve bir döngü içinde append() metoduyla büyütebiliriz. Bu yazıda bu işlemi daha hızlı verimli olarak yapmamızı sağlayan özel liste kurma yazımını göreceğiz. Liste kurma, genel olarak bir üreteç ifadesi örneğidir. Liste kurma gibi sözlük ve kümeleri de hızlıca kurmak için benzer bir yazım kullanırız.\nPython Programlamaya Giriş yazı dizimizin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut."
  },
  {
    "objectID": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#basit-liste-kurma",
    "href": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#basit-liste-kurma",
    "title": "Python Programlamaya Giriş 19 - Liste kurma, sözlük kurma, üreteç ifadeler",
    "section": "Basit liste kurma",
    "text": "Basit liste kurma\nBasit bir örnekle başlayalım: Bir sayı listesi alalım, ve liste elemanlarının karelerinden oluşan yeni bir liste oluşturalım.\nŞimdiye kadar gördüğümüz yöntemlerle bu işi yapmak için önce boş bir liste yaratırız, sonra bir for döngüsü içinde sayıları tek tek alırız, karelerini teker teker boş listeye ekleriz.\n\nsayılar = [1,2,3,4,5]\nkareler = []\nfor x in sayılar:\n    kareler.append(x*x)\n\nkareler\n\n[1, 4, 9, 16, 25]\n\n\nAynı işi daha kısa yoldan ve daha hızlı yapmak için Python’da liste kurma (list comprehensions) denen bir yapı vardır.\n\nkareler = [x*x for x in sayılar]\nkareler\n\n[1, 4, 9, 16, 25]\n\n\nEn basit halinde, liste kurma yapısının genel hali şöyledir:\n[ &lt;ifade&gt; for &lt;değişken&gt; in &lt;sıralı nesne&gt; ]\nBu yapıda, &lt;sıralı nesne&gt;’deki değerler tek tek &lt;değişken&gt;’e atanır, ve &lt;ifade&gt;’nin değeri hesaplanarak listeye eklenir.\nYukarıdaki liste kurma ifadesi aşağıdaki kod parçasına denktir:\nL = []\nfor &lt;değişken&gt; in &lt;sıralı nesne&gt;:\n    L.append(&lt;ifade&gt;)\nBirkaç örnek vererek açıklayalım. İkinin ilk on kuvvetinin listesi:\n\n[2**i for i in range(1,11)]\n\n[2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n\n\nBir dizedeki karakterleri tek tek almak:\n\n[c+\"*\" for c in \"merhaba\"]\n\n['m*', 'e*', 'r*', 'h*', 'a*', 'b*', 'a*']\n\n\nÇokuzlardaki elemanların toplamlarının listesi:\n\n[ x[0] + x[1] for x in [(1,2), (2,-1), (4,2), (3,7)] ]\n\n[3, 1, 6, 10]\n\n\nYukarıdaki örnek, çokuz ataması özelliği sayesinde şöyle de yazılabilir:\n\n[ x+y for x,y in [(1,2), (2,-1), (4,2), (3,7)] ]\n\n[3, 1, 6, 10]\n\n\nAradaki fark şöyle: Birinci durumda x değişkenine sırayla çokuzlar atanıyor, sonra indeksleme ile tek tek elemanlarını alıyoruz. İkinci durumda ise çokuzun birinci ve ikinci elemanı sırasıyla x ve y değişkenlerine atanıyor.\nİfade olarak bir fonksiyon da kullanılabilir.\n\ndef kare(x): return x*x\n[kare(x) for x in range(1,11)]\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\n\ndef topla(a,b): return a+b\n[topla(x,y) for x,y in [(1,2), (2,-1), (4,2), (3,7)] ]\n\n[3, 1, 6, 10]\n\n\nListe kurma ifadelerinin döngülerden bir farkı da, döngü değişkeninin kalıcı olmamasıdır.\n\n[i*i for i in range(10)]\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\n\ni\n\nNameError: name 'i' is not defined\n\n\nOysa bir döngü kullandığımızda iç değişkenler döngüden sonra da erişilebilir olurlar.\n\nL = []\nfor i in range(10):\n    L.append(i*i)\n\ni\n\n9"
  },
  {
    "objectID": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#hız-farkı",
    "href": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#hız-farkı",
    "title": "Python Programlamaya Giriş 19 - Liste kurma, sözlük kurma, üreteç ifadeler",
    "section": "Hız farkı",
    "text": "Hız farkı\nListe kurma ile, bir döngü içinde bir listeye append() ile eleman ekleme aynı işi yapıyorsa, neden liste kurmayı kullanalım? Birincisi, daha sade bir yapı olduğu için. Daha da önemlisi, liste kurma işlemi daha hızlı çalışır.\nHız farkının iki sebebi vardır: Birincisi Python gibi yorumlanan dillerde döngülerin nispeten yavaş çalışmasıdır (C gibi derlenen dillere göre). Bir liste kurma ifadesi yine de örtük bir döngü içeriyor elbette, ama bu döngü alt seviyededir ve Python yorumlayıcısı tarafından yüksek hızda işletilir. İkinci sebep ise her iterasyonda listenin append() metodunun çağırılması gereğidir - fonksiyon çağrıları uzun zaman alan işlemlerdir ve programı yavaşlatırlar.\nBunu daha somut olarak görmek için 1 ile 1000 arasındaki sayıların karelerini alan bir liste kurma ve bir döngü oluşturalım ve iki yaklaşım arasındaki zaman farkına bakalım.\n\n%%timeit\n[x*x for x in range(1000)]\n\n79.8 µs ± 9.52 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)\n\n\n\n%%timeit\nL = []\nfor x in range(1000):\n    L.append(x*x)\n\n150 µs ± 13.2 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)\n\n\nŞartlı liste kurma\n\nListe kurma işleminde her elemanı eklemek zorunda değiliz; bir şartı sağlayanları da eklememiz mümkün. Sözgelişi, bir sayı listesi içinde, sadece beşten büyük olanların karesini barındıran bir liste oluşturalım.\n\n[x*x for x in [1,3,5,7,9,11] if x&gt;5 ]\n\n[49, 81, 121]\n\n\nBu ifade, aşağıdaki döngüye denktir:\nL = []\nfor x in [1,3,5,7,9,11]:\n    if x&gt;5:\n        L.append(x*x)\nÇeşitli karşılaştırma işlemleri ve mantıksal işlemler de birleştirilebilir. Örnek olarak, 1900 ile 2100 arasındaki artık yılların listesini oluşturalım. Bilindiği gibi bir yıl 4’e bölünebiliyorsa artık yıldır; 100’e bölünen ama 400’e bölünemeyen yıllar hariç. Yani 1600 ve 2000 yılları artık yıl iken, 1700, 1800, 1900, 2100 yılları artık değildir.\n\n[ y for y in range(1900, 2101) if (y%4 == 0 and y%100 != 0) or y%400 == 0 ]\n\n[1904,\n 1908,\n 1912,\n 1916,\n 1920,\n 1924,\n 1928,\n 1932,\n 1936,\n 1940,\n 1944,\n 1948,\n 1952,\n 1956,\n 1960,\n 1964,\n 1968,\n 1972,\n 1976,\n 1980,\n 1984,\n 1988,\n 1992,\n 1996,\n 2000,\n 2004,\n 2008,\n 2012,\n 2016,\n 2020,\n 2024,\n 2028,\n 2032,\n 2036,\n 2040,\n 2044,\n 2048,\n 2052,\n 2056,\n 2060,\n 2064,\n 2068,\n 2072,\n 2076,\n 2080,\n 2084,\n 2088,\n 2092,\n 2096]\n\n\nŞartlı liste kurmanın genel ifadesi şöyledir:\n[&lt;ifade&gt; for &lt;değişken&gt; in &lt;sıralı nesne&gt; if &lt;şart&gt;]\nBu yapıda, sadece şartın doğru olduğu değişken değerleri için listeye eleman eklenir. Şart yanlışsa eklenmez. Eğer şart yanlış olduğunda da listeye belli değerler eklenmesini istiyorsak, daha önce gördüğümüz üçlü if-else ifadesini kullanabiliriz.\nSöz gelişi, girdi listesindeki sayı beşten büyükse o sayının karesini, değilse sıfırı barındıran bir liste kuralım.\n\n[x*x if x&gt;5 else 0 for x in [1,3,5,7,9,11] ]\n\n[0, 0, 0, 49, 81, 121]\n\n\nBuradaki if-else komutunun asıl ifadeye ait olduğuna dikkat edin; liste kurma şartı olarak kullanılmamıştır."
  },
  {
    "objectID": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#iç-içe-döngülerle-liste-kurma",
    "href": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#iç-içe-döngülerle-liste-kurma",
    "title": "Python Programlamaya Giriş 19 - Liste kurma, sözlük kurma, üreteç ifadeler",
    "section": "İç içe döngülerle liste kurma",
    "text": "İç içe döngülerle liste kurma\nDiyelim iki ayrı listeden elemanları birleştirerek mümkün bütün çiftleri kurmak istiyoruz, (a,1), (a,2),.., (b,1), (b,2),… gibi. Bunun için birinci listedeki her bir eleman için ikinci listedeki elemanlar üzerinde döngü kurmamız gerek. Yani döngü içinde döngü kurmalıyız. Bunu alışıldık yöntemle şöyle yapabiliriz:\n\nliste = []\nfor c in \"abcd\":\n    for b in [1,2,3]:\n        liste.append((c,b))\nliste\n\n[('a', 1),\n ('a', 2),\n ('a', 3),\n ('b', 1),\n ('b', 2),\n ('b', 3),\n ('c', 1),\n ('c', 2),\n ('c', 3),\n ('d', 1),\n ('d', 2),\n ('d', 3)]\n\n\nAynı işi liste kurma işlemiyle yapmak da mümkündür:\n\n[(c,b) for b in (1,2,3) for c in \"abcd\"]\n\n[('a', 1),\n ('b', 1),\n ('c', 1),\n ('d', 1),\n ('a', 2),\n ('b', 2),\n ('c', 2),\n ('d', 2),\n ('a', 3),\n ('b', 3),\n ('c', 3),\n ('d', 3)]\n\n\nBaşka bir örnek olarak, iki ayrı listeden alınan sayılar ve onların toplamlarından oluşan çokuzlarla bir liste kurabiliriz.\n\n[(a,b,a+b) for b in (1,2,3) for a in (4,5,6)]\n\n[(4, 1, 5),\n (5, 1, 6),\n (6, 1, 7),\n (4, 2, 6),\n (5, 2, 7),\n (6, 2, 8),\n (4, 3, 7),\n (5, 3, 8),\n (6, 3, 9)]\n\n\nKullanabileceğimiz iç içe döngülerin sınırı yok, istediğimiz kadar derine inebiliriz.\n\n[(a,b,c,a+b+c) for c in (1,2) for b in (3,4) for a in (5,6,7)]\n\n[(5, 3, 1, 9),\n (6, 3, 1, 10),\n (7, 3, 1, 11),\n (5, 4, 1, 10),\n (6, 4, 1, 11),\n (7, 4, 1, 12),\n (5, 3, 2, 10),\n (6, 3, 2, 11),\n (7, 3, 2, 12),\n (5, 4, 2, 11),\n (6, 4, 2, 12),\n (7, 4, 2, 13)]\n\n\nHer for ile beraber bir şart ekleyebiliriz.\n\n[(a,b,a+b) for a in (1,2,3,4) if a&gt;2 for b in (5,6,7)]\n\n[(3, 5, 8), (3, 6, 9), (3, 7, 10), (4, 5, 9), (4, 6, 10), (4, 7, 11)]\n\n\n\n[(a,b,a+b) for a in (1,2,3,4) if a&gt;2 for b in (5,6,7) if b&lt;7]\n\n[(3, 5, 8), (3, 6, 9), (4, 5, 9), (4, 6, 10)]\n\n\nŞartlarımız değişkenlerin hepsini birleştiren bir ifade halinde de olabilir. Örnek olarak, a+b+c==10 şartını sağlayan bütün üçlüleri bulalım. Tekrarlardan kaçınmak için b&gt;=a ve c&gt;=b şartlarını da koyalım.\n\n[ (a,b,c) for a in range(1,10) for b in range(a, 10) for c in range(b,10) if a+b+c==10 ]\n\n[(1, 1, 8),\n (1, 2, 7),\n (1, 3, 6),\n (1, 4, 5),\n (2, 2, 6),\n (2, 3, 5),\n (2, 4, 4),\n (3, 3, 4)]\n\n\nListe kurma ifadesinde solda kalan değişken sağ tarafta tanınır, ama tersi doğru değildir. Aşağıdaki kod yanlış olur:\n\n[ (a,b,c) for b in range(a,10) for a in range(1, 10) for c in range(b,10) if a+b+c==10 ]\n\nNameError: name 'a' is not defined\n\n\nListe kurmanın yorumlanması sol taraftan başladığı için, yukarıdaki örnekte a henüz tanımlanmamış oluyor ve yorumlayıcı hata mesajı veriyor. Bu davranışı anlamak için yukarıda bir önceki örneği döngülerle yazalım:\nL = []\nfor a in range(1,10):\n    for b in range(a,10):\n        for c in range(b,10):\n            if (a+b+c==10):\n                L.append((a,b,c))\n          \nBuradan da görülebileceği gibi, for b in range(a,10): satırı önce gelirse, a’nın değeri tanımsız oluyor."
  },
  {
    "objectID": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#genel-liste-kurma-ifadesi-ve-dengi-olan-döngüler",
    "href": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#genel-liste-kurma-ifadesi-ve-dengi-olan-döngüler",
    "title": "Python Programlamaya Giriş 19 - Liste kurma, sözlük kurma, üreteç ifadeler",
    "section": "Genel liste kurma ifadesi ve dengi olan döngüler",
    "text": "Genel liste kurma ifadesi ve dengi olan döngüler\nListe kurma ifadesinin en genel hali şöyle yazılabilir:\n[ &lt;ifade&gt; for &lt;değişken_1&gt; in &lt;sıralı_1&gt; if &lt;şart_1&gt;\nfor &lt;değişken_2&gt; in &lt;sıralı_2&gt; if &lt;şart_2&gt;\n...\nfor &lt;değişken_N&gt; in &lt;sıralı_N&gt; if &lt;şart_N&gt; ]\nBurada if kısımları mecburi değil. Bu yapı ilk bakışta yadırgatıcı geliyorsa, aynısının döngü karşılığını göz önünde tutmak faydalı olabilir.\nliste = []\nfor &lt;değişken_1&gt; in &lt;sıralı_1&gt;:\n    if &lt;şart_1&gt;:\n        for &lt;değişken_2&gt; in &lt;sıralı_2&gt;:\n            if &lt;şart_2&gt;:\n            ....\n                      for &lt;değişken_N&gt; in &lt;sıralı_N&gt;:\n                          if &lt;şart_N&gt;:\n                              liste.append(&lt;ifade&gt;)"
  },
  {
    "objectID": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#iç-içe-listeler-ve-matrisler-kurma",
    "href": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#iç-içe-listeler-ve-matrisler-kurma",
    "title": "Python Programlamaya Giriş 19 - Liste kurma, sözlük kurma, üreteç ifadeler",
    "section": "İç içe listeler ve matrisler kurma",
    "text": "İç içe listeler ve matrisler kurma\nBir önceki bölümde gördüğümüz iç içe for döngülerinin tek seviyeli bir liste kurduğuna dikkat edin. Listeye yeni eleman eklemek ancak en içteki döngüde gerçekleşiyor. Eğer bir listeler listesi oluşturmak istiyorsak başka bir yaklaşım kullanacağız, yani bir liste kurma işlemini başka birinin içine yerleştireceğiz.\n\n[ [a+b for a in \"abc\"] for b in \"xyz\"]\n\n[['ax', 'bx', 'cx'], ['ay', 'by', 'cy'], ['az', 'bz', 'cz']]\n\n\nBir matris bir listeler listesi olarak yazılabilir. Listenin her elemanı (satır) bir listedir. Sözgelişi, \\(\\left[\\begin{array}{ccc}1&2&3\\\\ 4&5&6\\\\7&8&9\\end{array}\\right]\\) matrisini bu şekilde temsil etmek için aşağıdaki yapıyı kullanabiliriz.\n\n[ [3*sütun + satır for satır in [1,2,3] ] for sütun in [0,1,2] ]\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\nDaha karmaşık bir örnek olarak, Kronecker delta \\(\\delta_{i,j}\\) matrisi, yani diyagonal elemanları 1, diğer elemanları 0 olan matris bir üçlü if-else ifadesiyle yazılabilir:\n\n[ [ 1 if satır==sütun else 0 for sütun in range(5)] for satır in range(5)]\n\n[[1, 0, 0, 0, 0],\n [0, 1, 0, 0, 0],\n [0, 0, 1, 0, 0],\n [0, 0, 0, 1, 0],\n [0, 0, 0, 0, 1]]\n\n\nÜreteç ifadeler\n\nYukarıda gördüğümüz liste kurma yapısı, aslında daha genel ve daha verimli olan üreteç ifadeleri nin (generator expressions) özel bir durumudur. İlk örneğimizi, bir üreteç olarak şöyle yazabiliriz:\n\n(x*x for x in [1,2,3,4,5])\n\n&lt;generator object &lt;genexpr&gt; at 0x7f26157b7a98&gt;\n\n\nSomut bir listeye çevirmek için bu üreteç ifadesini çıplak halde (çevresinde parantezler olmadan) bir list() fonksiyonuna verebiliriz. Bu, liste kurma ifadesiyle birebir aynı sonucu verir.\n\nlist(x*x for x in [1,2,3,4,5])\n\n[1, 4, 9, 16, 25]\n\n\nÜreteçler, sıralı nesneler gibi iterasyonlarda kullanılabilirler. Önemli bir farkları vardır: Bütün elemanları bir seferde yaratılıp bellekte saklanmaz. Bunun yerine, her eleman sırası geldikçe üretilir. Üreteç en son kaldığı yeri aklında tutar.\n\ng = (x*x for x in [1,2,3,4,5])\nnext(g), next(g), next(g)\n\n(1, 4, 9)\n\n\nÜreteci bir döngüde kullanabiliriz:\n\nfor i in g:\n    print(i)\n\n16\n25\n\n\nÜreteç ifadelerinin listelere göre avantajı daha az yer kaplamalarıdır. Bir listede bütün elemanlar baştan sonra üretilip bellekte saklanırken, bir üreteçte her eleman sadece ihtiyaç duyulduğu anda (söz gelişi, döngüde sırası geldiği zaman) dinamik olarak üretilirler. Özellikle çok elemanlı dizilerde bu önemli miktarda bellek tasarrufu sağlayabilir.\nÜreteç ifadeleri, dizili nesne alan fonksiyonlara parametre olarak verilebilir:\n\nsum(1/(x*x) for x in range(1,1001))\n\n1.6439345666815615\n\n\nBir de kendi tanımladığımız fonksiyonla kullanalım.\n\ndef çarpım(L):\n    \"\"\"Liste elemanlarının çarpımını döndürür.\"\"\"\n    p = 1\n    for x in L:\n        p *= x\n    return p\n\nçarpım(x+2 for x in range(1,6))\n\n2520"
  },
  {
    "objectID": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#çokuz-ve-küme-kurma",
    "href": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#çokuz-ve-küme-kurma",
    "title": "Python Programlamaya Giriş 19 - Liste kurma, sözlük kurma, üreteç ifadeler",
    "section": "Çokuz ve küme kurma",
    "text": "Çokuz ve küme kurma\nListe yerine küme kurmak için köşeli parantez [] yerine küme parantezi {} kullanmak yeterlidir. Aynı kurallar geçerlidir.\n\n{i for i in range(10) if i%3 &gt; 0}\n\n{1, 2, 4, 5, 7, 8}\n\n\nAncak, yuvarlak parantez () üreteç kurma için kullanıldığından, çokuz üretmek için üreteci tuple() fonksiyonuna vermek gerekir.\n\ntuple( (i,i**2, i**3) for i in range(10) )\n\n((0, 0, 0),\n (1, 1, 1),\n (2, 4, 8),\n (3, 9, 27),\n (4, 16, 64),\n (5, 25, 125),\n (6, 36, 216),\n (7, 49, 343),\n (8, 64, 512),\n (9, 81, 729))"
  },
  {
    "objectID": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#sözlük-kurma",
    "href": "posts/2018/03/24/python-programlamaya-giris-19-liste-kurma-sozluk-kurma-uretec-ifadeler/index.html#sözlük-kurma",
    "title": "Python Programlamaya Giriş 19 - Liste kurma, sözlük kurma, üreteç ifadeler",
    "section": "Sözlük kurma",
    "text": "Sözlük kurma\nListe kurma yapısını sözlük kurmaya adapte etmek mümkündür. Sözlük kurma yapısında, ikililerden oluan bir sıralı nesne üzerinden iterasyon yapılır. İkililerin birinci elemanı sözlüğe anahtar, ikinci elemanı ise o anahtara ait değer olarak atanır.\n\n{k:v for k,v in ((\"a\",1),(\"b\",2),(\"c\",6))}\n\n{'a': 1, 'b': 2, 'c': 6}\n\n\nAnahtarlar ve değerler ayrı nesnelerde sıralanmışlarsa, bunlar zip() fonksiyonuyla istenen biçime sokulabilir.\n\nanahtarlar = (\"a\",\"b\",\"c\")\ndeğerler = (1,2,3)\n{k:v for k,v in zip(anahtarlar,değerler)}\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\nBir sözlüğün items() metodu anahtar-değer ikililerinden oluşan bir dizi verir. Bu dizi üzerinden iterasyon yaparsak, mevcut bir sözlükteki verilerle yeni bir sözlük oluşturabiliriz.\nSöz gelişi, d sözlüğündeki değerlerin karesini barındıran yeni bir sözlük oluşturalım:\n\nd = {'a': 1, 'b': 2, 'c': 3}\n{k*2:v*v for k,v in d.items()}\n\n{'aa': 1, 'bb': 4, 'cc': 9}\n\n\nBu yöntemle bir sözlüğün anahtar ve değerlerini ters çevirmek çok kolaydır:\n\n{v:k for k,v in d.items()}\n\n{1: 'a', 2: 'b', 3: 'c'}\n\n\nBu son örnekte, iki ayrı anahtarda aynı değer varsa, sonra gelenin öncekini sileceğine dikkat edin.\n\nd = {'a': 1, 'b': 2, 'c': 3, 'd':2}\n{v:k for k,v in d.items()}\n\n{1: 'a', 2: 'd', 3: 'c'}"
  },
  {
    "objectID": "posts/2018/03/19/python-programlamaya-giris-18-python-referans-modeli-sig-ve-derin-kopyalama/index.html",
    "href": "posts/2018/03/19/python-programlamaya-giris-18-python-referans-modeli-sig-ve-derin-kopyalama/index.html",
    "title": "Python Programlamaya Giriş 18 - Python referans modeli, sığ ve derin kopyalama",
    "section": "",
    "text": "Python Programlamaya Giriş yazı dizimizin bu bölümünün konusu, Python’da isimler ve nesnelerin eşleştirilmesinin ayrıntıları, ve bu ayrıntıların bazen nasıl bizi şaşırtabileceği. Dizinin bütün yazılarına erişmek için Python Programlamaya Giriş kategorimize bakabilirsiniz. Bu dizideki yazılar ayrıca Jupyter defterleri halinde GitHub depomuzda da mevcut.\n\nNesneler ve referanslar\nElimizde a isimli bir liste olsun. Diyelim bu listeyi kopyalayıp b isimli ikinci ve eş bir liste yaratmak istiyoruz. İlk aklımıza gelen şeyi yapalım ve basit bir atama yapalım.\n\na = [1,2,3]\nb = a\nb\n\n[1, 2, 3]\n\n\nŞimdi a’yı bir kenara bırakalım ve b ile çalışalım. Sözgelişi, b’nin ikinci elemanını değiştirelim.\n\nb[1] = \"abc\"\nb\n\n[1, 'abc', 3]\n\n\nAncak, bu değişiklik b ile sınırlı kalmaz, a’yı da etkiler.\n\na\n\n[1, 'abc', 3]\n\n\nBirçok başka programlama dilinde görülmeyen bu davranışın nedenini anlamak için Python’un atamaları nasıl yaptığına bakmamız gerekiyor.\nBasit bir atamayla başlayalım. Yorumlayıcı a = 42 gibi bir atama ifadesi gördüğünde iki şey yapar: 42 değerini taşıyan bir tamsayı nesnesi yaratır, ayrıca bir a ismi yaratır, ve bu ismi 42 nesnesine bağlar. İsim ve işaret ettiği nesne birbirlerinden bağımsız varlıklardır.\n\nfrom IPython.display import Image\n\n\nImage(\"img/atamalar1.png\")\n\n\n\n\nİsimlerle nesneler birbirinden ayrıldığı için, Python’da değişkenlerin ne tipte olduğunu (tamsayı, karakter, vs) deklare etmeniz gerekmez. Aynı isim çok farklı tipte nesnelere aktarılabilir. Mesela hemen ardından a = \"merhaba\" komutu verirsek yorumlayıcı \"merhaba\" dizesini barındıran bir nesne yaratır, ve a ismini bu yeni dizeye bağlar.\n\nImage(\"img/atamalar2.png\")\n\n\n\n\nBu olunca 42’ye ne olur? Eğer ona referans veren başka bir isim varsa yerinde kalır, yoksa silinir. Her nesneyle beraber ona kaç referans verildiğinin sayısı tutulur. Bu sayı sıfıra indiğinde “çöp toplayıcı” o nesneyi bellekten kaldırır.\na değişkenini \"merhaba\"ya bağladıktan sonra b = a gibi bir atama yapıldığında \"merhaba\"ya bir de b ismi bağlanır. Şimdi aynı nesnenin iki farklı ismi vardır.\n\na = \"merhaba\"\nb = a\nb is a\n\nTrue\n\n\nBurada kullandığımız is işleminin True vermesi iki ismin aynı nesneye işaret ettiğini gösterir. Yani a ve b’deki değerler eşit olmakla kalmıyorlar, aynılar.\n\nImage(\"img/atamalar3.png\")\n\n\n\n\nŞimdi yukarıdaki davranışı daha iyi anlayabiliyoruz. Yaptığımız atamalar sonucunda a ve b aynı listeye işaret ettiğinden, b ismi aracılığıyla yapılan bir değişiklik a ismine de yansır.\n\na = [1,2,3]\nb = a\na is b, a[0] is b[0]\n\n(True, True)\n\n\n\nfrom IPython.display import IFrame\n\nBunu daha iyi görmek için Python Tutor sitesinden, Python kodunun işletilme aşamalarını görsel olarak sunan bir programcığı kullanabiliriz. “Next&gt;” tuşuna tıklayarak satırları tek tek işletin.\n\nIFrame(src=\"http://pythontutor.com/iframe-embed.html#code=a%20%3D%20%5B1,2,3%5D%0Ab%20%3D%20a%0Ab%5B0%5D%20%3D%20%22abc%22&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=false&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\",\n       width=800, height=500) \n\n\n        \n        \n\n\nAynı davranış fonksiyonlarda da görülür. Bir fonksiyon parametre olarak bir liste alır ve listeyi kendi içinde değiştirirse, orijinal liste de değişir.\n\ndef f(x,L):\n    L[0] = x  # L'nin ilk elemanına x'i ata.\n\na = [1,2,3]\nf(\"merhaba\",a)\na\n\n['merhaba', 2, 3]\n\n\n\n\nSığ ve derin kopyalama\nPeki ne yapmalıyız? Doğrudan atama yapmak yerine, listenin copy() metodunu kullanmamız gerekir. Bu metod ile elde ettiğimiz kopyayı yeni bir isme atadığımızda, artık iki isim aynı nesneye işaret etmez, ve birinde yapılan değişiklik öbürüne aktarılmaz.\n\na = [1,2,3]\nb = a.copy()\nprint(\"a is b?\", a is b)\nprint(\"a == b?\", a == b)\n\na is b? False\na == b? True\n\n\nBurada a ve b aynı değerleri taşıyan ama birbirinden ayrı iki liste oldu. Artık birini değiştirmek öbürünün de değişmesine sebep olmayacak.\n\nImage(\"img/atamalar4.png\")\n\n\n\n\n\nb[0] = \"abc\"\nb\n\n['abc', 2, 3]\n\n\n\na\n\n[1, 2, 3]\n\n\ncopy() metodu listelerin yanı sıra sözlükler ve kümelerde de mevcuttur. Çokuz ve dizelerde bulunmazlar, ama zaten onlar değiştirilemez (immutable) nesneler oldukları için elemanlarına atama yapılamaz.\nSıralı nesnelerde (liste, çokuz, dize, vs.) dilimleme işlemi de bir kopya üretmek için kullanılabilir. Böylece bir a nesnesini kopyalamak için a[:] yazımı kullanılabilir.\n\na = [1,2,3]\nb = a[:]\na is b\n\nFalse\n\n\nAncak, gerek copy() metodu gerekse de a[:] işlemi sığ bir kopya üretir. Başka bir deyişle, liste elemanlarını birebir kopyalarlar. Ama ya liste elemanının kendisi bir listeyse? O zaman aynı problem daha derin bir seviyede karşımıza çıkar.\n\na = [5, [4,9,3], 7.1]\nb = a.copy()\nb[0] = 8                # a'yı değiştirmez\nprint(\"a =\",a)\nprint(\"b =\",b)\n\na = [5, [4, 9, 3], 7.1]\nb = [8, [4, 9, 3], 7.1]\n\n\n\nb[1][0] = \"merhaba\"     # a'yı değiştirir\nprint(\"a =\",a)\nprint(\"b =\",b)\n\na = [5, ['merhaba', 9, 3], 7.1]\nb = [8, ['merhaba', 9, 3], 7.1]\n\n\nAynı sorunla karşılaşmamızın sebebi, a’nın ikinci elemanının bir referans barındırmasıdır. copy() metoduyla kopyalanan da bu referanstır, listenin kendisi değil.\n\nImage(\"img/atamalar5.png\")\n\n\n\n\nDerin seviyelerde kusursuz kopyalama yapabilmek için copy modülü içindeki deepcopy() fonksiyonunu kullanmak gerekir.\n\nimport copy\n\na = [5, [4,9,3], 7.1]\nb = copy.deepcopy(a)\n\nb[1][0] = \"merhaba\"\nprint(\"a =\",a)\nprint(\"b =\",b)\n\na = [5, [4, 9, 3], 7.1]\nb = [5, ['merhaba', 9, 3], 7.1]\n\n\nBu sefer derin kopyalama yaptığımız için, b’de yaptığımız hiç bir değişiklik artık a’ya yansımıyor.\n\n\nListe-sayı çarpımı referansları kopyalar\nSon bir örnek olarak, çarpma işlemiyle çoğaltılmış bir listeler listesini ele alalım.\n\nL = [[1,2,3]]*4\nL\n\n[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]\n\n\nBildiğimiz gibi bir listeyle bir sayıyı çarpmak, o listenin elemanlarının o sayı kadar tekrarlandığı yeni bir liste yaratır. Burada da beş tane listeden oluşan bir listemiz var. Bu listenin birinci elemanındaki elemanlardan birine bir atama yapalım.\n\nL[0][0] = \"abc\"\nL\n\n[['abc', 2, 3], ['abc', 2, 3], ['abc', 2, 3], ['abc', 2, 3]]\n\n\nBu davranışın sebebi liste elemanlarının kendilerinin değil referanslarının kopyalanarak listeye konması. Nitekim is işlemi ile kontrol ettiğimizde elemanların aynı nesne olduğunu görüyoruz.\n\nL[0] is L[1]\n\nTrue\n\n\n\nImage(\"img/atamalar6.png\")\n\n\n\n\nÇarpımla çoğaltılan listelerde elemanların değil referansların kopyalanması genel olarak verimlilik sağlayan bir özellik. Aynı nesneleri dört kere değil bir milyon kere çoğalttığımızı düşünün; kopyalamakla gereksiz yere bellek işgal etmiş oluruz. Yine de eğer gerçek kopyalama istiyorsak, deepcopy() fonksiyonunu liste kurma işlemi ile beraber şu şekilde kullanabiliriz.\n\nL = [copy.deepcopy(i) for i in [[1,2,3]]*4]\nL\n\n[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]\n\n\nBöylece elemanlar aynı nesne olmaktan çıkar ve birine yapılan atama diğerlerini etkilemez.\n\nL[0] is L[1]\n\nFalse\n\n\n\nL[0][0]=\"abc\"\nL\n\n[['abc', 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]"
  },
  {
    "objectID": "posts/2018/08/29/bilimsel-programlamaya-kolay-baslangic-1/index.html",
    "href": "posts/2018/08/29/bilimsel-programlamaya-kolay-baslangic-1/index.html",
    "title": "Bilimsel Programlamaya Kolay Başlangıç - 1",
    "section": "",
    "text": "Bilimsel Programlamaya Kolay Başlangıç gibi bir seri oluşturma fikri, öğrencilerin bir problemi çözmek için yaklaşım geliştirmekte ne kadar zorlandıklarını gördükten sonra kafamda oluşmaya başladı. Veri Defteri’nde belli bir konuyu açıklamayı hedefleyen birçok faydalı yazı var, ama benim amacım, programlamayı araç olarak kullanmak; seri boyunca gitgide karmaşıklaşan problemleri buna uygun programlama araçlarıyla çözmek.\nBilimsel Programlama denilince akla şu ara yapay zeka, makine öğrenmesi gibi afili konular geliyor, ama aslında bilimsel programlama bazen bundan çok daha fazlası ve genellikle de çok daha azı. Aslında istediğimiz şey, basit ya da karmaşık bir problemi bilgisayar aracılığıyla çözülebilir hale getirmek, problemi bilgisayara çözdürmek ve sonuçları anlayıp değerlendirmekten ibaret.\nBilimsel Programlama her disiplin için farklı şeyler ifade etse de, öğrencilerden araştırmacılara birçokları için temel birkaç adımdan oluşuyor:\n\nHazırlık (Sabitleri başlatma, gerekirse veri yapılarını oluşturma vb.)\nHesaplama\nSonuçları Görselleştirme\n\nOlan biteni daha net anlatabilmek için son derece basit, lise seviyesinde bir problemi ele alalım: Serbest Düşüş Hareketi.\nProblemin matematiksel modeli bu kadarcık:\nKonum değişimi:\n\\(h(t) = h(t_0) - \\frac{1}{2} g t^2\\)\nHız değişimi:\n\\(v(t) = v(t_0) - g t\\)\nParametreler ise şöyle:\n\\(h =\\) yükseklik (\\(m\\))\n\\(v =\\) hız (\\(m/s\\))\n\\(g =\\) kütleçekimi sabiti (Dünya için 9.81 \\(m/s^2\\))\n\\(t =\\) zaman (\\(s\\))\n\\(h(t_0) =\\) başlangıçtaki yükseklik (\\(m\\))\n\\(v(t_0) =\\) başlangıçtaki hız (\\(m/s\\))\nBu yazıda sadece yukarıdaki formül ile “gerçek” değerler üzerinden ilerleyeceğiz, sonraki yazıda ise yatay atış hareketi ve bunun sayısal yöntemlerle modellenmesi konusunda değineceğiz. Amacımız, başlangıçtan itibaren 10 saniye içinde düşen cismin yükseklik değişiminin grafiğini çizebilmek. Bunun için 1 saniye aralıkla yüksekliği hesaplayacağız.\nİlk adım olarak, hazırlık aşamasında yerçekimi sabitini ve çıktı alacağımız zaman listesi ile daha sonra dolduracağımız konum ve hız listelerini oluşturuyoruz:\n\n# sonradan gerekecek kütüphanelerini çağır\nimport matplotlib.pyplot as plt\n\n# Kütleçekimi Sabiti [m/s^2]\ngDünya = 9.81\n\n# bitiş zamanı (sn)\ntSon = 10 \n# adım büyüklüğü (sn)\ntAdım = 0.5\n\n\n# başlangıç zamanı, irtifa ve hız\nt0 = 0 \nh0 = 0\nv0 = 0\n\n# Zaman, yükseklik ve hız listelerini oluştur\ntList = []\nhListDünya = []\nvListDünya = []\n\nBahsettiğimiz üç adımdan Hazırlık kısmını hallettiğimize göre, Hesaplama adımına geçmek için işin matematiğine yakından bakabiliriz. Her adımda yukarıda verdiğimiz formülün sonucunu tekrar tekrar hesaplıyoruz ve değişen tek şey sadece zaman. O halde hesaplama mekanizmasını bir kere kurup sonra gerektikçe tekrar çalıştırabiliriz.\nBu işi yapmanın iki yöntemi var: 1. Karmaşık işler için eski usül “fonksiyon” tanımlama (hatırlatma için buraya ve buraya bakabilirsiniz.) 2. Basit sayılabilecek işler için lambda mekanizması (hatırlatma için buraya bakabilirsiniz)\nİkisini de gösterecek örneklere bakalım; konumu eski usül fonksiyonla, hızı da lambda ile hesaplayalım:\n\n# Normal inline method\ndef h(t, h0=0, g=gDünya):\n    \"\"\"Verilen bir t zamanı için irtifayı döndürür ($ h(t) = h_0 - \\frac{1}{2} g t^2 $)\"\"\"\n    return h0 + (-1/2 * g * t**2)\n\n# Lambda method\nv = lambda t, vy0=0, g=gDünya: vy0 + ( -g*t )\n#    \"\"\"Verilen bir t zamanı için hızı döndürür ($ v(t) = v_0 - g t $)\"\"\"\n\nSözdizimini uzun uzun anlatmayacağım. Özetle, konum fonksiyonuna hedef zaman, başlangıç konumu ve kütleçekimi ivmesini veriyoruz; eğer bir şey vermezsek başlangıç konumunu sıfır ve kütleçekimi ivmesini de Dünya olarak almasını tembihliyoruz. Benzer şekilde hız fonksiyonuna da hedef zaman, başlangıç konumu ve kütleçekimi ivmesini veriyoruz; eğer bir şey vermezsek başlangıç hızını sıfır ve kütleçekimi ivmesini de yine Dünya olarak almasını sağlıyoruz.\nÜç tırnak ile fonksiyonlara açıklama koyduğumuz da dikkatinizi çeksin. Bu kadar basit bir örnekte o kadar gerekli olmayabilir, ama emin olun karmaşık bir fonksiyonun ne yaptığını, hangi parametreleri hangi birimde aldığını altı ay sonra hatırlamayacaksınız. Yazdığınız kodu başkası kullanacaksa, bu açıklamaları yazmazsanız yiyeceğiniz küfür de cabası. Bunların hepsi iyi alışkanlıklar.\nFonksiyonlarımızı zaten daha önce hazırlamıştık, tek yapmamız gereken başlangıçtan bitiş zamanına dek her zaman adımı için bunları tekrar tekrar çağırmak ve bulduğumuz değerleri en başta oluşturduğumuz boş listelere eklemek:\n\nt = t0 \nwhile t&lt;=tSon:\n    hListDünya.append( h(t, h0) )\n    vListDünya.append( v(t, v0) )\n    tList.append(t)\n    t += tAdım\n\n# Zaman listesinin ilk 3 elemanını ekrana bas\nprint(tList[:3])\n# Yükseklik listesinin ilk 3 elemanını ekrana bas\nprint(hListDünya[:3])\n# Hız listesinin ilk 3 elemanını ekrana bas\nprint(vListDünya[:3])\n\n[0, 0.5, 1.0]\n[0.0, -1.22625, -4.905]\n[0.0, -4.905, -9.81]\n\n\nEkrana zaman, konum ve hızın ilk 3 değerini bastık. Birinci saniyede konumun -4.905 m , hızın da -9.81 m/s olması iyiye işaret, yukarıda formülden de bunun doğruluğunu kontrol edebiliriz. Görünen o ki fonksiyonlarımız iyi çalışıyor. Bu tür küçük testleri yapmak, daha da iyisi bunları minik birim testleri (unit test) olarak kodunuza eklemek yarın bir gün bir şeyler çalışmadığında hatanın nerede olduğunu, ya da en azından nerede olmadığını anlamanızda size çok yardımcı olacaktır.\nHer bir zaman adımı için hesaplamayı yaparken t zaman sayacını ilerlettiğimize de dikkat edin. Bu zaman sayacı sayesinde tSon değerini geçtiğimizde döngüden çıkıyoruz.\nSon adım olan Sonuçları Görselleştirme’de ise ekrana güzel bir grafik basıyoruz (\\(\\LaTeX\\) formatında yazılmış formüle dikkat). İlk grafikte zaman listesi ile aynı büyüklükte ve her bir zamana karşılık gelen konum listesini de grafik komutuna yolluyoruz. İkinci grafik de benzer şekilde zaman ve hız listelerinden grafiği oluşturuyor.\n\n# Yükseklik grafiği\nplt.plot( tList , hListDünya)\n\nplt.title(r\"Yükseklik Değişimi ($ h = \\frac{1}{2} g t^2 $)\")\nplt.xlabel(\"zaman (s)\")\nplt.ylabel(\"yükseklik (m)\")\n\nplt.show()\n\n\n\n\n\n# Hız grafiği\nplt.plot( tList , vListDünya)\n\nplt.title(r\"Hız Değişimi ($ v = -gt $)\")\nplt.xlabel(\"zaman (s)\")\nplt.ylabel(\"hız (m/sn)\")\n\nplt.show()\n\n\n\n\nJupyter defterleri ve grafiklerin içindeki \\(\\LaTeX\\) formülleri ilginizi çektiyse buradan daha fazla bilgi edinebilirsiniz.\nBuraya kadar her şey güzel ve basit - bilimsel programlamanın yukarıda bahsettiğim üç temel adımını da uygulamış olduk. Bu problemi çözmek için daha başka yöntemler de uygulamak elbette mümkün. Sonuçta programlamada her yiğidin bir yoğurt yiyişi olduğu doğru. Önemli olan, daha zorlu problemler karşımıza çıktıkça daha farklı yöntemleri de kullanabilmek.\nO halde yazıyı bitirmeden önce işleri biraz daha eğlenceli hale getirelim ve Dünya ile Ay’daki serbest düşmeyi kıyaslayalım. Altyapıyı (fonksiyonlarımızı) iyi hazırladığımız için bunu yapmak gayet kolay.\nYapılması gereken ilk iş hazırlık kısmına Ay’ı eklemek ve zaman listesinin yanı sıra boş konum ve hız listelerini oluşturmak. Konum ve hız listelerini hem Dünya hem de Ay için ayrı ayrı oluşturmamız gerekiyor. Ancak zaman listesi ikisi için de ortak.\n\n# Kütleçekimi Sabiti [m/s^2]\ngDünya = 9.81\ngAy  = 1.625 \n\n# bitiş zamanı (sn)\ntSon = 10 \n# adım büyüklüğü (sn)\ntAdım = 0.5\n\n\n# başlangıç zamanı, irtifa ve hız\nt0 = 0 \nh0 = 0\nv0 = 0\n\n# Zaman, yükseklik ve hız listelerini oluştur\ntList = []\nhListDünya = []\nvListDünya = []\nhListAy = []\nvListAy = []\n\nDöngüyü her bir zaman adımı için çalıştırıp bu kez hem Ay hem de Dünya için konum ve hız verilerini dolduruyoruz. Ayrıca, varsayılan değer olarak Dünya kütleçekimi katsayısını değil, hem Ay hem de Dünya için başta belirlediğimiz kütleçekimi katsayısı değerlerini fonksiyona yolluyoruz.\n\nt = t0 \nwhile t&lt;=tSon:\n    hListDünya.append( h(t, h0, gDünya) )\n    vListDünya.append( v(t, v0, gDünya) )\n    \n    hListAy.append( h(t, h0, gAy) )\n    vListAy.append( v(t, v0, gAy) )\n    \n    tList.append(t)\n    t += tAdım\n\nBu örnekte grafikleri birazcık süsleyeceğiz. Hem Ay hem de Dünya için grafikleri üstüste basarak karşılaştıracağız. Bunu yaparken Ay ve Dünya için veri etiketlerini legend kullanarak grafiğe ekleyeceğiz.\nBunun yanı sıra subplot yapısıyla konum ve hız grafiklerinin zamanı ortak eksen olarak kullanan yekpare bir grafik olarak çalışmasını sağlayacağız. Bu tür ikili veya dörtlü grafik gruplarını makalelerde sıklıkla görebilirsiniz.\n\n# Yükseklik grafiği\nplt.subplot(211)\nplt.plot( tList , hListDünya, label=\"Dünya\")\nplt.plot( tList , hListAy, label=\"Ay\")\n\nplt.title(r\"Yükseklik ve Hız Değişimi ($ h = \\frac{1}{2} g t^2 $ & $ v = -gt $)\")\nplt.xlabel(\"zaman (s)\")\nplt.ylabel('yükseklik (m)')\nplt.legend(loc=3)\n\n# Hız grafiği\nplt.subplot(212)\nplt.plot( tList , vListDünya, label=\"Dünya\")\nplt.plot( tList , vListAy, label=\"Ay\")\n\nplt.xlabel(\"zaman (s)\")\nplt.ylabel(\"hız (m/sn)\")\nplt.legend(loc=3)\n\nplt.show()\n\n\n\n\nBu örneğimizde saf Python kullandık, henüz numpy gibi daha eğlenceli ve yetenekli yapılara girmedik. Ancak temel döngüler, veri görselleştirme, fonksiyonlar ve bilimsel programlamanın temellerine umuyorum ki kolay bir başlangıç yapmış olduk.\nBu yazıyı çalıştırılabilir bir Jupyter defteri halinde, yazıdaki iki örneğin kodlarıyla birlikte GitHub sayfamızda bulabilirsiniz."
  },
  {
    "objectID": "posts/2019/03/02/bilimsel-programlamaya-kolay-baslangic-iv/index.html",
    "href": "posts/2019/03/02/bilimsel-programlamaya-kolay-baslangic-iv/index.html",
    "title": "Bilimsel Programlamaya Kolay Başlangıç - 4",
    "section": "",
    "text": "Yazı dizimizin bir önceki bölümünde numpy kullanımına basit bir giriş yapmıştık, şimdi ise daha ileri matematiksel yöntemleri içeren scipy’a bir göz atalım. Yapmaya çalıştığımız “ivmenin nümerik integrasyonu” işi, aslında bir “ikinci derece diferansiyel denklem çözümü” ile eşdeğer. Konumun zamana göre ikinci türevi olan ivme diferansiyel denklemini analitik olarak çözebilseydik, konum ve hız vektörlerinin geçmiş ve gelecekteki tüm değerlerini bulabilirdik. Lakin bunu analitik olarak çözmeye hiç niyetimiz yok - işi bilgisayar yapabilecekken biz niye uğraşalım ki?\nscipy bu tür diferansiyel denklemleri çözmek için bize integrate paketi altında solve_ivp adlı kütüphaneyi sunuyor. Bu kütüphane altındaki metodlarla diferansiyel denklemleri sayısal metodlarla kolayca çözebiliriz. Ancak öncelikle denklemleri bu yöntemlerin anlayacağı halde yazmamız gerekiyor, diğer bir deyişle ikinci derece diferansiyel denklemi iki tane birinci derece diferansiyel denklem haline getirmemiz gerekiyor. Öncelikle kullanacağımız ara değişkenleri belirleyelim:\n\\[\\vec{y_1} = \\frac{d\\vec{r}}{dt} = \\dot{\\vec{r}}\\] \\[\\vec{y_2} = \\vec{r}\\]\nŞimdi de ikinci derece diferansiyel denklemimizi bu yeni değişkenler cinsinden yazalım:\n\\[\\dot{\\vec{y_2}} = \\frac{d\\vec{y_2}}{dt} = \\vec{y_1}\\]\n\\[\\dot{\\vec{y_1}} = \\frac{d\\vec{y_1}}{dt} = - \\frac{\\mu}{(y_2)^3} \\vec{y_2}\\]\nBöylece ikinci derece diferansiyel denklemimiz iki tane birinci derece diferansiyel denkleme indirgendi ve scipy’ın çözebileceği hale geldi.\nYukarıda olan biteni kod halinde yazmak zor değil:\n\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Kütleçekimi Sabiti [m^3/s^2]\nmuDünya = 398600.5*1E9  \n\ndef odeDiffDenklem(t, y, mu=muDünya):\n    \"\"\"\n    İki cisim problemi için diferansiyel denklem setini tanımlar.\n    \n    Arguments:\n        t {float} -- başlangıç zamanı (s)\n        y {ndarray} -- konum (m) ve hızı (m/s) içeren 1B, 4 elemanlı vektör [r_x r_y v_x v_y]\n\n\n    Returns:\n        {ndarray} -- konum ve hız diferansiyel denklemlerini (hız (m/s) ve ivmeyi(m/s^2)) içeren \n        1B, 4 elemanlı vektör [v_x v_y a_x a_y]\n    \"\"\"\n    r = np.sqrt(y[0]**2 + y[1]**2)\n\n    dy0 = y[2]\n    dy1 = y[3]\n    dy2 = -(mu / (r**3)) * y[0]\n    dy3 = -(mu / (r**3)) * y[1]\n    \n    return [dy0, dy1, dy2, dy3]\n\nodeDiffDenklem zaman ile konum-hız vektörünü alıyor (aslında yerçekimi ivmesini de alıyor ama maalesef henüz yeni çıkmış olan solve_ivp paketi bu değerin dışarıdan atanmasını kabul etmiyor).\nYukarıdaki metodla tanımlanan diferansiyel denklem setini çözen kod da zor görünüyor, ama aslında değil:\n\n\ndef odeÇözümü(pvt0, tAdım, tSon, çözücüTipi = 'RK45'):\n    \"\"\"\n    Scipy ODE sayısal integrasyon metodlarıyla konum ve hız değerleri listesini hesaplar.\n\n    Arguments:\n        tAdım {float} -- adım büyüklüğü (s)\n        pvt0 {ZamanKonumHız} -- başlangıç zamanında zaman konum hız\n        tSon {float} -- bitiş zamanı (s)\n        çözücüTipi {string} -- ODE çözücüsünün tipi ('RK45', 'RK23', 'Radau', 'BDF', 'LSODA')\n\n    Returns:\n        list {ZamanKonumHız} --  her bir zaman adımı için zaman konum hız değerlerini içeren liste\n    \"\"\"\n\n    # adımSayısı ve zaman listesini oluştur\n    adımSayısı = (tSon-pvt0.t)/tAdım + 1\n    zamanListesi = np.asarray(np.linspace(pvt0.t, tSon, num = adımSayısı, endpoint=True))\n    \n    # diff denklem başlangıç değerlerini oluştur\n    diffIlkDeğer = np.asarray(np.concatenate([pvt0.r, pvt0.v]))\n    \n    # diff denklemi başlangıç zamanından son zamana dek çöz\n    diffDenkÇözüm = solve_ivp(odeDiffDenklem, [pvt0.t, tSon], diffIlkDeğer, method=çözücüTipi, dense_output=True) \n    \n    # zaman listesine karşılık gelen değerleri oluştur\n    cozumListesi = diffDenkÇözüm.sol.__call__(zamanListesi)\n    \n    # sonuç listesini başlat\n    numPvtList = []\n\n    # Listeyi objelere dönştür\n    for i in range(len(zamanListesi)):\n        pvArray = cozumListesi[:, i]\n        numPvtList.append( ZamanKonumHız(zamanListesi[i], pvArray[0], pvArray[1], pvArray[2], pvArray[3]) )\n\n    return (numPvtList)\n\nodeÇözümü, başlangıç ZamanKonumHız nesnesini, adım büyüklüğünü ve son zaman adımını alıyor. Buraya kadarki kısmı Euler ile benzer. Ancak buna ek olarak kullanılacak diferansiyel denklem çözüm yöntemini de alıyor. Varsayılan değer olan RK45, 4. derece bir çözücü kullanarak adım büyüklüğünü belirleyen ama asıl çözüm için 5. derece kullanan bir Adaptif Runge-Kutta yöntemi. Çok profesyonel olmasa da birçok öğrencinin projelerinde iş görecek bir diferansiyel denklem çözücüsü. Bu yöntem, hatayı belli bir seviyenin altında tutacak şekilde kendi adım büyüklüğünü belirleyecek kadar da akıllı. Ancak biz her tAdım değerinde bir çıktı almak istiyoruz. Bu nedenle, her tAdım aralıkla çıktı alınacak zamanların bir listesini oluşturuyoruz.\nsolve_ivp satırı aslında denklem setinin çözüldüğü satır - bir döngü bile yok, her şey sessiz sedasız içeride hallediliyor. Bu çözücüye diferansiyel denklem setini içeren metodu, başlangıç ve bitiş zamanlarını, ilk konum ve hızı ve çözücü tipini yolluyoruz. Bir sonraki adımda ise zaman listesine karşılık gelen ara çözümleri oluşturuyoruz. Biz diffDenkÇözüm.sol.__call__(zamanListesi) komutunu yazdığımızda arka tarafta interpolasyon algoritmaları bizim istediğimiz zamanlara karşılık gelen noktaları oluşturuyor. Son kısımda ise elde ettiğimiz bu çözüm setini ZamanKonumHız nesnelerine dolduruyoruz.\nSadece bu iki satır ile, oturup yazmaya üşeneceğimiz (ben benzerlerini yazdım, oradan biliyorum), yüzlerce satırlık koda karşılık gelen işlevselliği kolaylıkla elde edebiliyoruz. scipy sayesinde elbette!\nO halde bunları çağırarak problemi çözen koda bakalım:\n\n# başlangıç zamanı\nt0 = 0\n# bitiş zamanı (sn)\ntSon = 6000 \n# adım büyüklüğü (sn)\ntAdımEuler_1  = 5\ntAdımEuler_2  = 1\ntAdımODE = 60\nçözücüTipi = 'RK23'\n\n# başlangıç konum ve hız\npvt0 = ZamanKonumHız(t0, 0, 7000*1E3, 7.5*1E3, 0)\n\n\n# Euler sayısal integrasyon verisini hesaplayan döngüyü çalıştır\neulPvtList5  = hesapDöngüsüEuler(pvt0, tAdımEuler_1, tSon)\neulPvtList1  = hesapDöngüsüEuler(pvt0, tAdımEuler_2, tSon)\n\nçözücüPvtList = odeÇözümü(pvt0, tAdımODE, tSon, çözücüTipi)\n\n/home/egemen/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:18: DeprecationWarning: object of type &lt;class 'float'&gt; cannot be safely interpreted as an integer.\n\n\nDiferansiyel denklem çözücüsü için 60 saniyelik bir çıktı adım büyüklüğü kullandık, ama bu seferlik kullanacağımız 3. derece Runge-Kutta (RK23) yönteminde de adım büyüklüğü otomatik olarak, integrasyon algoritması tarafından belirleniyor. Bakalım RK23 kullanarak bulduğumuz sonuçlar küçük adımlara sahip Euler yöntemlerinden daha mı iyi çıkacak?\nBu sorunun yanıtı için grafikleri oluşturmamız gerek:\n\n# konum grafiği\nplt.plot( [pvt.r[0] for pvt in çözücüPvtList], [pvt.r[1] for pvt in çözücüPvtList], label=çözücüTipi + \" (\" + str(tAdımODE) + \" s)\")\n\nplt.title(\"Konum\")\nplt.xlabel(\"x konum (m)\")\nplt.ylabel('y konum (m)')\n\nplt.axes().set_aspect('equal')\nplt.grid(b=True, which='major', linestyle='--')\n\nplt.show()\n\n# hız grafiği\nplt.plot( [pvt.v[0] for pvt in çözücüPvtList], [pvt.v[1] for pvt in çözücüPvtList], label=çözücüTipi + \" (\" + str(tAdımODE) + \" s)\")\n\nplt.title(\"Hız\")\nplt.xlabel(\"x hız (m/s)\")\nplt.ylabel(\"y hız (m/s)\")\n\nplt.axes().set_aspect('equal')\nplt.grid(b=True, which='major', linestyle='--')\n\nplt.show() \n\n# enerji grafikleri\n\n#referans değer - tüm farklar bu değere göre hesaplanacak\nspEnerjiRef = pvt0.spesifikEnerji()\n\nplt.title(\"Spesifik Enerji Değişimi\")\nplt.xlabel(\"zaman (s)\")\nplt.ylabel(\"spesifik enerji ($m^2/s^2$)\")\nplt.yscale('log')\n\nplt.plot( [pvt.t for pvt in eulPvtList1], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in eulPvtList1], label=\"Euler (\" + str(tAdımEuler_2) + \" s)\")\nplt.plot( [pvt.t for pvt in eulPvtList5], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in eulPvtList5], label=\"Euler (\" + str(tAdımEuler_1) + \" s)\")\nplt.plot( [pvt.t for pvt in çözücüPvtList], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in çözücüPvtList], label=çözücüTipi + \" (\" + str(tAdımODE) + \" s)\")\n\nplt.legend(loc=4)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\nÖncelikle konum ve hız grafiklerini göstermek için kullandığımız RK23’ün hiç fena performans göstermediği anlaşılıyor - başladığımız yere iyi kötü dönmeyi başarmışız.\nYöntemler arasındaki uçurum nedeniyle enerji değişim grafiğini log ölçeğinde çizdirdik, aslında tüm yöntemler için artış lineer. Log kısmını kapatıp bunu siz de görebilirsiniz. Enerji grafiklerine bakınca, RK23’ün, 1 saniye adım büyüklüğüne sahip Euler’in sadece onda biri kadar enerji hatası yaptığı görülüyor. Yani scipy’ın yöntemleri bizim uzun uzadıya yazdığımız kodlardan çok daha iyi sonuç veriyor. Çıkarılacak sonuç çok açık, tekerleği yeniden keşfetmenin gereği yok - tabii scipy’ın sunduklarından daha iyi algoritmalar kullanmak durumundaysanız iş başka.\nYazdığımız odeÇözümü metodunda pek hoş olmayan bir kısım var: metoda çözücü adını string olarak yolluyoruz. Ancak kafamıza göre bir string değeri yollamamız mümkün değil, zira solve_ivp tarafından kabul edilen sadece birkaç çözücü var. Bu yöntem bizi hataya fazlasıyla açık hale getiriyor. Bunu çözmenin pratik bir yolu enumerator adı verilen mini mini veri depoları. Öncelikle enum içinde olası tüm değerleri (yani integrasyon algoritması tiplerini) belirliyoruz. Örneğin adı, yani çözücüTipi.name değeri RADAU olan bir parametremiz var. Bunun çözücüTipi.value ile sorgulanan değeri ‘Radau’ ile ifade edilen string. Böylece parametre adları ve buna karşılık gelen değerlerden mini bir tablo oluşturmuş oluyoruz.\n\nfrom enum import Enum\n\nclass ODEÇözücüTipi(Enum):\n    \"\"\"\n    solve_ivp integrasyon tipleri\n    \"\"\"\n    RK45 = 'RK45'\n    RK23 = 'RK23'\n    RADAU = 'Radau'\n    BDF = 'BDF'\n    LSODA = 'LSODA'\n\nBir sonraki adımda da odeÇözümü metodunda buna uygun küçük bir değişiklik yapıyoruz - metodumuzun kullanıcısını yukarıda belirlediğimiz tablodaki parametreler arasında bir tercih yapmaya zorluyoruz.\n\ndef odeÇözümü(pvt0, tAdım, tSon, çözücüTipi = ODEÇözücüTipi.RK45):\n    \"\"\"\n    Scipy ODE sayısal integrasyon metodlarıyla konum ve hız değerleri listesini hesaplar.\n\n    Arguments:\n        tAdım {float} -- adım büyüklüğü (s)\n        pvt0 {ZamanKonumHız} -- başlangıç zamanında zaman konum hız\n        tSon {float} -- bitiş zamanı (s)\n        çözücüTipi {ODEÇözücüTipi} -- ODE Çözücü Tipi\n\n    Returns:\n        list {ZamanKonumHız} --  her bir zaman adımı için zaman konum hız değerlerini içeren liste\n    \"\"\"\n\n    # adımSayısı ve zaman listesini oluştur\n    adımSayısı = (tSon-pvt0.t)/tAdım + 1\n    zamanListesi = np.asarray(np.linspace(pvt0.t, tSon, num = adımSayısı, endpoint=True))\n    \n    # diff denklem başlangıç değerlerini oluştur\n    diffIlkDeğer = np.asarray(np.concatenate([pvt0.r, pvt0.v]))\n    \n    # diff denklemi başlangıç zamanından son zamana dek çöz\n    diffDenkÇözüm = solve_ivp(odeDiffDenklem, [pvt0.t, tSon], diffIlkDeğer, method=çözücüTipi.value, \n                                                                  dense_output=True, rtol = 1e-12, atol = 1e-15) \n\n    \n    # zaman listesine karşılık gelen değerleri oluştur\n    cozumListesi = diffDenkÇözüm.sol.__call__(zamanListesi)\n    \n    # sonuç listesini başlat\n    numPvtList = []\n\n    # Listeyi objelere dönştür\n    for i in range(len(zamanListesi)):\n        pvArray = cozumListesi[:, i]\n        numPvtList.append( ZamanKonumHız(zamanListesi[i], pvArray[0], pvArray[1], pvArray[2], pvArray[3]) )\n\n    return (numPvtList)\n\nBurada bir değişiklik daha yaptık ve solve_ivp’yi çağırırken method=çözücüTipi.value, dense_output=True, rtol = 1e-12, atol = 1e-15 parametre setini de ekledik. Bu üçlünün detaylarına girmeyeceğim, ama sadece hata kontrolünün burada yapıldığını söylemekle yetineyim. Yani buradaki rtol ve atol ile verilen bağıl ve mutlak tolerans değerlerini ne kadar küçük seçerseniz diferansiyel denklem çözücüsünü de o kadar hatasız ve elbette küçük adımlarla ve yavaş çalışmaya zorlarsınız. Farklı tolerans değerlerini deneyip hatanın nasıl değiştiğini kendiniz de görebilirsiniz.\nKalan kısımlarda önemli bir değişiklik yapmayacağız, sadece bu kez de RK45 adlı çözücüyü deneyip RK23 ile karşılaştıracağız. Kalan tüm değerler ve Euler ilerleticiler öncekilerle aynı olduğu için buraya eklemedim.\n\n# *********** ana kod yapısı ***********\n\n# başlangıç zamanı\nt0 = 0\n# bitiş zamanı (sn)\ntSon = 6000\n# adım büyüklüğü (sn)\ntAdımEuler_1  = 5\ntAdımEuler_2  = 1\ntAdımODE = 60\nçözücüTipi1 = ODEÇözücüTipi.RK23\nçözücüTipi2 = ODEÇözücüTipi.RK45\n\n# başlangıç konum ve hız\npvt0 = ZamanKonumHız(t0, 0, 7000*1E3, 7.5*1E3, 0)\n\n\n# Euler sayısal integrasyon verisini hesaplayan döngüyü çalıştır\neulPvtList5  = hesapDöngüsüEuler(pvt0, tAdımEuler_1, tSon)\neulPvtList1  = hesapDöngüsüEuler(pvt0, tAdımEuler_2, tSon)\n\nçözücüPvtList1 = odeÇözümü(pvt0, tAdımODE, tSon, çözücüTipi1)\nçözücüPvtList2 = odeÇözümü(pvt0, tAdımODE, tSon, çözücüTipi2)\n\n/home/egemen/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:17: DeprecationWarning: object of type &lt;class 'float'&gt; cannot be safely interpreted as an integer.\n\n\nSon olarak, yeni diferansiyel çözücümüz RK45’in sonuçlarını görmek için grafiklere tekrar bakalım:\n\n# *********** grafikler ***********\n\n# konum grafiği\nplt.plot( [pvt.r[0] for pvt in çözücüPvtList2], [pvt.r[1] for pvt in çözücüPvtList2], label=çözücüTipi2.value + \" (\" + str(tAdımODE) + \" s)\")\n\nplt.title(\"Konum\")\nplt.xlabel(\"x konum (m)\")\nplt.ylabel('y konum (m)')\n\nplt.axes().set_aspect('equal')\nplt.grid(b=True, which='major', linestyle='--')\n\nplt.show()\n\n# hız grafiği\nplt.plot( [pvt.v[0] for pvt in çözücüPvtList2], [pvt.v[1] for pvt in çözücüPvtList2], label=çözücüTipi2.value + \" (\" + str(tAdımODE) + \" s)\")\n\nplt.title(\"Hız\")\nplt.xlabel(\"x hız (m/s)\")\nplt.ylabel(\"y hız (m/s)\")\n\nplt.axes().set_aspect('equal')\nplt.grid(b=True, which='major', linestyle='--')\n\nplt.show() \n\n# enerji grafikleri\n\n#referans değer - tüm farklar bu değere göre hesaplanacak\nspEnerjiRef = pvt0.spesifikEnerji()\n\nplt.title(\"Spesifik Enerji Değişimi\")\nplt.xlabel(\"zaman (s)\")\nplt.ylabel(\"spesifik enerji ($m^2/s^2$)\")\nplt.yscale('log')\n\nplt.plot( [pvt.t for pvt in eulPvtList1], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in eulPvtList1], label=\"Euler (\" + str(tAdımEuler_2) + \" s)\")\nplt.plot( [pvt.t for pvt in eulPvtList5], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in eulPvtList5], label=\"Euler (\" + str(tAdımEuler_1) + \" s)\")\nplt.plot( [pvt.t for pvt in çözücüPvtList1], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in çözücüPvtList1], label=çözücüTipi1.value + \" (\" + str(tAdımODE) + \" s)\")\nplt.plot( [pvt.t for pvt in çözücüPvtList2], [np.abs(pvt.spesifikEnerji()-spEnerjiRef) for pvt in çözücüPvtList2], label=çözücüTipi2.value + \" (\" + str(tAdımODE) + \" s)\")\n\nplt.legend(loc=4)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\nStandart bir RK23 ile geçen sefer enerjiyi 1 saniye adım büyüklüğüne sahip Euler’den 10 kat daha iyi koruduğumuzu söylemiştik. Bu kez sıkı bir adım kontrolü kullanan bir RK45 ile, Euler’e oranla enerjiyi 10,000,000,000 (10 milyar) kez daha iyi koruduk! Bu kadar iyi bir sonucu elde etmek için daha fazla kod yazmamız da gerekmedi zira scipy bize tüm bu imkanları hazır olarak sunuyor. RK23 de RK45’e yakın bir performans gösterdi, çünkü sıkı adım kontrolünü ona da uyguladık. Ancak muhtemelen otomatik seçilen adım büyüklükleri RK45’ten daha küçük kaldı; diğer bir deyişle, kullandığımız metod olan RK23, RK45’ten daha kötü olduğu için aynı performansı gösterebilmek için daha çok çalıştı. Gerçek problemlerde, kullanacağımız sayısal integrasyon metodunun seçimi kritik önem teşkil eder. Diferansiyel denklemin bir adımını çözmek için gereken hesaplama kapasitesi, problemin non-lineerliği ve ne kadar ani değişiklikler gösterdiği, problemi ne kadar uzun süre modelleyeceğimiz ile elbette doğruya ne kadar yakın sonuçlar istediğimize bağlı olarak seçeceğimiz matematiksel model değişiklik gösterir. Bu durumda, genellikle farklı modellerle uzun uzadıya performans testleri yaparak en uygun model seçilir.\nÖzetle, bu örneğimizde sonunda numpy ve scipy kütüphanelerine bir başlangıç yaptık ve kod organizasyonu, işlevlerin ayrılması, kodun yeniden kullanımı gibi yazılımcılık zanaatının temel prensiplerinden bahsettik. Bu arada iki cisim gibi basit bir problemin çözümünde bile, fizik kanunları ve matematiksel modeller arasındaki ilişkinin ne kadar çetrefilli olabileceğine kısaca değindik. Son olarak ikinci derece bir diferansiyel denklemin nasıl çözülebileceğine dair de küçük bir örnek yaptık.\nBu yazıyı da, her zamanki gibi, çalıştırılabilir bir Jupyter defteri halinde, yazıdaki iki örneğin kodlarıyla birlikte GitHub sayfamızda bulabilirsiniz."
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "Veri Defteri",
    "section": "",
    "text": "Site Quarto ile hazırlanmaktadır. Öncelikle bilgisayarınıza Quarto kurun ve çalıştırın.\nVSCode kullanıyorsanız Quarto eklentisini kurmak kolaylık sağlar.\nBu repoyu bilgisayarınıza indirin\n$ gh repo clone mkozturk/veridefteri.com\nQuarto, kod içeren belgeleri çalıştıracaktır. Bunun için bir hesaplama ortamı oluşturmak gerekiyor. Çalışma dizininde bir virtual environment yaratın ve aktifleştirin:\n$ cd veridefteri.com\n$ python -m venv .venv\n$ source .venv/bin/activate\nArdından requirements.txt kullanarak gerekli paketleri yeni sanal ortama kurun.\n(.venv)$ pip install -r requirement.txt\nEğer yazınız için yeni bir kütüphane gerekiyorsa requirements.txt içine ekleyip işlemi tekrarlayın. Yeni halini github reposuna push etmeyi unutmayın.\n\n\n\nYazınızı önceden Markdown olarak hazırlayabilirsiniz. Quarto belgeleri pandoc markdown kullanır.\nJupyter notebook (ipynb) belgelerini de doğrudan alabilir. Web sitesini hazırlarken bunları HTML’ye dönüştürür.\n\n\nQuarto, posts/ dizini altındaki .qmd veya .ipynb belgelerini birer blog yazısına dönüştürür. Yazılar posts/&lt;yıl&gt;/&lt;ay&gt;/&lt;gün&gt;/&lt;yazı-basligi&gt;/index.ipynb yapısıyla düzenlenmelidir. Örneğin\nposts/2017/10/30/jupyter-notebook-nedir/index.ipynb\nBu şekilde yazı, veridefteri.com/posts/2017/10/30/jupyter-notebook-nedir/ URL’sinde yayınlanacak. Böylece orijinal Wordpress URL’lerimize yakın bir yapı olacak. (posts/ parçası hariç)\nYazıyla ilgili dosyaları (resim, modül, data vs) yazıyla aynı dizine, veya bir altdizine koyabilirsiniz.\nAlternatif olarak index.qmd kullanılabilir. Jupyter belgesini qmd’ye çevirmek için:\n$ quarto convert my_notebook.ipynb --output index.qmd\n\n\n\nHer yazının en üstünde yazının başlığı, yazarı, tarihi ve kategorilerini belirten, üç çizgiyle başlayıp biten, YAML formatında metaveri bulunmalı. Örneğin\n---\ntitle: Aşırı Öğrenme ve Eksik Öğrenme\nauthor: Birol Yüceoğlu\ndate: '2017-11-07'\ncategories:\n    - yapay öğrenme\n---\nBu metaveri qmd formatındaki dosyanın başına eklenebilir. Belgeniz ipynb formatındaysa en başa “raw” bir metin hücresi olarak eklenmelidir (markdown hücresi olmaz).\nposts/_metadata.yml dosyasındaki metaveriler bütün yazılara uygulanır.\n\n\n\nVSCode Quarto eklentisi kullanıyorsanız editör penceresinin sağ üstündeki “Preview” düğmesine tıklayın. Bu yazıyı (veya proje kökünde index.qmd içindeyseniz siteyi) tekrar render edip önizleme açacak.\nAlternatif olarak, komut satırında\n$ quarto render\nveya\n$ quarto render yeni_yazim.qmd\nkomutlarını verebilirsiniz. Ardından\n$ quarto preview\nkomutu, siteyi yerel olarak hazırlayıp bilgisayarınızda başlattığı bir sunucu ile bir ön izleme yapacak.\nAlternatif olarak tarayıcınızda _site/index.html sayfasını açarak önizleme yapabilirsiniz.\n\n\n\n\nSiteyi Github Pages ile yayınlıyoruz.\nYazınızı hazırladıktan sonra, terminal açın ve web sitesi projesinin dizini içinde şu komutu verin:\n$ quarto publish gh-pages\nBu komut mevcut belgelerden site içeriğini hazırlayacak, çıktıyı özel bir gh-pages dalına yükleyecek, bu dalı GitHub’a push edecek ve sitemizin güncellenmesini sağlayacak.\nAyrıntılı bilgi için:\nhttps://quarto.org/docs/publishing/github-pages.html#publish-command"
  },
  {
    "objectID": "readme.html#kurulum",
    "href": "readme.html#kurulum",
    "title": "Veri Defteri",
    "section": "",
    "text": "Site Quarto ile hazırlanmaktadır. Öncelikle bilgisayarınıza Quarto kurun ve çalıştırın.\nVSCode kullanıyorsanız Quarto eklentisini kurmak kolaylık sağlar.\nBu repoyu bilgisayarınıza indirin\n$ gh repo clone mkozturk/veridefteri.com\nQuarto, kod içeren belgeleri çalıştıracaktır. Bunun için bir hesaplama ortamı oluşturmak gerekiyor. Çalışma dizininde bir virtual environment yaratın ve aktifleştirin:\n$ cd veridefteri.com\n$ python -m venv .venv\n$ source .venv/bin/activate\nArdından requirements.txt kullanarak gerekli paketleri yeni sanal ortama kurun.\n(.venv)$ pip install -r requirement.txt\nEğer yazınız için yeni bir kütüphane gerekiyorsa requirements.txt içine ekleyip işlemi tekrarlayın. Yeni halini github reposuna push etmeyi unutmayın."
  },
  {
    "objectID": "readme.html#yazının-hazırlanması",
    "href": "readme.html#yazının-hazırlanması",
    "title": "Veri Defteri",
    "section": "",
    "text": "Yazınızı önceden Markdown olarak hazırlayabilirsiniz. Quarto belgeleri pandoc markdown kullanır.\nJupyter notebook (ipynb) belgelerini de doğrudan alabilir. Web sitesini hazırlarken bunları HTML’ye dönüştürür.\n\n\nQuarto, posts/ dizini altındaki .qmd veya .ipynb belgelerini birer blog yazısına dönüştürür. Yazılar posts/&lt;yıl&gt;/&lt;ay&gt;/&lt;gün&gt;/&lt;yazı-basligi&gt;/index.ipynb yapısıyla düzenlenmelidir. Örneğin\nposts/2017/10/30/jupyter-notebook-nedir/index.ipynb\nBu şekilde yazı, veridefteri.com/posts/2017/10/30/jupyter-notebook-nedir/ URL’sinde yayınlanacak. Böylece orijinal Wordpress URL’lerimize yakın bir yapı olacak. (posts/ parçası hariç)\nYazıyla ilgili dosyaları (resim, modül, data vs) yazıyla aynı dizine, veya bir altdizine koyabilirsiniz.\nAlternatif olarak index.qmd kullanılabilir. Jupyter belgesini qmd’ye çevirmek için:\n$ quarto convert my_notebook.ipynb --output index.qmd\n\n\n\nHer yazının en üstünde yazının başlığı, yazarı, tarihi ve kategorilerini belirten, üç çizgiyle başlayıp biten, YAML formatında metaveri bulunmalı. Örneğin\n---\ntitle: Aşırı Öğrenme ve Eksik Öğrenme\nauthor: Birol Yüceoğlu\ndate: '2017-11-07'\ncategories:\n    - yapay öğrenme\n---\nBu metaveri qmd formatındaki dosyanın başına eklenebilir. Belgeniz ipynb formatındaysa en başa “raw” bir metin hücresi olarak eklenmelidir (markdown hücresi olmaz).\nposts/_metadata.yml dosyasındaki metaveriler bütün yazılara uygulanır.\n\n\n\nVSCode Quarto eklentisi kullanıyorsanız editör penceresinin sağ üstündeki “Preview” düğmesine tıklayın. Bu yazıyı (veya proje kökünde index.qmd içindeyseniz siteyi) tekrar render edip önizleme açacak.\nAlternatif olarak, komut satırında\n$ quarto render\nveya\n$ quarto render yeni_yazim.qmd\nkomutlarını verebilirsiniz. Ardından\n$ quarto preview\nkomutu, siteyi yerel olarak hazırlayıp bilgisayarınızda başlattığı bir sunucu ile bir ön izleme yapacak.\nAlternatif olarak tarayıcınızda _site/index.html sayfasını açarak önizleme yapabilirsiniz."
  },
  {
    "objectID": "readme.html#yazıyı-yayınlamak",
    "href": "readme.html#yazıyı-yayınlamak",
    "title": "Veri Defteri",
    "section": "",
    "text": "Siteyi Github Pages ile yayınlıyoruz.\nYazınızı hazırladıktan sonra, terminal açın ve web sitesi projesinin dizini içinde şu komutu verin:\n$ quarto publish gh-pages\nBu komut mevcut belgelerden site içeriğini hazırlayacak, çıktıyı özel bir gh-pages dalına yükleyecek, bu dalı GitHub’a push edecek ve sitemizin güncellenmesini sağlayacak.\nAyrıntılı bilgi için:\nhttps://quarto.org/docs/publishing/github-pages.html#publish-command"
  }
]